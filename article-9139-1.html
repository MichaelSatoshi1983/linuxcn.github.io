<!doctype html><html lang="en"><head><meta name="msvalidate.01" content="D404690CEFCB54C7762AC84935B99171"><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?6618da70c90c8744eead2e9371fb5077";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><script type="text/javascript">!function(t,e,n,c,s,a,r){t[n]=t[n]||function(){(t[n].q=t[n].q||[]).push(arguments)},(a=e.createElement(c)).async=1,a.src="https://www.clarity.ms/tag/s5f3f0tojf",(r=e.getElementsByTagName(c)[0]).parentNode.insertBefore(a,r)}(window,document,"clarity","script")</script><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta http-equiv="X-UA-Compatible" content="ie=edge"><link rel="stylesheet" href="/styles/base.css"><link rel="stylesheet" href="/styles/theme.css"><link rel="shortcut icon" href="/favicon.png"><title>7 个使用 bcc/BPF 的性能分析神器 - 归墟星火集</title><meta name="generator" content="Hexo 7.3.0"></head><body><div class="header-title"><span class="header-light"></span> <span class="header-light"></span> <span class="header-light"></span> <span>归墟星火集 linuxcn.undefined.today<span></span></span></div><div class="container"><ul class="nav"><li><a href="/">首页</a></li><li><a href="/about/">关于</a></li><li><a target="_blank" rel="noopener" href="https://undefined.today/">Blog</a></li></ul><div class="content"><div class="post-container"><div class="post-header"><span class="ui-tips">标题：</span><h1 class="ui-keyword post-title">7 个使用 bcc/BPF 的性能分析神器</h1><span class="post-date">2017-12-13</span></div><div class="post-header"><span class="ui-tips">分类：</span> <a href="/categories/%E6%8A%80%E6%9C%AF/">技术</a></div><div class="post-header"><span class="ui-tips">标签：</span> <a href="/tags/%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/">性能分析</a> <a href="/tags/BPF/">BPF</a> <a href="/tags/eBPF/">eBPF</a> <a href="/tags/bcc/">bcc</a></div><div class="post-content"><blockquote><p>使用<ruby>伯克利包过滤器 <rt>Berkeley Packet Filter</rt></ruby>（BPF）<ruby>编译器集合 <rt>Compiler Collection</rt></ruby>（BCC）工具深度探查你的 Linux 代码。</p></blockquote><p><img src="https://linuxcn.img.undefined.today/data/attachment/album/201712/13/145007s235twz5tuib4sty.jpg"></p><p>在 Linux 中出现的一种新技术能够为系统管理员和开发者提供大量用于性能分析和故障排除的新工具和仪表盘。它被称为<ruby>增强的伯克利数据包过滤器 <rt>enhanced Berkeley Packet Filter</rt></ruby>（eBPF，或 BPF），虽然这些改进并不是由伯克利开发的，而且它们不仅仅是处理数据包，更多的是过滤。我将讨论在 Fedora 和 Red Hat Linux 发行版中使用 BPF 的一种方法，并在 Fedora 26 上演示。</p><p>BPF 可以在内核中运行由用户定义的沙盒程序，可以立即添加新的自定义功能。这就像按需给 Linux 系统添加超能力一般。 你可以使用它的例子包括如下：</p><ul><li><strong>高级性能跟踪工具</strong>：对文件系统操作、TCP 事件、用户级事件等的可编程的低开销检测。</li><li><strong>网络性能</strong>： 尽早丢弃数据包以提高对 DDoS 的恢复能力，或者在内核中重定向数据包以提高性能。</li><li><strong>安全监控</strong>： 7x24 小时的自定义检测和记录内核空间与用户空间内的可疑事件。</li></ul><p>在可能的情况下，BPF 程序必须通过一个内核验证机制来保证它们的安全运行，这比写自定义的内核模块更安全。我在此假设大多数人并不编写自己的 BPF 程序，而是使用别人写好的。在 GitHub 上的 <a target="_blank" rel="noopener" href="https://github.com/iovisor/bcc">BPF Compiler Collection (bcc)</a> 项目中，我已发布许多开源代码。bcc 为 BPF 开发提供了不同的前端支持，包括 Python 和 Lua，并且是目前最活跃的 BPF 工具项目。</p><h3 id="7-个有用的-bcc-BPF-新工具"><a href="#7-个有用的-bcc-BPF-新工具" class="headerlink" title="7 个有用的 bcc&#x2F;BPF 新工具"></a>7 个有用的 bcc&#x2F;BPF 新工具</h3><p>为了了解 bcc&#x2F;BPF 工具和它们的检测内容，我创建了下面的图表并添加到 bcc 项目中。</p><p><img src="https://linuxcn.img.undefined.today/data/attachment/album/201712/13/145136hwlo4w4jow1wtwjj.png" alt="Linux bcc&#x2F;BPF 跟踪工具图"></p><p>这些是命令行界面工具，你可以通过 SSH 使用它们。目前大多数分析，包括我的老板，都是用 GUI 和仪表盘进行的。SSH 是最后的手段。但这些命令行工具仍然是预览 BPF 能力的好方法，即使你最终打算通过一个可用的 GUI 使用它。我已着手向一个开源 GUI 添加 BPF 功能，但那是另一篇文章的主题。现在我想向你分享今天就可以使用的 CLI 工具。</p><h4 id="1、-execsnoop"><a href="#1、-execsnoop" class="headerlink" title="1、 execsnoop"></a>1、 execsnoop</h4><p>从哪儿开始呢？如何查看新的进程。那些会消耗系统资源，但很短暂的进程，它们甚至不会出现在 <code>top(1)</code> 命令或其它工具中的显示之中。这些新进程可以使用 <a target="_blank" rel="noopener" href="https://github.com/brendangregg/perf-tools/blob/master/execsnoop">execsnoop</a> 进行检测（或使用行业术语说，可以<ruby>被追踪 <rt>traced</rt></ruby>）。 在追踪时，我将在另一个窗口中通过 SSH 登录：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># /usr/share/bcc/tools/execsnoop</span><br><span class="line">PCOMM            PID    PPID   RET ARGS</span><br><span class="line">sshd             12234  727      0 /usr/sbin/sshd -D -R</span><br><span class="line">unix_chkpwd      12236  12234    0 /usr/sbin/unix_chkpwd root nonull</span><br><span class="line">unix_chkpwd      12237  12234    0 /usr/sbin/unix_chkpwd root chkexpiry</span><br><span class="line">bash             12239  12238    0 /bin/bash</span><br><span class="line">id               12241  12240    0 /usr/bin/id -un</span><br><span class="line">hostname         12243  12242    0 /usr/bin/hostname</span><br><span class="line">pkg-config       12245  12244    0 /usr/bin/pkg-config --variable=completionsdir bash-completion</span><br><span class="line">grepconf.sh      12246  12239    0 /usr/libexec/grepconf.sh -c</span><br><span class="line">grep             12247  12246    0 /usr/bin/grep -qsi ^COLOR.*none /etc/GREP_COLORS</span><br><span class="line">tty              12249  12248    0 /usr/bin/tty -s</span><br><span class="line">tput             12250  12248    0 /usr/bin/tput colors</span><br><span class="line">dircolors        12252  12251    0 /usr/bin/dircolors --sh /etc/DIR_COLORS</span><br><span class="line">grep             12253  12239    0 /usr/bin/grep -qi ^COLOR.*none /etc/DIR_COLORS</span><br><span class="line">grepconf.sh      12254  12239    0 /usr/libexec/grepconf.sh -c</span><br><span class="line">grep             12255  12254    0 /usr/bin/grep -qsi ^COLOR.*none /etc/GREP_COLORS</span><br><span class="line">grepconf.sh      12256  12239    0 /usr/libexec/grepconf.sh -c</span><br><span class="line">grep             12257  12256    0 /usr/bin/grep -qsi ^COLOR.*none /etc/GREP_COLORS</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>哇哦。 那是什么？ 什么是 <code>grepconf.sh</code>？ 什么是 <code>/etc/GREP_COLORS</code>？ 是 <code>grep</code> 在读取它自己的配置文件……由 <code>grep</code> 运行的？ 这究竟是怎么工作的？</p><p>欢迎来到有趣的系统追踪世界。 你可以学到很多关于系统是如何工作的（或者根本不工作，在有些情况下），并且发现一些简单的优化方法。 <code>execsnoop</code> 通过跟踪 <code>exec()</code> 系统调用来工作，<code>exec()</code> 通常用于在新进程中加载不同的程序代码。</p><h4 id="2、-opensnoop"><a href="#2、-opensnoop" class="headerlink" title="2、 opensnoop"></a>2、 opensnoop</h4><p>接着上面继续，所以，<code>grepconf.sh</code> 可能是一个 shell 脚本，对吧？ 我将运行 <code>file(1)</code> 来检查它，并使用<a target="_blank" rel="noopener" href="https://github.com/brendangregg/perf-tools/blob/master/opensnoop">opensnoop</a> bcc 工具来查看打开的文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># /usr/share/bcc/tools/opensnoop</span><br><span class="line">PID    COMM               FD ERR PATH</span><br><span class="line">12420  file                3   0 /etc/ld.so.cache</span><br><span class="line">12420  file                3   0 /lib64/libmagic.so.1</span><br><span class="line">12420  file                3   0 /lib64/libz.so.1</span><br><span class="line">12420  file                3   0 /lib64/libc.so.6</span><br><span class="line">12420  file                3   0 /usr/lib/locale/locale-archive</span><br><span class="line">12420  file               -1   2 /etc/magic.mgc</span><br><span class="line">12420  file                3   0 /etc/magic</span><br><span class="line">12420  file                3   0 /usr/share/misc/magic.mgc</span><br><span class="line">12420  file                3   0 /usr/lib64/gconv/gconv-modules.cache</span><br><span class="line">12420  file                3   0 /usr/libexec/grepconf.sh</span><br><span class="line">1      systemd            16   0 /proc/565/cgroup</span><br><span class="line">1      systemd            16   0 /proc/536/cgroup</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>像 <code>execsnoop</code> 和 <code>opensnoop</code> 这样的工具会将每个事件打印一行。上图显示 <code>file(1)</code> 命令当前打开（或尝试打开）的文件：返回的文件描述符（“FD” 列）对于 <code>/etc/magic.mgc</code> 是 -1，而 “ERR” 列指示它是“文件未找到”。我不知道该文件，也不知道 <code>file(1)</code> 正在读取的 <code>/usr/share/misc/magic.mgc</code> 文件是什么。我不应该感到惊讶，但是 <code>file(1)</code> 在识别文件类型时没有问题：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># file /usr/share/misc/magic.mgc /etc/magic</span><br><span class="line">/usr/share/misc/magic.mgc: magic binary file for file(1) cmd (version 14) (little endian)</span><br><span class="line">/etc/magic:                magic text file for file(1) cmd, ASCII text</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>opensnoop</code> 通过跟踪 <code>open()</code> 系统调用来工作。为什么不使用 <code>strace -feopen file</code> 命令呢？ 在这种情况下是可以的。然而，<code>opensnoop</code> 的一些优点在于它能在系统范围内工作，并且跟踪所有进程的 <code>open()</code> 系统调用。注意上例的输出中包括了从 systemd 打开的文件。<code>opensnoop</code> 应该系统开销更低：BPF 跟踪已经被优化过，而当前版本的 <code>strace(1)</code> 仍然使用较老和较慢的 <code>ptrace(2)</code> 接口。</p><h4 id="3、-xfsslower"><a href="#3、-xfsslower" class="headerlink" title="3、 xfsslower"></a>3、 xfsslower</h4><p>bcc&#x2F;BPF 不仅仅可以分析系统调用。<a target="_blank" rel="noopener" href="https://github.com/iovisor/bcc/blob/master/tools/xfsslower.py">xfsslower</a> 工具可以跟踪大于 1 毫秒（参数）延迟的常见 XFS 文件系统操作。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># /usr/share/bcc/tools/xfsslower 1</span><br><span class="line">Tracing XFS operations slower than 1 ms</span><br><span class="line">TIME     COMM           PID    T BYTES   OFF_KB   LAT(ms) FILENAME</span><br><span class="line">14:17:34 systemd-journa 530    S 0       0           1.69 system.journal</span><br><span class="line">14:17:35 auditd         651    S 0       0           2.43 audit.log</span><br><span class="line">14:17:42 cksum          4167   R 52976   0           1.04 at</span><br><span class="line">14:17:45 cksum          4168   R 53264   0           1.62 [</span><br><span class="line">14:17:45 cksum          4168   R 65536   0           1.01 certutil</span><br><span class="line">14:17:45 cksum          4168   R 65536   0           1.01 dir</span><br><span class="line">14:17:45 cksum          4168   R 65536   0           1.17 dirmngr-client</span><br><span class="line">14:17:46 cksum          4168   R 65536   0           1.06 grub2-file</span><br><span class="line">14:17:46 cksum          4168   R 65536   128         1.01 grub2-fstest</span><br><span class="line">[...]</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在上图输出中，我捕获到了多个延迟超过 1 毫秒 的 <code>cksum(1)</code> 读取操作（字段 “T” 等于 “R”）。这是在 <code>xfsslower</code> 工具运行的时候，通过在 XFS 中动态地检测内核函数实现的，并当它结束的时候解除该检测。这个 bcc 工具也有其它文件系统的版本：<code>ext4slower</code>、<code>btrfsslower</code>、<code>zfsslower</code> 和 <code>nfsslower</code>。</p><p>这是个有用的工具，也是 BPF 追踪的重要例子。对文件系统性能的传统分析主要集中在块 I&#x2F;O 统计信息 —— 通常你看到的是由 <code>iostat(1)</code> 工具输出，并由许多性能监视 GUI 绘制的图表。这些统计数据显示的是磁盘如何执行，而不是真正的文件系统如何执行。通常比起磁盘来说，你更关心的是文件系统的性能，因为应用程序是在文件系统中发起请求和等待。并且，文件系统的性能可能与磁盘的性能大为不同！文件系统可以完全从内存缓存中读取数据，也可以通过预读算法和回写缓存来填充缓存。<code>xfsslower</code> 显示了文件系统的性能 —— 这是应用程序直接体验到的性能。通常这对于排除整个存储子系统的问题是有用的；如果确实没有文件系统延迟，那么性能问题很可能是在别处。</p><h4 id="4、-biolatency"><a href="#4、-biolatency" class="headerlink" title="4、 biolatency"></a>4、 biolatency</h4><p>虽然文件系统性能对于理解应用程序性能非常重要，但研究磁盘性能也是有好处的。当各种缓存技巧都无法挽救其延迟时，磁盘的低性能终会影响应用程序。 磁盘性能也是容量规划研究的目标。</p><p><code>iostat(1)</code> 工具显示了平均磁盘 I&#x2F;O 延迟，但平均值可能会引起误解。 以直方图的形式研究 I&#x2F;O 延迟的分布是有用的，这可以通过使用 [biolatency] 来实现<a target="_blank" rel="noopener" href="https://github.com/iovisor/bcc/blob/master/tools/biolatency.py">18</a>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># /usr/share/bcc/tools/biolatency</span><br><span class="line">Tracing block device I/O... Hit Ctrl-C to end.</span><br><span class="line">^C</span><br><span class="line">     usecs               : count     distribution</span><br><span class="line">         0 -&gt; 1          : 0        |                                        |</span><br><span class="line">         2 -&gt; 3          : 0        |                                        |</span><br><span class="line">         4 -&gt; 7          : 0        |                                        |</span><br><span class="line">         8 -&gt; 15         : 0        |                                        |</span><br><span class="line">        16 -&gt; 31         : 0        |                                        |</span><br><span class="line">        32 -&gt; 63         : 1        |                                        |</span><br><span class="line">        64 -&gt; 127        : 63       |****                                    |</span><br><span class="line">       128 -&gt; 255        : 121      |*********                               |</span><br><span class="line">       256 -&gt; 511        : 483      |************************************    |</span><br><span class="line">       512 -&gt; 1023       : 532      |****************************************|</span><br><span class="line">      1024 -&gt; 2047       : 117      |********                                |</span><br><span class="line">      2048 -&gt; 4095       : 8        |                                        |</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这是另一个有用的工具和例子；它使用一个名为 maps 的 BPF 特性，它可以用来实现高效的内核摘要统计。从内核层到用户层的数据传输仅仅是“计数”列。 用户级程序生成其余的。</p><p>值得注意的是，这种工具大多支持 CLI 选项和参数，如其使用信息所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"># /usr/share/bcc/tools/biolatency -h</span><br><span class="line">usage: biolatency [-h] [-T] [-Q] [-m] [-D] [interval] [count]</span><br><span class="line"></span><br><span class="line">Summarize block device I/O latency as a histogram</span><br><span class="line"></span><br><span class="line">positional arguments:</span><br><span class="line">  interval            output interval, in seconds</span><br><span class="line">  count               number of outputs</span><br><span class="line"></span><br><span class="line">optional arguments:</span><br><span class="line">  -h, --help          show this help message and exit</span><br><span class="line">  -T, --timestamp     include timestamp on output</span><br><span class="line">  -Q, --queued        include OS queued time in I/O time</span><br><span class="line">  -m, --milliseconds  millisecond histogram</span><br><span class="line">  -D, --disks         print a histogram per disk device</span><br><span class="line"></span><br><span class="line">examples:</span><br><span class="line">    ./biolatency            # summarize block I/O latency as a histogram</span><br><span class="line">    ./biolatency 1 10       # print 1 second summaries, 10 times</span><br><span class="line">    ./biolatency -mT 1      # 1s summaries, milliseconds, and timestamps</span><br><span class="line">    ./biolatency -Q         # include OS queued time in I/O time</span><br><span class="line">    ./biolatency -D         # show each disk device separately</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>它们的行为就像其它 Unix 工具一样，以利于采用而设计。</p><h4 id="5、-tcplife"><a href="#5、-tcplife" class="headerlink" title="5、 tcplife"></a>5、 tcplife</h4><p>另一个有用的工具是 <a target="_blank" rel="noopener" href="https://github.com/iovisor/bcc/blob/master/tools/tcplife.py">tcplife</a> ，该例显示 TCP 会话的生命周期和吞吐量统计。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># /usr/share/bcc/tools/tcplife</span><br><span class="line">PID   COMM       LADDR           LPORT RADDR           RPORT TX_KB RX_KB MS</span><br><span class="line">12759 sshd       192.168.56.101  22    192.168.56.1    60639     2     3 1863.82</span><br><span class="line">12783 sshd       192.168.56.101  22    192.168.56.1    60640     3     3 9174.53</span><br><span class="line">12844 wget       10.0.2.15       34250 54.204.39.132   443      11  1870 5712.26</span><br><span class="line">12851 curl       10.0.2.15       34252 54.204.39.132   443       0    74 505.90</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在你说 “我不是可以只通过 <code>tcpdump(8)</code> 就能输出这个？” 之前请注意，运行 <code>tcpdump(8)</code> 或任何数据包嗅探器，在高数据包速率的系统上的开销会很大，即使 <code>tcpdump(8)</code> 的用户层和内核层机制已经过多年优化（要不可能更差）。<code>tcplife</code> 不会测试每个数据包；它只会有效地监视 TCP 会话状态的变化，并由此得到该会话的持续时间。它还使用已经跟踪了吞吐量的内核计数器，以及进程和命令信息（“PID” 和 “COMM” 列），这些对于 <code>tcpdump(8)</code> 等线上嗅探工具是做不到的。</p><h4 id="6、-gethostlatency"><a href="#6、-gethostlatency" class="headerlink" title="6、 gethostlatency"></a>6、 gethostlatency</h4><p>之前的每个例子都涉及到内核跟踪，所以我至少需要一个用户级跟踪的例子。 这就是 <a target="_blank" rel="noopener" href="https://github.com/iovisor/bcc/blob/master/tools/gethostlatency.py">gethostlatency</a>，它检测用于名称解析的 <code>gethostbyname(3)</code> 和相关的库调用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># /usr/share/bcc/tools/gethostlatency</span><br><span class="line">TIME      PID    COMM                  LATms HOST</span><br><span class="line">06:43:33  12903  curl                 188.98 opensource.com</span><br><span class="line">06:43:36  12905  curl                   8.45 opensource.com</span><br><span class="line">06:43:40  12907  curl                   6.55 opensource.com</span><br><span class="line">06:43:44  12911  curl                   9.67 opensource.com</span><br><span class="line">06:45:02  12948  curl                  19.66 opensource.cats</span><br><span class="line">06:45:06  12950  curl                  18.37 opensource.cats</span><br><span class="line">06:45:07  12952  curl                  13.64 opensource.cats</span><br><span class="line">06:45:19  13139  curl                  13.10 opensource.cats</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>是的，总是有 DNS 请求，所以有一个工具来监视系统范围内的 DNS 请求会很方便（这只有在应用程序使用标准系统库时才有效）。看看我如何跟踪多个对 “opensource.com” 的查找？ 第一个是 188.98 毫秒，然后更快，不到 10 毫秒，毫无疑问，这是缓存的作用。它还追踪多个对 “opensource.cats” 的查找，一个不存在的可怜主机名，但我们仍然可以检查第一个和后续查找的延迟。（第二次查找后是否有一些否定缓存的影响？）</p><h4 id="7、-trace"><a href="#7、-trace" class="headerlink" title="7、 trace"></a>7、 trace</h4><p>好的，再举一个例子。 <a target="_blank" rel="noopener" href="https://github.com/iovisor/bcc/blob/master/tools/trace.py">trace</a> 工具由 Sasha Goldshtein 提供，并提供了一些基本的 <code>printf(1)</code> 功能和自定义探针。 例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># /usr/share/bcc/tools/trace &#x27;pam:pam_start &quot;%s: %s&quot;, arg1, arg2&#x27;</span><br><span class="line">PID    TID    COMM         FUNC             -</span><br><span class="line">13266  13266  sshd         pam_start        sshd: root</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在这里，我正在跟踪 <code>libpam</code> 及其 <code>pam_start(3)</code> 函数，并将其两个参数都打印为字符串。 <code>libpam</code> 用于插入式身份验证模块系统，该输出显示 sshd 为 “root” 用户调用了 <code>pam_start()</code>（我登录了）。 其使用信息中有更多的例子（<code>trace -h</code>），而且所有这些工具在 bcc 版本库中都有手册页和示例文件。 例如 <code>trace_example.txt</code> 和 <code>trace.8</code>。</p><h3 id="通过包安装-bcc"><a href="#通过包安装-bcc" class="headerlink" title="通过包安装 bcc"></a>通过包安装 bcc</h3><p>安装 bcc 最佳的方法是从 iovisor 仓储库中安装，按照 bcc 的 <a target="_blank" rel="noopener" href="https://github.com/iovisor/bcc/blob/master/INSTALL.md#fedora---binary">INSTALL.md</a> 进行即可。<a target="_blank" rel="noopener" href="https://www.iovisor.org/">IO Visor</a> 是包括了 bcc 的 Linux 基金会项目。4.x 系列 Linux 内核中增加了这些工具所使用的 BPF 增强功能，直到 4.9 添加了全部支持。这意味着拥有 4.8 内核的 Fedora 25 可以运行这些工具中的大部分。 使用 4.11 内核的 Fedora 26 可以全部运行它们（至少在目前是这样）。</p><p>如果你使用的是 Fedora 25（或者 Fedora 26，而且这个帖子已经在很多个月前发布了 —— 你好，来自遥远的过去！），那么这个通过包安装的方式是可以工作的。 如果您使用的是 Fedora 26，那么请跳至“通过源代码安装”部分，它避免了一个<a target="_blank" rel="noopener" href="https://reviews.llvm.org/rL302055">已修复的</a>的<a target="_blank" rel="noopener" href="https://github.com/iovisor/bcc/issues/1221">已知</a>错误。 这个错误修复目前还没有进入 Fedora 26 软件包的依赖关系。 我使用的系统是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># uname -a</span><br><span class="line">Linux localhost.localdomain 4.11.8-300.fc26.x86_64 #1 SMP Thu Jun 29 20:09:48 UTC 2017 x86_64 x86_64 x86_64 GNU/Linux</span><br><span class="line"># cat /etc/fedora-release</span><br><span class="line">Fedora release 26 (Twenty Six)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>以下是我所遵循的安装步骤，但请参阅 INSTALL.md 获取更新的版本：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># echo -e &#x27;[iovisor]\nbaseurl=https://repo.iovisor.org/yum/nightly/f25/$basearch\nenabled=1\ngpgcheck=0&#x27; | sudo tee /etc/yum.repos.d/iovisor.repo</span><br><span class="line"># dnf install bcc-tools</span><br><span class="line">[...]</span><br><span class="line">Total download size: 37 M</span><br><span class="line">Installed size: 143 M</span><br><span class="line">Is this ok [y/N]: y</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>安装完成后，您可以在 <code>/usr/share</code> 中看到新的工具：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># ls /usr/share/bcc/tools/</span><br><span class="line">argdist       dcsnoop              killsnoop       softirqs    trace</span><br><span class="line">bashreadline  dcstat               llcstat         solisten    ttysnoop</span><br><span class="line">[...]</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>试着运行其中一个：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># /usr/share/bcc/tools/opensnoop</span><br><span class="line">chdir(/lib/modules/4.11.8-300.fc26.x86_64/build): No such file or directory</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;/usr/share/bcc/tools/opensnoop&quot;, line 126, in </span><br><span class="line">    b = BPF(text=bpf_text)</span><br><span class="line">  File &quot;/usr/lib/python3.6/site-packages/bcc/__init__.py&quot;, line 284, in __init__</span><br><span class="line">    raise Exception(&quot;Failed to compile BPF module %s&quot; % src_file)</span><br><span class="line">Exception: Failed to compile BPF module</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>运行失败，提示 <code>/lib/modules/4.11.8-300.fc26.x86_64/build</code> 丢失。 如果你也遇到这个问题，那只是因为系统缺少内核头文件。 如果你看看这个文件指向什么（这是一个符号链接），然后使用 <code>dnf whatprovides</code> 来搜索它，它会告诉你接下来需要安装的包。 对于这个系统，它是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># dnf install kernel-devel-4.11.8-300.fc26.x86_64</span><br><span class="line">[...]</span><br><span class="line">Total download size: 20 M</span><br><span class="line">Installed size: 63 M</span><br><span class="line">Is this ok [y/N]: y</span><br><span class="line">[...]</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>现在：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># /usr/share/bcc/tools/opensnoop</span><br><span class="line">PID    COMM               FD ERR PATH</span><br><span class="line">11792  ls                  3   0 /etc/ld.so.cache</span><br><span class="line">11792  ls                  3   0 /lib64/libselinux.so.1</span><br><span class="line">11792  ls                  3   0 /lib64/libcap.so.2</span><br><span class="line">11792  ls                  3   0 /lib64/libc.so.6</span><br><span class="line">[...]</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>运行起来了。 这是捕获自另一个窗口中的 ls 命令活动。 请参阅前面的部分以使用其它有用的命令。</p><h3 id="通过源码安装"><a href="#通过源码安装" class="headerlink" title="通过源码安装"></a>通过源码安装</h3><p>如果您需要从源代码安装，您还可以在 <a target="_blank" rel="noopener" href="https://github.com/iovisor/bcc/blob/master/INSTALL.md#fedora---source">INSTALL.md</a> 中找到文档和更新说明。 我在 Fedora 26 上做了如下的事情：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">sudo dnf install -y bison cmake ethtool flex git iperf libstdc++-static \</span><br><span class="line">  python-netaddr python-pip gcc gcc-c++ make zlib-devel \</span><br><span class="line">  elfutils-libelf-devel</span><br><span class="line">sudo dnf install -y luajit luajit-devel  # for Lua support</span><br><span class="line">sudo dnf install -y \</span><br><span class="line">  http://pkgs.repoforge.org/netperf/netperf-2.6.0-1.el6.rf.x86_64.rpm</span><br><span class="line">sudo pip install pyroute2</span><br><span class="line">sudo dnf install -y clang clang-devel llvm llvm-devel llvm-static ncurses-devel</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>除 <code>netperf</code> 外一切妥当，其中有以下错误：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Curl error (28): Timeout was reached for http://pkgs.repoforge.org/netperf/netperf-2.6.0-1.el6.rf.x86_64.rpm [Connection timed out after 120002 milliseconds]</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>不必理会，<code>netperf</code> 是可选的，它只是用于测试，而 bcc 没有它也会编译成功。</p><p>以下是余下的 bcc 编译和安装步骤：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/iovisor/bcc.git</span><br><span class="line">mkdir bcc/build; cd bcc/build</span><br><span class="line">cmake .. -DCMAKE_INSTALL_PREFIX=/usr</span><br><span class="line">make</span><br><span class="line">sudo make install</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>现在，命令应该可以工作了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># /usr/share/bcc/tools/opensnoop</span><br><span class="line">PID    COMM               FD ERR PATH</span><br><span class="line">4131   date                3   0 /etc/ld.so.cache</span><br><span class="line">4131   date                3   0 /lib64/libc.so.6</span><br><span class="line">4131   date                3   0 /usr/lib/locale/locale-archive</span><br><span class="line">4131   date                3   0 /etc/localtime</span><br><span class="line">[...]</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="写在最后和其他的前端"><a href="#写在最后和其他的前端" class="headerlink" title="写在最后和其他的前端"></a>写在最后和其他的前端</h3><p>这是一个可以在 Fedora 和 Red Hat 系列操作系统上使用的新 BPF 性能分析强大功能的快速浏览。我演示了 BPF 的流行前端 <a target="_blank" rel="noopener" href="https://github.com/iovisor/bcc">bcc</a> ，并包括了其在 Fedora 上的安装说明。bcc 附带了 60 多个用于性能分析的新工具，这将帮助您充分利用 Linux 系统。也许你会直接通过 SSH 使用这些工具，或者一旦 GUI 监控程序支持 BPF 的话，你也可以通过它们来使用相同的功能。</p><p>此外，bcc 并不是正在开发的唯一前端。<a target="_blank" rel="noopener" href="https://github.com/iovisor/ply">ply</a> 和 <a target="_blank" rel="noopener" href="https://github.com/ajor/bpftrace">bpftrace</a>，旨在为快速编写自定义工具提供更高级的语言支持。此外，<a target="_blank" rel="noopener" href="https://sourceware.org/systemtap/">SystemTap</a> 刚刚发布<a target="_blank" rel="noopener" href="https://sourceware.org/ml/systemtap/2017-q4/msg00096.html">版本 3.2</a>，包括一个早期的实验性 eBPF 后端。 如果这个继续开发，它将为运行多年来开发的许多 SystemTap 脚本和 tapset（库）提供一个安全和高效的生产级引擎。（随同 eBPF 使用 SystemTap 将是另一篇文章的主题。）</p><p>如果您需要开发自定义工具，那么也可以使用 bcc 来实现，尽管语言比 SystemTap、ply 或 bpftrace 要冗长得多。我的 bcc 工具可以作为代码示例，另外我还贡献了用 Python 开发 bcc 工具的<a target="_blank" rel="noopener" href="https://github.com/iovisor/bcc/blob/master/docs/tutorial_bcc_python_developer.md">教程</a>。 我建议先学习 bcc 的 multi-tools，因为在需要编写新工具之前，你可能会从里面获得很多经验。 您可以从它们的 bcc 存储库<a target="_blank" rel="noopener" href="https://github.com/iovisor/bcc/blob/master/tools/funccount_example.txt">funccount</a>，<a target="_blank" rel="noopener" href="https://github.com/iovisor/bcc/blob/master/tools/funclatency_example.txt">funclatency</a>，<a target="_blank" rel="noopener" href="https://github.com/iovisor/bcc/blob/master/tools/funcslower_example.txt">funcslower</a>，<a target="_blank" rel="noopener" href="https://github.com/iovisor/bcc/blob/master/tools/stackcount_example.txt">stackcount</a>，<a target="_blank" rel="noopener" href="https://github.com/iovisor/bcc/blob/master/tools/trace_example.txt">trace</a> ，<a target="_blank" rel="noopener" href="https://github.com/iovisor/bcc/blob/master/tools/argdist_example.txt">argdist</a> 的示例文件中研究 bcc。</p><p>感谢 <a target="_blank" rel="noopener" href="http://opensource.com/">Opensource.com</a> 进行编辑。</p><h3 id="关于作者"><a href="#关于作者" class="headerlink" title="关于作者"></a>关于作者</h3><p>Brendan Gregg 是 Netflix 的一名高级性能架构师，在那里他进行大规模的计算机性能设计、分析和调优。</p><hr><p>via:<a target="_blank" rel="noopener" href="https://opensource.com/article/17/11/bccbpf-performance">https://opensource.com/article/17/11/bccbpf-performance</a></p><p>作者：<a target="_blank" rel="noopener" href="https://opensource.com/users/brendang">Brendan Gregg</a> 译者：<a target="_blank" rel="noopener" href="https://github.com/yongshouzhang">yongshouzhang</a> 校对：<a target="_blank" rel="noopener" href="https://github.com/wxy">wxy</a></p><p>本文由 <a target="_blank" rel="noopener" href="https://github.com/LCTT/TranslateProject">LCTT</a> 原创编译，<a target="_blank" rel="noopener" href="https://linux.cn/">Linux中国</a> 荣誉推出</p></div></div></div><div class="footer"><p class="footer-copyright"><span>Powered by <a target="_blank" href="https://hexo.io">Hexo</a></span> <span>Theme <a target="_blank" href="https://github.com/tinkink-co/hexo-theme-terminal">Terminal</a></span><script type="text/javascript" src="https://cdn.staticfile.net/jquery/3.4.1/jquery.min.js"></script><script>getCDNinfo=function(){$.ajax({url:"/cdn-cgi/trace",success:function(a,n){let i="Antananarivo, Madagascar - (TNR);Cape Town, South Africa - (CPT);Casablanca, Morocco - (CMN);Dar Es Salaam, Tanzania - (DAR);Djibouti City, Djibouti - (JIB);Durban, South Africa - (DUR);Johannesburg, South Africa - (JNB);Kigali, Rwanda - (KGL);Lagos, Nigeria - (LOS);Luanda, Angola - (LAD);Maputo, MZ - (MPM);Mombasa, Kenya - (MBA);Port Louis, Mauritius - (MRU);Réunion, France - (RUN);Bangalore, India - (BLR);Bangkok, Thailand - (BKK);Bandar Seri Begawan, Brunei - (BWN);Cebu, Philippines - (CEB);Chengdu, China - (CTU);Chennai, India - (MAA);Chittagong, Bangladesh - (CGP);Chongqing, China - (CKG);Colombo, Sri Lanka - (CMB);Dhaka, Bangladesh - (DAC);Dongguan, China - (SZX);Foshan, China - (FUO);Fuzhou, China - (FOC);Guangzhou, China - (CAN);Hangzhou, China - (HGH);Hanoi, Vietnam - (HAN);Hengyang, China - (HNY);Ho Chi Minh City, Vietnam - (SGN);Hong Kong - (HKG);Hyderabad, India - (HYD);Islamabad, Pakistan - (ISB);Jakarta, Indonesia - (CGK);Jinan, China - (TNA);Karachi, Pakistan - (KHI);Kathmandu, Nepal - (KTM);Kolkata, India - (CCU);Kuala Lumpur, Malaysia - (KUL);Lahore, Pakistan - (LHE);Langfang, China - (NAY);Luoyang, China - (LYA);Macau - (MFM);Malé, Maldives - (MLE);Manila, Philippines - (MNL);Mumbai, India - (BOM);Nagpur, India - (NAG);Nanning, China - (NNG);New Delhi, India - (DEL);Osaka, Japan - (KIX);Phnom Penh, Cambodia - (PNH);Qingdao, China - (TAO);Seoul, South Korea - (ICN);Shanghai, China - (SHA);Shenyang, China - (SHE);Shijiazhuang, China - (SJW);Singapore, Singapore - (SIN);Suzhou, China - (SZV);Taipei - (TPE);Thimphu, Bhutan - (PBH);Tianjin, China - (TSN);Tokyo, Japan - (NRT);Ulaanbaatar, Mongolia - (ULN);Vientiane, Laos - (VTE);Wuhan, China - (WUH);Wuxi, China - (WUX);Xi'an, China - (XIY);Yerevan, Armenia - (EVN);Zhengzhou, China - (CGO);Zuzhou, China - (CSX);Amsterdam, Netherlands - (AMS);Athens, Greece - (ATH);Barcelona, Spain - (BCN);Belgrade, Serbia - (BEG);Berlin, Germany - (TXL);Brussels, Belgium - (BRU);Bucharest, Romania - (OTP);Budapest, Hungary - (BUD);Chișinău, Moldova - (KIV);Copenhagen, Denmark - (CPH);Cork, Ireland -  (ORK);Dublin, Ireland - (DUB);Düsseldorf, Germany - (DUS);Edinburgh, United Kingdom - (EDI);Frankfurt, Germany - (FRA);Geneva, Switzerland - (GVA);Gothenburg, Sweden - (GOT);Hamburg, Germany - (HAM);Helsinki, Finland - (HEL);Istanbul, Turkey - (IST);Kyiv, Ukraine - (KBP);Lisbon, Portugal - (LIS);London, United Kingdom - (LHR);Luxembourg City, Luxembourg - (LUX);Madrid, Spain - (MAD);Manchester, United Kingdom - (MAN);Marseille, France - (MRS);Milan, Italy - (MXP);Moscow, Russia - (DME);Munich, Germany - (MUC);Nicosia, Cyprus - (LCA);Oslo, Norway - (OSL);Paris, France - (CDG);Prague, Czech Republic - (PRG);Reykjavík, Iceland - (KEF);Riga, Latvia - (RIX);Rome, Italy - (FCO);Saint Petersburg, Russia - (LED);Sofia, Bulgaria - (SOF);Stockholm, Sweden - (ARN);Tallinn, Estonia - (TLL);Thessaloniki, Greece - (SKG);Vienna, Austria - (VIE);Vilnius, Lithuania - (VNO);Warsaw, Poland - (WAW);Zagreb, Croatia - (ZAG);Zürich, Switzerland - (ZRH);Arica, Chile - (ARI);Asunción, Paraguay - (ASU);Bogotá, Colombia - (BOG);Buenos Aires, Argentina - (EZE);Curitiba, Brazil - (CWB);Fortaleza, Brazil - (FOR);Guatemala City, Guatemala - (GUA);Lima, Peru - (LIM);Medellín, Colombia - (MDE);Panama City, Panama - (PTY);Porto Alegre, Brazil - (POA);Quito, Ecuador - (UIO);Rio de Janeiro, Brazil - (GIG);São Paulo, Brazil - (GRU);Santiago, Chile - (SCL);Willemstad, Curaçao - (CUR);St. George's, Grenada - (GND);Amman, Jordan - (AMM);Baghdad, Iraq - (BGW);Baku, Azerbaijan - (GYD);Beirut, Lebanon - (BEY);Doha, Qatar - (DOH);Dubai, United Arab Emirates - (DXB);Kuwait City, Kuwait - (KWI);Manama, Bahrain - (BAH);Muscat, Oman - (MCT);Ramallah - (ZDM);Riyadh, Saudi Arabia - (RUH);Tel Aviv, Israel - (TLV);Ashburn, VA, United States - (IAD);Atlanta, GA, United States - (ATL);Boston, MA, United States - (BOS);Buffalo, NY, United States - (BUF);Calgary, AB, Canada - (YYC);Charlotte, NC, United States - (CLT);Chicago, IL, United States - (ORD);Columbus, OH, United States - (CMH);Dallas, TX, United States - (DFW);Denver, CO, United States - (DEN);Detroit, MI, United States - (DTW);Honolulu, HI, United States - (HNL);Houston, TX, United States - (IAH);Indianapolis, IN, United States - (IND);Jacksonville, FL, United States - (JAX);Kansas City, MO, United States - (MCI);Las Vegas, NV, United States - (LAS);Los Angeles, CA, United States - (LAX);McAllen, TX, United States - (MFE);Memphis, TN, United States - (MEM);Mexico City, Mexico - (MEX);Miami, FL, United States - (MIA);Minneapolis, MN, United States - (MSP);Montgomery, AL, United States - (MGM);Montréal, QC, Canada - (YUL);Nashville, TN, United States - (BNA);Newark, NJ, United States - (EWR);Norfolk, VA, United States - (ORF);Omaha, NE, United States - (OMA);Philadelphia, United States - (PHL);Phoenix, AZ, United States - (PHX);Pittsburgh, PA, United States - (PIT);Port-Au-Prince, Haiti - (PAP);Portland, OR, United States - (PDX);Queretaro, MX, Mexico - (QRO);Richmond, Virginia - (RIC);Sacramento, CA, United States - (SMF);Salt Lake City, UT, United States - (SLC);San Diego, CA, United States - (SAN);San Jose, CA, United States - (SJC);Saskatoon, SK, Canada - (YXE);Seattle, WA, United States - (SEA);St. Louis, MO, United States - (STL);Tampa, FL, United States - (TPA);Toronto, ON, Canada - (YYZ);Vancouver, BC, Canada - (YVR);Tallahassee, FL, United States - (TLH);Winnipeg, MB, Canada - (YWG);Adelaide, SA, Australia - (ADL);Auckland, New Zealand - (AKL);Brisbane, QLD, Australia - (BNE);Melbourne, VIC, Australia - (MEL);Noumea, New caledonia - (NOU);Perth, WA, Australia - (PER);Sydney, NSW, Australia - (SYD)".split(";"),e=a.split("colo=")[1].split("\n")[0],t=(a.split("colo=")[1].split("\n")[0],a.split("tls=")[1].split("\n")[0]),o=a.split("http=")[1].split("\n")[0],s=a.split("sni=")[1].split("\n")[0],r=a.split("ip=")[1].split("\n")[0],l=a.split("uag=")[1].split("\n")[0];for(var d=0;d<i.length;d++)if(-1!=i[d].indexOf(e)){document.getElementById("cdn").innerHTML=i[d];break}document.getElementById("tls").innerHTML=t,document.getElementById("http").innerHTML=o,document.getElementById("sni").innerHTML=s,document.getElementById("ip").innerHTML=r,document.getElementById("useragent").innerHTML=l}})},$(document).ready((function(){getCDNinfo()}))</script></p><p style="text-align:center">感谢陪伴与布道，开源之火不灭。​</p><p style="text-align:center"><script>document.write("本次加载耗时: "+(performance.getEntriesByType("navigation").reduce((e,r)=>e+r.responseEnd-r.startTime,0)+performance.getEntriesByType("resource").reduce((e,r)=>e+r.responseEnd-r.startTime,0)).toFixed(0)+"ms")</script></p><p style="text-align:center">当前 SNI 状态： <span id="sni">正在统计！或可能被浏览器防追踪拦截！</span></p><p style="text-align:center">当前 TLS 版本： <span id="tls">正在统计！或可能被浏览器防追踪拦截！</span></p><p style="text-align:center">当前 HTTP 版本： <span id="http">正在统计！或可能被浏览器防追踪拦截！</span></p><p style="text-align:center">当前您的客户端 IP 是： <span id="ip">正在统计！或可能被浏览器防追踪拦截！</span></p><p style="text-align:center">当前分配的 CDN 节点是: <span id="cdn">正在统计！或可能被浏览器防追踪拦截！</span></p><p style="text-align:center">您的 UserAgent 信息是: <span id="useragent">正在统计！或可能被浏览器防追踪拦截！</span></p><p></p></div></div></body></html>