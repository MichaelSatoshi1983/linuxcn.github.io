<!doctype html><html lang="en"><head><meta name="description" content="一个LinuxCN的镜像站"><meta name="msvalidate.01" content="D404690CEFCB54C7762AC84935B99171"><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?6618da70c90c8744eead2e9371fb5077";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><script type="text/javascript">!function(t,e,n,c,s,a,r){t[n]=t[n]||function(){(t[n].q=t[n].q||[]).push(arguments)},(a=e.createElement(c)).async=1,a.src="https://www.clarity.ms/tag/s5f3f0tojf",(r=e.getElementsByTagName(c)[0]).parentNode.insertBefore(a,r)}(window,document,"clarity","script")</script><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta http-equiv="X-UA-Compatible" content="ie=edge"><link rel="stylesheet" href="/styles/base.css"><link rel="stylesheet" href="/styles/theme.css"><link rel="shortcut icon" href="/favicon.png"><title>用 Python 构建一个极小的区块链 - 归墟星火集 又一个 LinuxCN 站点</title><meta name="generator" content="Hexo 7.3.0"></head><body><div class="header-title"><span class="header-light"></span> <span class="header-light"></span> <span class="header-light"></span> <span>归墟星火集 又一个 LinuxCN 站点 linuxcn.undefined.today<span></span></span></div><div class="container"><ul class="nav"><li><a href="/">首页</a></li><li><a target="_blank" rel="noopener" href="https://undefined.today/">Blog</a></li></ul><div class="content"><div class="post-container"><div class="post-header"><span class="ui-tips">标题：</span><h1 class="ui-keyword post-title">用 Python 构建一个极小的区块链</h1><span class="post-date">2018-03-17</span></div><div class="post-header"><span class="ui-tips">分类：</span> <a href="/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/">区块链</a></div><div class="post-header"><span class="ui-tips">标签：</span> <a href="/tags/Python/">Python</a> <a href="/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/">区块链</a></div><div class="post-content"><p><img src="https://linuxcn.img.undefined.today/data/attachment/album/201803/17/021735y0htspy6tjdwssqh.jpg"></p><p>虽然有些人认为区块链是一个早晚会出现问题的解决方案，但是毫无疑问，这个创新技术是一个计算机技术上的奇迹。那么，究竟什么是区块链呢？</p><h3 id="区块链"><a href="#区块链" class="headerlink" title="区块链"></a>区块链</h3><blockquote><p>以<ruby>比特币 <rp>（ </rp><rt>Bitcoin</rt> <rp>）</rp></ruby>或其它加密货币按时间顺序公开地记录交易的数字账本。</p></blockquote><p>更通俗的说，它是一个公开的数据库，新的数据存储在被称之为<ruby>区块 <rp>（ </rp><rt>block</rt> <rp>）</rp></ruby>的容器中，并被添加到一个不可变的<ruby>链 <rp>（ </rp><rt>chain</rt> <rp>）</rp></ruby>中（因此被称为<ruby>区块链 <rp>（ </rp><rt>blockchain</rt> <rp>）</rp></ruby>），之前添加的数据也在该链中。对于比特币或其它加密货币来说，这些数据就是一组组交易，不过，也可以是其它任何类型的数据。</p><p>区块链技术带来了全新的、完全数字化的货币，如比特币和<ruby>莱特币 <rp>（ </rp><rt>Litecoin</rt> <rp>）</rp></ruby>，它们并不由任何中心机构管理。这给那些认为当今的银行系统是骗局并将最终走向失败的人带来了自由。区块链也革命性地改变了分布式计算的技术形式，如<ruby>以太坊 <rp>（ </rp><rt>Ethereum</rt> <rp>）</rp></ruby>就引入了一种有趣的概念：<ruby><a target="_blank" rel="noopener" href="https://blockgeeks.com/guides/smart-contracts/">智能合约 </a><rp>（ </rp><rt>smart contract</rt> <rp>）</rp></ruby>。</p><p>在这篇文章中，我将用不到 50 行的 Python 2.x 代码实现一个简单的区块链，我把它叫做 SnakeCoin。</p><h3 id="不到-50-行代码的区块链"><a href="#不到-50-行代码的区块链" class="headerlink" title="不到 50 行代码的区块链"></a>不到 50 行代码的区块链</h3><p>我们首先将从定义我们的区块是什么开始。在区块链中，每个区块随同时间戳及可选的索引一同存储。在 SnakeCoin 中，我们会存储这两者。为了确保整个区块链的完整性，每个区块都会有一个自识别的哈希值。如在比特币中，每个区块的哈希是该块的索引、时间戳、数据和前一个区块的哈希值等数据的加密哈希值。这里提及的“数据”可以是任何你想要的数据。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">import hashlib as hasher</span><br><span class="line"></span><br><span class="line">class Block:</span><br><span class="line">  def __init__(self, index, timestamp, data, previous_hash):</span><br><span class="line">    self.index = index</span><br><span class="line">    self.timestamp = timestamp</span><br><span class="line">    self.data = data</span><br><span class="line">    self.previous_hash = previous_hash</span><br><span class="line">    self.hash = self.hash_block()</span><br><span class="line">  </span><br><span class="line">  def hash_block(self):</span><br><span class="line">    sha = hasher.sha256()</span><br><span class="line">    sha.update(str(self.index) + </span><br><span class="line">               str(self.timestamp) + </span><br><span class="line">               str(self.data) + </span><br><span class="line">               str(self.previous_hash))</span><br><span class="line">    return sha.hexdigest()</span><br></pre></td></tr></table></figure><p>真棒，现在我们有了区块的结构了，不过我们需要创建的是一个区块链。我们需要把区块添加到一个实际的链中。如我们之前提到过的，每个区块都需要前一个区块的信息。但问题是，该区块链中的第一个区块在哪里？好吧，这个第一个区块，也称之为创世区块，是一个特别的区块。在很多情况下，它是手工添加的，或通过独特的逻辑添加的。</p><p>我们将创建一个函数来简单地返回一个创世区块解决这个问题。这个区块的索引为 0 ，其包含一些任意的数据值，其“前一哈希值”参数也是任意值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import datetime as date</span><br><span class="line"></span><br><span class="line">def create_genesis_block():</span><br><span class="line">  # Manually construct a block with</span><br><span class="line">  # index zero and arbitrary previous hash</span><br><span class="line">  return Block(0, date.datetime.now(), &quot;Genesis Block&quot;, &quot;0&quot;)</span><br></pre></td></tr></table></figure><p>现在我们可以创建创世区块了，我们需要一个函数来生成该区块链中的后继区块。该函数将获取链中的前一个区块作为参数，为要生成的区块创建数据，并用相应的数据返回新的区块。新的区块的哈希值来自于之前的区块，这样每个新的区块都提升了该区块链的完整性。如果我们不这样做，外部参与者就很容易“改变过去”，把我们的链替换为他们的新链了。这个哈希链起到了加密的证明作用，并有助于确保一旦一个区块被添加到链中，就不能被替换或移除。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">def next_block(last_block):</span><br><span class="line">  this_index = last_block.index + 1</span><br><span class="line">  this_timestamp = date.datetime.now()</span><br><span class="line">  this_data = &quot;Hey! I&#x27;m block &quot; + str(this_index)</span><br><span class="line">  this_hash = last_block.hash</span><br><span class="line">  return Block(this_index, this_timestamp, this_data, this_hash)</span><br></pre></td></tr></table></figure><p>这就是主要的部分。</p><p>现在我们能创建自己的区块链了！在这里，这个区块链是一个简单的 Python 列表。其第一个的元素是我们的创世区块，我们会添加后继区块。因为 SnakeCoin 是一个极小的区块链，我们仅仅添加了 20 个区块。我们通过循环来完成它。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># Create the blockchain and add the genesis block</span><br><span class="line">blockchain = [create_genesis_block()]</span><br><span class="line">previous_block = blockchain[0]</span><br><span class="line"></span><br><span class="line"># How many blocks should we add to the chain</span><br><span class="line"># after the genesis block</span><br><span class="line">num_of_blocks_to_add = 20</span><br><span class="line"></span><br><span class="line"># Add blocks to the chain</span><br><span class="line">for i in range(0, num_of_blocks_to_add):</span><br><span class="line">  block_to_add = next_block(previous_block)</span><br><span class="line">  blockchain.append(block_to_add)</span><br><span class="line">  previous_block = block_to_add</span><br><span class="line">  # Tell everyone about it!</span><br><span class="line">  print &quot;Block #&#123;&#125; has been added to the blockchain!&quot;.format(block_to_add.index)</span><br><span class="line">  print &quot;Hash: &#123;&#125;\n&quot;.format(block_to_add.hash) </span><br></pre></td></tr></table></figure><p>让我们看看我们的成果：</p><p><img src="https://linuxcn.img.undefined.today/data/attachment/album/201803/17/021736e1eef2zmjwor1j2l.png"></p><p><em>别担心，它将一直添加到 20 个区块</em></p><p>很好，我们的区块链可以工作了。如果你想要在主控台查看更多的信息，你可以编辑其<a target="_blank" rel="noopener" href="https://gist.github.com/aunyks/8f2c2fd51cc17f342737917e1c2582e2">完整的源代码</a>并输出每个区块的时间戳或数据。</p><p>这就是 SnakeCoin 所具有的功能。要使 SnakeCoin 达到现今的产品级的区块链的高度，我们需要添加更多的功能，如服务器层，以在多台机器上跟踪链的改变，并通过<a target="_blank" rel="noopener" href="https://en.bitcoin.it/wiki/Proof_of_work">工作量证明算法（POW）</a>来限制给定时间周期内可以添加的区块数量。</p><p>如果你想了解更多技术细节，你可以在<a target="_blank" rel="noopener" href="https://bitcoin.org/bitcoin.pdf">这里</a>查看最初的<a target="_blank" rel="noopener" href="https://bitcoin.org/bitcoin.pdf">比特币白皮书</a>。</p><h3 id="让这个极小区块链稍微变大些"><a href="#让这个极小区块链稍微变大些" class="headerlink" title="让这个极小区块链稍微变大些"></a>让这个极小区块链稍微变大些</h3><p>这个极小的区块链及其简单，自然也相对容易完成。但是因其简单也带来了一些缺陷。首先，SnakeCoin 仅能运行在单一的一台机器上，所以它相距分布式甚远，更别提去中心化了。其次，区块添加到区块链中的速度同在主机上创建一个 Python 对象并添加到列表中一样快。在我们的这个简单的区块链中，这不是问题，但是如果我们想让 SnakeCoin 成为一个实际的加密货币，我们就需要控制在给定时间内能创建的区块（和币）的数量。</p><p>从现在开始，SnakeCoin 中的“数据”将是交易数据，每个区块的“数据”字段都将是一些交易信息的列表。接着我们来定义“交易”。每个“交易”是一个 JSON 对象，其记录了币的发送者、接收者和转移的 SnakeCoin 数量。注：交易信息是 JSON 格式，原因我很快就会说明。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;from&quot;: &quot;71238uqirbfh894-random-public-key-a-alkjdflakjfewn204ij&quot;,</span><br><span class="line">  &quot;to&quot;: &quot;93j4ivnqiopvh43-random-public-key-b-qjrgvnoeirbnferinfo&quot;,</span><br><span class="line">  &quot;amount&quot;: 3</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我们知道了交易信息看起来的样子了，我们需要一个办法来将其加到我们的区块链网络中的一台计算机（称之为节点）中。要做这个事情，我们会创建一个简单的 HTTP 服务器，以便每个用户都可以让我们的节点知道发生了新的交易。节点可以接受 POST 请求，请求数据为如上的交易信息。这就是为什么交易信息是 JSON 格式的：我们需要它们可以放在请求信息中传递给服务器。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pip install flask # 首先安装 Web 服务器框架</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">from flask import Flask</span><br><span class="line">from flask import request</span><br><span class="line">node = Flask(__name__)</span><br><span class="line"></span><br><span class="line"># Store the transactions that</span><br><span class="line"># this node has in a list</span><br><span class="line">this_nodes_transactions = []</span><br><span class="line"></span><br><span class="line">@node.route(&#x27;/txion&#x27;, methods=[&#x27;POST&#x27;])</span><br><span class="line">def transaction():</span><br><span class="line">  if request.method == &#x27;POST&#x27;:</span><br><span class="line">    # On each new POST request,</span><br><span class="line">    # we extract the transaction data</span><br><span class="line">    new_txion = request.get_json()</span><br><span class="line">    # Then we add the transaction to our list</span><br><span class="line">    this_nodes_transactions.append(new_txion)</span><br><span class="line">    # Because the transaction was successfully</span><br><span class="line">    # submitted, we log it to our console</span><br><span class="line">    print &quot;New transaction&quot;</span><br><span class="line">    print &quot;FROM: &#123;&#125;&quot;.format(new_txion[&#x27;from&#x27;])</span><br><span class="line">    print &quot;TO: &#123;&#125;&quot;.format(new_txion[&#x27;to&#x27;])</span><br><span class="line">    print &quot;AMOUNT: &#123;&#125;\n&quot;.format(new_txion[&#x27;amount&#x27;])</span><br><span class="line">    # Then we let the client know it worked out</span><br><span class="line">    return &quot;Transaction submission successful\n&quot;</span><br><span class="line"></span><br><span class="line">node.run()</span><br></pre></td></tr></table></figure><p>真棒！现在我们有了一种保存用户彼此发送 SnakeCoin 的记录的方式。这就是为什么人们将区块链称之为公共的、分布式账本：所有的交易信息存储给所有人看，并被存储在该网络的每个节点上。</p><p>但是，有个问题：人们从哪里得到 SnakeCoin 呢？现在还没有办法得到，还没有一个称之为 SnakeCoin 这样的东西，因为我们还没有创建和分发任何一个币。要创建新的币，人们需要“挖”一个新的 SnakeCoin 区块。当他们成功地挖到了新区块，就会创建出一个新的 SnakeCoin ，并奖励给挖出该区块的人（矿工）。一旦挖矿的矿工将 SnakeCoin 发送给别人，这个币就流通起来了。</p><p>我们不想让挖新的 SnakeCoin 区块太容易，因为这将导致 SnakeCoin 太多了，其价值就变低了；同样，我们也不想让它变得太难，因为如果没有足够的币供每个人使用，它们对于我们来说就太昂贵了。为了控制挖新的 SnakeCoin 区块的难度，我们会实现一个<ruby><a target="_blank" rel="noopener" href="https://en.bitcoin.it/wiki/Proof_of_work">工作量证明 </a><rp>（ </rp><rt>Proof-of-Work</rt> <rp>）</rp></ruby>（PoW）算法。工作量证明基本上就是一个生成某个项目比较难，但是容易验证（其正确性）的算法。这个项目被称之为“证明”，听起来就像是它证明了计算机执行了特定的工作量。</p><p>在 SnakeCoin 中，我们创建了一个简单的 PoW 算法。要创建一个新区块，矿工的计算机需要递增一个数字，当该数字能被 9 （“SnakeCoin” 这个单词的字母数）整除时，这就是最后这个区块的证明数字，就会挖出一个新的 SnakeCoin 区块，而该矿工就会得到一个新的 SnakeCoin。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"># ...blockchain</span><br><span class="line"># ...Block class definition</span><br><span class="line"></span><br><span class="line">miner_address = &quot;q3nf394hjg-random-miner-address-34nf3i4nflkn3oi&quot;</span><br><span class="line"></span><br><span class="line">def proof_of_work(last_proof):</span><br><span class="line">  # Create a variable that we will use to find</span><br><span class="line">  # our next proof of work</span><br><span class="line">  incrementor = last_proof + 1</span><br><span class="line">  # Keep incrementing the incrementor until</span><br><span class="line">  # it&#x27;s equal to a number divisible by 9</span><br><span class="line">  # and the proof of work of the previous</span><br><span class="line">  # block in the chain</span><br><span class="line">  while not (incrementor % 9 == 0 and incrementor % last_proof == 0):</span><br><span class="line">    incrementor += 1</span><br><span class="line">  # Once that number is found,</span><br><span class="line">  # we can return it as a proof</span><br><span class="line">  # of our work</span><br><span class="line">  return incrementor</span><br><span class="line"></span><br><span class="line">@node.route(&#x27;/mine&#x27;, methods = [&#x27;GET&#x27;])</span><br><span class="line">def mine():</span><br><span class="line">  # Get the last proof of work</span><br><span class="line">  last_block = blockchain[len(blockchain) - 1]</span><br><span class="line">  last_proof = last_block.data[&#x27;proof-of-work&#x27;]</span><br><span class="line">  # Find the proof of work for</span><br><span class="line">  # the current block being mined</span><br><span class="line">  # Note: The program will hang here until a new</span><br><span class="line">  #       proof of work is found</span><br><span class="line">  proof = proof_of_work(last_proof)</span><br><span class="line">  # Once we find a valid proof of work,</span><br><span class="line">  # we know we can mine a block so </span><br><span class="line">  # we reward the miner by adding a transaction</span><br><span class="line">  this_nodes_transactions.append(</span><br><span class="line">    &#123; &quot;from&quot;: &quot;network&quot;, &quot;to&quot;: miner_address, &quot;amount&quot;: 1 &#125;</span><br><span class="line">  )</span><br><span class="line">  # Now we can gather the data needed</span><br><span class="line">  # to create the new block</span><br><span class="line">  new_block_data = &#123;</span><br><span class="line">    &quot;proof-of-work&quot;: proof,</span><br><span class="line">    &quot;transactions&quot;: list(this_nodes_transactions)</span><br><span class="line">  &#125;</span><br><span class="line">  new_block_index = last_block.index + 1</span><br><span class="line">  new_block_timestamp = this_timestamp = date.datetime.now()</span><br><span class="line">  last_block_hash = last_block.hash</span><br><span class="line">  # Empty transaction list</span><br><span class="line">  this_nodes_transactions[:] = []</span><br><span class="line">  # Now create the</span><br><span class="line">  # new block!</span><br><span class="line">  mined_block = Block(</span><br><span class="line">    new_block_index,</span><br><span class="line">    new_block_timestamp,</span><br><span class="line">    new_block_data,</span><br><span class="line">    last_block_hash</span><br><span class="line">  )</span><br><span class="line">  blockchain.append(mined_block)</span><br><span class="line">  # Let the client know we mined a block</span><br><span class="line">  return json.dumps(&#123;</span><br><span class="line">      &quot;index&quot;: new_block_index,</span><br><span class="line">      &quot;timestamp&quot;: str(new_block_timestamp),</span><br><span class="line">      &quot;data&quot;: new_block_data,</span><br><span class="line">      &quot;hash&quot;: last_block_hash</span><br><span class="line">  &#125;) + &quot;\n&quot;</span><br></pre></td></tr></table></figure><p>现在，我们能控制特定的时间段内挖到的区块数量，并且我们给了网络中的人新的币，让他们彼此发送。但是如我们说的，我们只是在一台计算机上做的。如果区块链是去中心化的，我们怎样才能确保每个节点都有相同的链呢？要做到这一点，我们会使每个节点都广播其（保存的）链的版本，并允许它们接受其它节点的链。然后，每个节点会校验其它节点的链，以便网络中每个节点都能够达成最终的链的共识。这称之为<ruby><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Consensus_%28computer_science%29">共识算法 </a><rp>（ </rp><rt>consensus algorithm</rt> <rp>）</rp></ruby>。</p><p>我们的共识算法很简单：如果一个节点的链与其它的节点的不同（例如有冲突），那么最长的链保留，更短的链会被删除。如果我们网络上的链没有了冲突，那么就可以继续了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">@node.route(&#x27;/blocks&#x27;, methods=[&#x27;GET&#x27;])</span><br><span class="line">def get_blocks():</span><br><span class="line">  chain_to_send = blockchain</span><br><span class="line">  # Convert our blocks into dictionaries</span><br><span class="line">  # so we can send them as json objects later</span><br><span class="line">  for block in chain_to_send:</span><br><span class="line">    block_index = str(block.index)</span><br><span class="line">    block_timestamp = str(block.timestamp)</span><br><span class="line">    block_data = str(block.data)</span><br><span class="line">    block_hash = block.hash</span><br><span class="line">    block = &#123;</span><br><span class="line">      &quot;index&quot;: block_index,</span><br><span class="line">      &quot;timestamp&quot;: block_timestamp,</span><br><span class="line">      &quot;data&quot;: block_data,</span><br><span class="line">      &quot;hash&quot;: block_hash</span><br><span class="line">    &#125;</span><br><span class="line">  # Send our chain to whomever requested it</span><br><span class="line">  chain_to_send = json.dumps(chain_to_send)</span><br><span class="line">  return chain_to_send</span><br><span class="line"></span><br><span class="line">def find_new_chains():</span><br><span class="line">  # Get the blockchains of every</span><br><span class="line">  # other node</span><br><span class="line">  other_chains = []</span><br><span class="line">  for node_url in peer_nodes:</span><br><span class="line">    # Get their chains using a GET request</span><br><span class="line">    block = requests.get(node_url + &quot;/blocks&quot;).content</span><br><span class="line">    # Convert the JSON object to a Python dictionary</span><br><span class="line">    block = json.loads(block)</span><br><span class="line">    # Add it to our list</span><br><span class="line">    other_chains.append(block)</span><br><span class="line">  return other_chains</span><br><span class="line"></span><br><span class="line">def consensus():</span><br><span class="line">  # Get the blocks from other nodes</span><br><span class="line">  other_chains = find_new_chains()</span><br><span class="line">  # If our chain isn&#x27;t longest,</span><br><span class="line">  # then we store the longest chain</span><br><span class="line">  longest_chain = blockchain</span><br><span class="line">  for chain in other_chains:</span><br><span class="line">    if len(longest_chain) &lt; len(chain):</span><br><span class="line">      longest_chain = chain</span><br><span class="line">  # If the longest chain wasn&#x27;t ours,</span><br><span class="line">  # then we set our chain to the longest</span><br><span class="line">  blockchain = longest_chain</span><br></pre></td></tr></table></figure><p>我们差不多就要完成了。在运行了<a target="_blank" rel="noopener" href="https://gist.github.com/aunyks/47d157f8bc7d1829a729c2a6a919c173">完整的 SnakeCoin 服务器代码</a>之后，在你的终端可以运行如下代码。（假设你已经安装了 cCUL）。</p><h4 id="1、创建交易"><a href="#1、创建交易" class="headerlink" title="1、创建交易"></a>1、创建交易</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">curl &quot;localhost:5000/txion&quot; \  </span><br><span class="line">     -H &quot;Content-Type: application/json&quot; \  </span><br><span class="line">     -d &#x27;&#123;&quot;from&quot;: &quot;akjflw&quot;, &quot;to&quot;:&quot;fjlakdj&quot;, &quot;amount&quot;: 3&#125;&#x27;</span><br></pre></td></tr></table></figure><h4 id="2、挖一个新区块"><a href="#2、挖一个新区块" class="headerlink" title="2、挖一个新区块"></a>2、挖一个新区块</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl localhost:5000/mine</span><br></pre></td></tr></table></figure><h4 id="3、-查看结果。从客户端窗口，我们可以看到。"><a href="#3、-查看结果。从客户端窗口，我们可以看到。" class="headerlink" title="3、 查看结果。从客户端窗口，我们可以看到。"></a>3、 查看结果。从客户端窗口，我们可以看到。</h4><p><img src="https://linuxcn.img.undefined.today/data/attachment/album/201803/17/021736bn5xydc4dba6xlyq.png"></p><p>对代码做下美化处理，我们看到挖矿后我们得到的新区块的信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#123;  </span><br><span class="line">  &quot;index&quot;: 2,  </span><br><span class="line">  &quot;data&quot;: &#123;  </span><br><span class="line">    &quot;transactions&quot;: [  </span><br><span class="line">      &#123;  </span><br><span class="line">        &quot;to&quot;: &quot;fjlakdj&quot;,  </span><br><span class="line">        &quot;amount&quot;: 3,  </span><br><span class="line">        &quot;from&quot;: &quot;akjflw&quot;  </span><br><span class="line">      &#125;,  </span><br><span class="line">      &#123;  </span><br><span class="line">        &quot;to&quot;: &quot;q3nf394hjg-random-miner-address-34nf3i4nflkn3oi&quot;,  </span><br><span class="line">        &quot;amount&quot;: 1,  </span><br><span class="line">        &quot;from&quot;: &quot;network&quot;  </span><br><span class="line">      &#125;  </span><br><span class="line">    ],  </span><br><span class="line">    &quot;proof-of-work&quot;: 36  </span><br><span class="line">  &#125;,  </span><br><span class="line">  &quot;hash&quot;: &quot;151edd3ef6af2e7eb8272245cb8ea91b4ecfc3e60af22d8518ef0bba8b4a6b18&quot;,  </span><br><span class="line">  &quot;timestamp&quot;: &quot;2017-07-23 11:23:10.140996&quot;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大功告成！现在 SnakeCoin 可以运行在多个机器上，从而创建了一个网络，而且真实的 SnakeCoin 也能被挖到了。</p><p>你可以根据你的喜好去修改 SnakeCoin 服务器代码，并问各种问题了。</p><p>在下一篇（LCTT 译注：截止至本文翻译，作者还没有写出下一篇），我们将讨论创建一个 SnakeCoin 钱包，这样用户就可以发送、接收和存储他们的 SnakeCoin 了。</p></div></div></div><div class="footer"><p class="footer-copyright"><span>Powered by <a target="_blank" href="https://hexo.io">Hexo</a></span> <span>Theme <a target="_blank" href="https://github.com/tinkink-co/hexo-theme-terminal">Terminal</a></span><script type="text/javascript" src="https://cdn.staticfile.net/jquery/3.4.1/jquery.min.js"></script><script>getCDNinfo=function(){$.ajax({url:"/cdn-cgi/trace",success:function(a,n){let i="Antananarivo, Madagascar - (TNR);Cape Town, South Africa - (CPT);Casablanca, Morocco - (CMN);Dar Es Salaam, Tanzania - (DAR);Djibouti City, Djibouti - (JIB);Durban, South Africa - (DUR);Johannesburg, South Africa - (JNB);Kigali, Rwanda - (KGL);Lagos, Nigeria - (LOS);Luanda, Angola - (LAD);Maputo, MZ - (MPM);Mombasa, Kenya - (MBA);Port Louis, Mauritius - (MRU);Réunion, France - (RUN);Bangalore, India - (BLR);Bangkok, Thailand - (BKK);Bandar Seri Begawan, Brunei - (BWN);Cebu, Philippines - (CEB);Chengdu, China - (CTU);Chennai, India - (MAA);Chittagong, Bangladesh - (CGP);Chongqing, China - (CKG);Colombo, Sri Lanka - (CMB);Dhaka, Bangladesh - (DAC);Dongguan, China - (SZX);Foshan, China - (FUO);Fuzhou, China - (FOC);Guangzhou, China - (CAN);Hangzhou, China - (HGH);Hanoi, Vietnam - (HAN);Hengyang, China - (HNY);Ho Chi Minh City, Vietnam - (SGN);Hong Kong - (HKG);Hyderabad, India - (HYD);Islamabad, Pakistan - (ISB);Jakarta, Indonesia - (CGK);Jinan, China - (TNA);Karachi, Pakistan - (KHI);Kathmandu, Nepal - (KTM);Kolkata, India - (CCU);Kuala Lumpur, Malaysia - (KUL);Lahore, Pakistan - (LHE);Langfang, China - (NAY);Luoyang, China - (LYA);Macau - (MFM);Malé, Maldives - (MLE);Manila, Philippines - (MNL);Mumbai, India - (BOM);Nagpur, India - (NAG);Nanning, China - (NNG);New Delhi, India - (DEL);Osaka, Japan - (KIX);Phnom Penh, Cambodia - (PNH);Qingdao, China - (TAO);Seoul, South Korea - (ICN);Shanghai, China - (SHA);Shenyang, China - (SHE);Shijiazhuang, China - (SJW);Singapore, Singapore - (SIN);Suzhou, China - (SZV);Taipei - (TPE);Thimphu, Bhutan - (PBH);Tianjin, China - (TSN);Tokyo, Japan - (NRT);Ulaanbaatar, Mongolia - (ULN);Vientiane, Laos - (VTE);Wuhan, China - (WUH);Wuxi, China - (WUX);Xi'an, China - (XIY);Yerevan, Armenia - (EVN);Zhengzhou, China - (CGO);Zuzhou, China - (CSX);Amsterdam, Netherlands - (AMS);Athens, Greece - (ATH);Barcelona, Spain - (BCN);Belgrade, Serbia - (BEG);Berlin, Germany - (TXL);Brussels, Belgium - (BRU);Bucharest, Romania - (OTP);Budapest, Hungary - (BUD);Chișinău, Moldova - (KIV);Copenhagen, Denmark - (CPH);Cork, Ireland -  (ORK);Dublin, Ireland - (DUB);Düsseldorf, Germany - (DUS);Edinburgh, United Kingdom - (EDI);Frankfurt, Germany - (FRA);Geneva, Switzerland - (GVA);Gothenburg, Sweden - (GOT);Hamburg, Germany - (HAM);Helsinki, Finland - (HEL);Istanbul, Turkey - (IST);Kyiv, Ukraine - (KBP);Lisbon, Portugal - (LIS);London, United Kingdom - (LHR);Luxembourg City, Luxembourg - (LUX);Madrid, Spain - (MAD);Manchester, United Kingdom - (MAN);Marseille, France - (MRS);Milan, Italy - (MXP);Moscow, Russia - (DME);Munich, Germany - (MUC);Nicosia, Cyprus - (LCA);Oslo, Norway - (OSL);Paris, France - (CDG);Prague, Czech Republic - (PRG);Reykjavík, Iceland - (KEF);Riga, Latvia - (RIX);Rome, Italy - (FCO);Saint Petersburg, Russia - (LED);Sofia, Bulgaria - (SOF);Stockholm, Sweden - (ARN);Tallinn, Estonia - (TLL);Thessaloniki, Greece - (SKG);Vienna, Austria - (VIE);Vilnius, Lithuania - (VNO);Warsaw, Poland - (WAW);Zagreb, Croatia - (ZAG);Zürich, Switzerland - (ZRH);Arica, Chile - (ARI);Asunción, Paraguay - (ASU);Bogotá, Colombia - (BOG);Buenos Aires, Argentina - (EZE);Curitiba, Brazil - (CWB);Fortaleza, Brazil - (FOR);Guatemala City, Guatemala - (GUA);Lima, Peru - (LIM);Medellín, Colombia - (MDE);Panama City, Panama - (PTY);Porto Alegre, Brazil - (POA);Quito, Ecuador - (UIO);Rio de Janeiro, Brazil - (GIG);São Paulo, Brazil - (GRU);Santiago, Chile - (SCL);Willemstad, Curaçao - (CUR);St. George's, Grenada - (GND);Amman, Jordan - (AMM);Baghdad, Iraq - (BGW);Baku, Azerbaijan - (GYD);Beirut, Lebanon - (BEY);Doha, Qatar - (DOH);Dubai, United Arab Emirates - (DXB);Kuwait City, Kuwait - (KWI);Manama, Bahrain - (BAH);Muscat, Oman - (MCT);Ramallah - (ZDM);Riyadh, Saudi Arabia - (RUH);Tel Aviv, Israel - (TLV);Ashburn, VA, United States - (IAD);Atlanta, GA, United States - (ATL);Boston, MA, United States - (BOS);Buffalo, NY, United States - (BUF);Calgary, AB, Canada - (YYC);Charlotte, NC, United States - (CLT);Chicago, IL, United States - (ORD);Columbus, OH, United States - (CMH);Dallas, TX, United States - (DFW);Denver, CO, United States - (DEN);Detroit, MI, United States - (DTW);Honolulu, HI, United States - (HNL);Houston, TX, United States - (IAH);Indianapolis, IN, United States - (IND);Jacksonville, FL, United States - (JAX);Kansas City, MO, United States - (MCI);Las Vegas, NV, United States - (LAS);Los Angeles, CA, United States - (LAX);McAllen, TX, United States - (MFE);Memphis, TN, United States - (MEM);Mexico City, Mexico - (MEX);Miami, FL, United States - (MIA);Minneapolis, MN, United States - (MSP);Montgomery, AL, United States - (MGM);Montréal, QC, Canada - (YUL);Nashville, TN, United States - (BNA);Newark, NJ, United States - (EWR);Norfolk, VA, United States - (ORF);Omaha, NE, United States - (OMA);Philadelphia, United States - (PHL);Phoenix, AZ, United States - (PHX);Pittsburgh, PA, United States - (PIT);Port-Au-Prince, Haiti - (PAP);Portland, OR, United States - (PDX);Queretaro, MX, Mexico - (QRO);Richmond, Virginia - (RIC);Sacramento, CA, United States - (SMF);Salt Lake City, UT, United States - (SLC);San Diego, CA, United States - (SAN);San Jose, CA, United States - (SJC);Saskatoon, SK, Canada - (YXE);Seattle, WA, United States - (SEA);St. Louis, MO, United States - (STL);Tampa, FL, United States - (TPA);Toronto, ON, Canada - (YYZ);Vancouver, BC, Canada - (YVR);Tallahassee, FL, United States - (TLH);Winnipeg, MB, Canada - (YWG);Adelaide, SA, Australia - (ADL);Auckland, New Zealand - (AKL);Brisbane, QLD, Australia - (BNE);Melbourne, VIC, Australia - (MEL);Noumea, New caledonia - (NOU);Perth, WA, Australia - (PER);Sydney, NSW, Australia - (SYD)".split(";"),e=a.split("colo=")[1].split("\n")[0],t=(a.split("colo=")[1].split("\n")[0],a.split("tls=")[1].split("\n")[0]),o=a.split("http=")[1].split("\n")[0],s=a.split("sni=")[1].split("\n")[0],r=a.split("ip=")[1].split("\n")[0],l=a.split("uag=")[1].split("\n")[0];for(var d=0;d<i.length;d++)if(-1!=i[d].indexOf(e)){document.getElementById("cdn").innerHTML=i[d];break}document.getElementById("tls").innerHTML=t,document.getElementById("http").innerHTML=o,document.getElementById("sni").innerHTML=s,document.getElementById("ip").innerHTML=r,document.getElementById("useragent").innerHTML=l}})},$(document).ready((function(){getCDNinfo()}))</script></p><p style="text-align:center">感谢陪伴与布道，开源之火不灭。​</p><p style="text-align:center"><script>document.write("本次加载耗时: "+(performance.getEntriesByType("navigation").reduce((e,r)=>e+r.responseEnd-r.startTime,0)+performance.getEntriesByType("resource").reduce((e,r)=>e+r.responseEnd-r.startTime,0)).toFixed(0)+"ms")</script></p><p style="text-align:center">当前 SNI 状态： <span id="sni">正在统计！或可能被浏览器防追踪拦截！</span></p><p style="text-align:center">当前 TLS 版本： <span id="tls">正在统计！或可能被浏览器防追踪拦截！</span></p><p style="text-align:center">当前 HTTP 版本： <span id="http">正在统计！或可能被浏览器防追踪拦截！</span></p><p style="text-align:center">当前您的客户端 IP 是： <span id="ip">正在统计！或可能被浏览器防追踪拦截！</span></p><p style="text-align:center">当前分配的 CDN 节点是: <span id="cdn">正在统计！或可能被浏览器防追踪拦截！</span></p><p style="text-align:center">您的 UserAgent 信息是: <span id="useragent">正在统计！或可能被浏览器防追踪拦截！</span></p><p></p><script defer src="https://pv.undefined.today/tracker.min.js" data-website-id="LinuxCNMirror-tracker"></script></div></div></body></html>