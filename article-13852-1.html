<!doctype html><html lang="en"><head><meta name="msvalidate.01" content="D404690CEFCB54C7762AC84935B99171"><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?6618da70c90c8744eead2e9371fb5077";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><script type="text/javascript">!function(t,e,n,c,s,a,r){t[n]=t[n]||function(){(t[n].q=t[n].q||[]).push(arguments)},(a=e.createElement(c)).async=1,a.src="https://www.clarity.ms/tag/s5f3f0tojf",(r=e.getElementsByTagName(c)[0]).parentNode.insertBefore(a,r)}(window,document,"clarity","script")</script><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta http-equiv="X-UA-Compatible" content="ie=edge"><link rel="stylesheet" href="/styles/base.css"><link rel="stylesheet" href="/styles/theme.css"><link rel="shortcut icon" href="/favicon.png"><title>使用 trace-cmd 追踪内核 - 归墟星火集 又一个 LinuxCN 站点</title><meta name="generator" content="Hexo 7.3.0"></head><body><div class="header-title"><span class="header-light"></span> <span class="header-light"></span> <span class="header-light"></span> <span>归墟星火集 又一个 LinuxCN 站点 linuxcn.undefined.today<span></span></span></div><div class="container"><ul class="nav"><li><a href="/">首页</a></li><li><a target="_blank" rel="noopener" href="https://undefined.today/">Blog</a></li></ul><div class="content"><div class="post-container"><div class="post-header"><span class="ui-tips">标题：</span><h1 class="ui-keyword post-title">使用 trace-cmd 追踪内核</h1><span class="post-date">2021-10-05</span></div><div class="post-header"><span class="ui-tips">分类：</span> <a href="/categories/%E6%8A%80%E6%9C%AF/">技术</a></div><div class="post-header"><span class="ui-tips">标签：</span> <a href="/tags/%E5%86%85%E6%A0%B8/">内核</a> <a href="/tags/%E8%BF%BD%E8%B8%AA/">追踪</a></div><div class="post-content"><blockquote><p>trace-cmd 是一个易于使用，且特性众多、可用来追踪内核函数的命令。</p></blockquote><p><img src="https://linuxcn.img.undefined.today/data/attachment/album/202110/05/145818d2i9tgjetzj8itqg.jpg" title="Puzzle pieces coming together to form a computer screen"></p><p>在 <a href="/article-13752-1.html">之前的文章</a> 里，我介绍了如何利用 <code>ftrace</code> 来追踪内核函数。通过写入和读出文件来使用 <code>ftrace</code> 会变得很枯燥，所以我对它做了一个封装来运行带有选项的命令，以启用和禁用追踪、设置过滤器、查看输出、清除输出等等。</p><p><a target="_blank" rel="noopener" href="https://lwn.net/Articles/410200/">trace-cmd</a> 命令是一个可以帮助你做到这一点的工具。在这篇文章中，我使用 <code>trace-cmd</code> 来执行我在 <code>ftrace</code> 文章中所做的相同任务。由于会经常参考那篇文章，建议在阅读这篇文章之前先阅读它。</p><h3 id="安装-trace-cmd"><a href="#安装-trace-cmd" class="headerlink" title="安装 trace-cmd"></a>安装 trace-cmd</h3><p>本文中所有的命令都运行在 root 用户下。</p><p>因为 <code>ftrace</code> 机制被内置于内核中，因此你可以使用下面的命令进行验证它是否启用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># mount | grep tracefs</span><br><span class="line">none on /sys/kernel/tracing type tracefs (rw,relatime,seclabel)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>不过，你需要手动尝试安装 <code>trace-cmd</code> 命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># dnf install trace-cmd -y</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="列出可用的追踪器"><a href="#列出可用的追踪器" class="headerlink" title="列出可用的追踪器"></a>列出可用的追踪器</h3><p>当使用 <code>ftrace</code> 时，你必须查看文件的内容以了解有哪些追踪器可用。但使用 <code>trace-cmd</code>，你可以通过以下方式获得这些信息:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># trace-cmd list -t</span><br><span class="line">hwlat blk mmiotrace function_graph wakeup_dl wakeup_rt wakeup function nop</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="启用函数追踪器"><a href="#启用函数追踪器" class="headerlink" title="启用函数追踪器"></a>启用函数追踪器</h3><p>在我 <a href="/article-13752-1.html">之前的文章</a> 中，我使用了两个追踪器，在这里我也会这么做。用 <code>function</code> 启用你的第一个追踪器:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ trace-cmd start -p function</span><br><span class="line">  plugin &#x27;function&#x27;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="查看追踪输出"><a href="#查看追踪输出" class="headerlink" title="查看追踪输出"></a>查看追踪输出</h3><p>一旦追踪器被启用，你可以通过使用 <code>show</code> 参数来查看输出。这只显示了前 20 行以保持例子的简短（见我之前的文章对输出的解释）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"># trace-cmd show | head -20</span><br><span class="line">## tracer: function</span><br><span class="line">#</span><br><span class="line"># entries-in-buffer/entries-written: 410142/3380032   #P:8</span><br><span class="line">#</span><br><span class="line">#                                _-----=&gt; irqs-off</span><br><span class="line">#                               / _----=&gt; need-resched</span><br><span class="line">#                              | / _---=&gt; hardirq/softirq</span><br><span class="line">#                              || / _--=&gt; preempt-depth</span><br><span class="line">#                              ||| /     delay</span><br><span class="line">#           TASK-PID     CPU#  ||||   TIMESTAMP  FUNCTION</span><br><span class="line">#              | |         |   ||||      |         |</span><br><span class="line">           gdbus-2606    [004] ..s. 10520.538759: __msecs_to_jiffies &lt;-rebalance_domains</span><br><span class="line">           gdbus-2606    [004] ..s. 10520.538760: load_balance &lt;-rebalance_domains</span><br><span class="line">           gdbus-2606    [004] ..s. 10520.538761: idle_cpu &lt;-load_balance</span><br><span class="line">           gdbus-2606    [004] ..s. 10520.538762: group_balance_cpu &lt;-load_balance</span><br><span class="line">           gdbus-2606    [004] ..s. 10520.538762: find_busiest_group &lt;-load_balance</span><br><span class="line">           gdbus-2606    [004] ..s. 10520.538763: update_group_capacity &lt;-update_sd_lb_stats.constprop.0</span><br><span class="line">           gdbus-2606    [004] ..s. 10520.538763: __msecs_to_jiffies &lt;-update_group_capacity</span><br><span class="line">           gdbus-2606    [004] ..s. 10520.538765: idle_cpu &lt;-update_sd_lb_stats.constprop.0</span><br><span class="line">           gdbus-2606    [004] ..s. 10520.538766: __msecs_to_jiffies &lt;-rebalance_domains</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="停止追踪并清除缓冲区"><a href="#停止追踪并清除缓冲区" class="headerlink" title="停止追踪并清除缓冲区"></a>停止追踪并清除缓冲区</h3><p>追踪将会在后台继续运行，你可以继续用 <code>show</code> 查看输出。</p><p>要停止追踪，请运行带有 <code>stop</code> 参数的 <code>trace-cmd</code> 命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># trace-cmd stop</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>要清除缓冲区，用 <code>clear</code> 参数运行它：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># trace-cmd clear</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="启用函数调用图追踪器"><a href="#启用函数调用图追踪器" class="headerlink" title="启用函数调用图追踪器"></a>启用函数调用图追踪器</h3><p>运行第二个追踪器，通过 <code>function_graph</code> 参数来启用它。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># trace-cmd start -p function_graph</span><br><span class="line">  Plugin &#x27;function_graph&#x27;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>再次使用 <code>show</code> 参数查看输出。正如预期的那样，输出与第一次追踪输出略有不同。这一次，它包括一个<strong>函数调用</strong>链：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"># trace-cmd show | head -20</span><br><span class="line">## tracer: function_graph</span><br><span class="line">#</span><br><span class="line"># CPU  DURATION                  FUNCTION CALLS</span><br><span class="line"># |     |   |                     |   |   |   |</span><br><span class="line"> 4)   0.079 us    |        &#125; /* rcu_all_qs */</span><br><span class="line"> 4)   0.327 us    |      &#125; /* __cond_resched */</span><br><span class="line"> 4)   0.081 us    |      rcu_read_unlock_strict();</span><br><span class="line"> 4)               |      __cond_resched() &#123;</span><br><span class="line"> 4)   0.078 us    |        rcu_all_qs();</span><br><span class="line"> 4)   0.243 us    |      &#125;</span><br><span class="line"> 4)   0.080 us    |      rcu_read_unlock_strict();</span><br><span class="line"> 4)               |      __cond_resched() &#123;</span><br><span class="line"> 4)   0.078 us    |        rcu_all_qs();</span><br><span class="line"> 4)   0.241 us    |      &#125;</span><br><span class="line"> 4)   0.080 us    |      rcu_read_unlock_strict();</span><br><span class="line"> 4)               |      __cond_resched() &#123;</span><br><span class="line"> 4)   0.079 us    |        rcu_all_qs();</span><br><span class="line"> 4)   0.235 us    |      &#125;</span><br><span class="line"> 4)   0.095 us    |      rcu_read_unlock_strict();</span><br><span class="line"> 4)               |      __cond_resched() &#123;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>使用 <code>stop</code> 和 <code>clear</code> 命令来停止追踪和清除缓存区：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># trace-cmd stop</span><br><span class="line"># trace-cmd clear</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="调整追踪以增加深度"><a href="#调整追踪以增加深度" class="headerlink" title="调整追踪以增加深度"></a>调整追踪以增加深度</h3><p>如果你想在函数调用中看到更多的深度，你可以对追踪器进行调整：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># trace-cmd start -p function_graph --max-graph-depth 5</span><br><span class="line">  plugin &#x27;function_graph&#x27;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>现在，当你将这个输出与你之前看到的进行比较时，你应该看到更多的嵌套函数调用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"># trace-cmd show | head -20</span><br><span class="line">## tracer: function_graph</span><br><span class="line">#</span><br><span class="line"># CPU  DURATION                  FUNCTION CALLS</span><br><span class="line"># |     |   |                     |   |   |   |</span><br><span class="line"> 6)               |        __fget_light() &#123;</span><br><span class="line"> 6)   0.804 us    |          __fget_files();</span><br><span class="line"> 6)   2.708 us    |        &#125;</span><br><span class="line"> 6)   3.650 us    |      &#125; /* __fdget */</span><br><span class="line"> 6)   0.547 us    |      eventfd_poll();</span><br><span class="line"> 6)   0.535 us    |      fput();</span><br><span class="line"> 6)               |      __fdget() &#123;</span><br><span class="line"> 6)               |        __fget_light() &#123;</span><br><span class="line"> 6)   0.946 us    |          __fget_files();</span><br><span class="line"> 6)   1.895 us    |        &#125;</span><br><span class="line"> 6)   2.849 us    |      &#125;</span><br><span class="line"> 6)               |      sock_poll() &#123;</span><br><span class="line"> 6)   0.651 us    |        unix_poll();</span><br><span class="line"> 6)   1.905 us    |      &#125;</span><br><span class="line"> 6)   0.475 us    |      fput();</span><br><span class="line"> 6)               |      __fdget() &#123;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="了解可被追踪的函数"><a href="#了解可被追踪的函数" class="headerlink" title="了解可被追踪的函数"></a>了解可被追踪的函数</h3><p>如果你想只追踪某些函数而忽略其他的，你需要知道确切的函数名称。你可以用 <code>list -f</code> 参数来得到它们。例如搜索常见的内核函数 <code>kmalloc</code>，它被用来在内核中分配内存：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># trace-cmd list -f | grep kmalloc</span><br><span class="line">bpf_map_kmalloc_node</span><br><span class="line">mempool_kmalloc</span><br><span class="line">__traceiter_kmalloc</span><br><span class="line">__traceiter_kmalloc_node</span><br><span class="line">kmalloc_slab</span><br><span class="line">kmalloc_order</span><br><span class="line">kmalloc_order_trace</span><br><span class="line">kmalloc_large_node</span><br><span class="line">__kmalloc</span><br><span class="line">__kmalloc_track_caller</span><br><span class="line">__kmalloc_node</span><br><span class="line">__kmalloc_node_track_caller</span><br><span class="line">[...]</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>下面是我的测试系统中可被追踪的函数总数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># trace-cmd list -f | wc -l</span><br><span class="line">63165</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="追踪内核模块相关的函数"><a href="#追踪内核模块相关的函数" class="headerlink" title="追踪内核模块相关的函数"></a>追踪内核模块相关的函数</h3><p>你也可以追踪与特定内核模块相关的函数。假设你想追踪 <code>kvm</code> 内核模块相关的功能，你可以通过以下方式来实现。请确保该模块已经加载：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># lsmod | grep kvm_intel</span><br><span class="line">kvm_intel 335872 0</span><br><span class="line">kvm 987136 1 kvm_intel</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>再次运行 <code>trace-cmd</code>，使用 <code>list</code> 参数，并从输出结果中，<code>grep</code> 查找以 <code>]</code> 结尾的行。这将过滤掉内核模块。然后 <code>grep</code> 内核模块 <code>kvm_intel</code> ，你应该看到所有与该内核模块有关的函数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># trace-cmd list -f | grep ]$  | grep kvm_intel</span><br><span class="line">vmx_can_emulate_instruction [kvm_intel]</span><br><span class="line">vmx_update_emulated_instruction [kvm_intel]</span><br><span class="line">vmx_setup_uret_msr [kvm_intel]</span><br><span class="line">vmx_set_identity_map_addr [kvm_intel]</span><br><span class="line">handle_machine_check [kvm_intel]</span><br><span class="line">handle_triple_fault [kvm_intel]</span><br><span class="line">vmx_patch_hypercall [kvm_intel]</span><br><span class="line"></span><br><span class="line">[...]</span><br><span class="line"></span><br><span class="line">vmx_dump_dtsel [kvm_intel]</span><br><span class="line">vmx_dump_sel [kvm_intel]</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="追踪特定函数"><a href="#追踪特定函数" class="headerlink" title="追踪特定函数"></a>追踪特定函数</h3><p>现在你知道了如何找到感兴趣的函数，请用一个例子把这些内容用于时间。就像前面的文章一样，试着追踪与文件系统相关的函数。我的测试系统上的文件系统是 <code>ext4</code>。</p><p>这个过程略有不同；你在运行命令时，不使用 <code>start</code> 参数，而是在 <code>record</code> 参数后面加上你想追踪的函数的“模式”。你还需要指定你想要的追踪器；在这种情况下，就是 <code>function_graph</code>。该命令会继续记录追踪，直到你用 <code>Ctrl+C</code> 停止它。所以几秒钟后，按 <code>Ctrl+C</code> 停止追踪：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># trace-cmd list -f | grep ^ext4_</span><br><span class="line"></span><br><span class="line"># trace-cmd record -l ext4_* -p function_graph</span><br><span class="line">  plugin &#x27;function_graph&#x27;</span><br><span class="line">Hit Ctrl^C to stop recording</span><br><span class="line">^C</span><br><span class="line">CPU0 data recorded at offset=0x856000</span><br><span class="line">    8192 bytes in size</span><br><span class="line">[...]</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="查看追踪记录"><a href="#查看追踪记录" class="headerlink" title="查看追踪记录"></a>查看追踪记录</h3><p>要查看你之前的追踪记录，运行带有 <code>report</code> 参数的命令。从输出结果来看，很明显过滤器起作用了，你只看到 <code>ext4</code> 相关的函数追踪：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># trace-cmd report | head -20</span><br><span class="line">[...]</span><br><span class="line">cpus=8</span><br><span class="line">       trace-cmd-12697 [000] 11303.928103: funcgraph_entry:                   |  ext4_show_options() &#123;</span><br><span class="line">       trace-cmd-12697 [000] 11303.928104: funcgraph_entry:        0.187 us   |    ext4_get_dummy_policy();</span><br><span class="line">       trace-cmd-12697 [000] 11303.928105: funcgraph_exit:         1.583 us   |  &#125;</span><br><span class="line">       trace-cmd-12697 [000] 11303.928122: funcgraph_entry:                   |  ext4_create() &#123;</span><br><span class="line">       trace-cmd-12697 [000] 11303.928122: funcgraph_entry:                   |    ext4_alloc_inode() &#123;</span><br><span class="line">       trace-cmd-12697 [000] 11303.928123: funcgraph_entry:        0.101 us   |      ext4_es_init_tree();</span><br><span class="line">       trace-cmd-12697 [000] 11303.928123: funcgraph_entry:        0.083 us   |      ext4_init_pending_tree();</span><br><span class="line">       trace-cmd-12697 [000] 11303.928123: funcgraph_entry:        0.141 us   |      ext4_fc_init_inode();</span><br><span class="line">       trace-cmd-12697 [000] 11303.928123: funcgraph_exit:         0.931 us   |    &#125;</span><br><span class="line">       trace-cmd-12697 [000] 11303.928124: funcgraph_entry:        0.081 us   |    ext4_get_dummy_policy();</span><br><span class="line">       trace-cmd-12697 [000] 11303.928124: funcgraph_entry:        0.133 us   |    ext4_get_group_desc();</span><br><span class="line">       trace-cmd-12697 [000] 11303.928124: funcgraph_entry:        0.115 us   |    ext4_free_inodes_count();</span><br><span class="line">       trace-cmd-12697 [000] 11303.928124: funcgraph_entry:        0.114 us   |    ext4_get_group_desc();</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="追踪一个特定的-PID"><a href="#追踪一个特定的-PID" class="headerlink" title="追踪一个特定的 PID"></a>追踪一个特定的 PID</h3><p>假设你想追踪与一个进程（PID）有关的函数。打开另一个终端，注意运行中的 shell 的PID：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># echo $$</span><br><span class="line">10885</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>再次运行 <code>record</code> 命令，用 <code>-P</code> 选项传递PID。这一次，让终端运行（也就是说，先不要按 <code>Ctrl+C</code> ）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># trace-cmd record -P 10885 -p function_graph</span><br><span class="line">  Plugin &#x27;function_graph&#x27;</span><br><span class="line">Hit Ctrl^C to stop recording</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="在-shell-上运行一些命令"><a href="#在-shell-上运行一些命令" class="headerlink" title="在 shell 上运行一些命令"></a>在 shell 上运行一些命令</h3><p>移动到另一个终端，在那里你有一个以特定 PID 运行的 shell，并运行任何命令，例如，<code>ls</code> 命令用来列出文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># ls</span><br><span class="line">Temp-9b61f280-fdc1-4512-9211-5c60f764d702</span><br><span class="line">tracker-extract-3-files.1000</span><br><span class="line">v8-compile-cache-1000</span><br><span class="line">[...]</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>移动到你启用追踪的终端，按 <code>Ctrl+C</code> 停止追踪：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># trace-cmd record -P 10885 -p function_graph</span><br><span class="line">  plugin &#x27;function_graph&#x27;</span><br><span class="line">Hit Ctrl^C to stop recording</span><br><span class="line">^C</span><br><span class="line">CPU1 data recorded at offset=0x856000</span><br><span class="line">    618496 bytes in size</span><br><span class="line">[...]</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在追踪的输出中，你可以看到左边是 PID 和 Bash shell，右边是与之相关的函数调用。这对于缩小你的追踪范围是非常方便的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># trace-cmd report  | head -20</span><br><span class="line"></span><br><span class="line">cpus=8</span><br><span class="line">          &lt;idle&gt;-0     [001] 11555.380581: funcgraph_entry:                   |  switch_mm_irqs_off() &#123;</span><br><span class="line">          &lt;idle&gt;-0     [001] 11555.380583: funcgraph_entry:        1.703 us   |    load_new_mm_cr3();</span><br><span class="line">          &lt;idle&gt;-0     [001] 11555.380586: funcgraph_entry:        0.493 us   |    switch_ldt();</span><br><span class="line">          &lt;idle&gt;-0     [001] 11555.380587: funcgraph_exit:         7.235 us   |  &#125;</span><br><span class="line">            bash-10885 [001] 11555.380589: funcgraph_entry:        1.046 us   |  finish_task_switch.isra.0();</span><br><span class="line">            bash-10885 [001] 11555.380591: funcgraph_entry:                   |  __fdget() &#123;</span><br><span class="line">            bash-10885 [001] 11555.380592: funcgraph_entry:        2.036 us   |    __fget_light();</span><br><span class="line">            bash-10885 [001] 11555.380594: funcgraph_exit:         3.256 us   |  &#125;</span><br><span class="line">            bash-10885 [001] 11555.380595: funcgraph_entry:                   |  tty_poll() &#123;</span><br><span class="line">            bash-10885 [001] 11555.380597: funcgraph_entry:                   |    tty_ldisc_ref_wait() &#123;</span><br><span class="line">            bash-10885 [001] 11555.380598: funcgraph_entry:                   |      ldsem_down_read() &#123;</span><br><span class="line">            bash-10885 [001] 11555.380598: funcgraph_entry:                   |        __cond_resched() &#123;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="试一试"><a href="#试一试" class="headerlink" title="试一试"></a>试一试</h3><p>这些简短的例子显示了使用 <code>trace-cmd</code> 命令而不是底层的 <code>ftrace</code> 机制，是如何实现既容易使用又拥有丰富的功能，许多内容本文并没有涉及。要想了解更多信息并更好地使用它，请查阅它的手册，并尝试使用其他有用的命令。</p><hr><p>via: <a target="_blank" rel="noopener" href="https://opensource.com/article/21/7/linux-kernel-trace-cmd">https://opensource.com/article/21/7/linux-kernel-trace-cmd</a></p><p>作者：<a target="_blank" rel="noopener" href="https://opensource.com/users/gkamathe">Gaurav Kamathe</a> 选题：<a target="_blank" rel="noopener" href="https://github.com/lujun9972">lujun9972</a> 译者：<a target="_blank" rel="noopener" href="https://github.com/mengxinayan">萌新阿岩</a> 校对：<a target="_blank" rel="noopener" href="https://github.com/wxy">wxy</a></p><p>本文由 <a target="_blank" rel="noopener" href="https://github.com/LCTT/TranslateProject">LCTT</a> 原创编译，<a target="_blank" rel="noopener" href="https://linux.cn/">Linux中国</a> 荣誉推出</p></div></div></div><div class="footer"><p class="footer-copyright"><span>Powered by <a target="_blank" href="https://hexo.io">Hexo</a></span> <span>Theme <a target="_blank" href="https://github.com/tinkink-co/hexo-theme-terminal">Terminal</a></span><script type="text/javascript" src="https://cdn.staticfile.net/jquery/3.4.1/jquery.min.js"></script><script>getCDNinfo=function(){$.ajax({url:"/cdn-cgi/trace",success:function(a,n){let i="Antananarivo, Madagascar - (TNR);Cape Town, South Africa - (CPT);Casablanca, Morocco - (CMN);Dar Es Salaam, Tanzania - (DAR);Djibouti City, Djibouti - (JIB);Durban, South Africa - (DUR);Johannesburg, South Africa - (JNB);Kigali, Rwanda - (KGL);Lagos, Nigeria - (LOS);Luanda, Angola - (LAD);Maputo, MZ - (MPM);Mombasa, Kenya - (MBA);Port Louis, Mauritius - (MRU);Réunion, France - (RUN);Bangalore, India - (BLR);Bangkok, Thailand - (BKK);Bandar Seri Begawan, Brunei - (BWN);Cebu, Philippines - (CEB);Chengdu, China - (CTU);Chennai, India - (MAA);Chittagong, Bangladesh - (CGP);Chongqing, China - (CKG);Colombo, Sri Lanka - (CMB);Dhaka, Bangladesh - (DAC);Dongguan, China - (SZX);Foshan, China - (FUO);Fuzhou, China - (FOC);Guangzhou, China - (CAN);Hangzhou, China - (HGH);Hanoi, Vietnam - (HAN);Hengyang, China - (HNY);Ho Chi Minh City, Vietnam - (SGN);Hong Kong - (HKG);Hyderabad, India - (HYD);Islamabad, Pakistan - (ISB);Jakarta, Indonesia - (CGK);Jinan, China - (TNA);Karachi, Pakistan - (KHI);Kathmandu, Nepal - (KTM);Kolkata, India - (CCU);Kuala Lumpur, Malaysia - (KUL);Lahore, Pakistan - (LHE);Langfang, China - (NAY);Luoyang, China - (LYA);Macau - (MFM);Malé, Maldives - (MLE);Manila, Philippines - (MNL);Mumbai, India - (BOM);Nagpur, India - (NAG);Nanning, China - (NNG);New Delhi, India - (DEL);Osaka, Japan - (KIX);Phnom Penh, Cambodia - (PNH);Qingdao, China - (TAO);Seoul, South Korea - (ICN);Shanghai, China - (SHA);Shenyang, China - (SHE);Shijiazhuang, China - (SJW);Singapore, Singapore - (SIN);Suzhou, China - (SZV);Taipei - (TPE);Thimphu, Bhutan - (PBH);Tianjin, China - (TSN);Tokyo, Japan - (NRT);Ulaanbaatar, Mongolia - (ULN);Vientiane, Laos - (VTE);Wuhan, China - (WUH);Wuxi, China - (WUX);Xi'an, China - (XIY);Yerevan, Armenia - (EVN);Zhengzhou, China - (CGO);Zuzhou, China - (CSX);Amsterdam, Netherlands - (AMS);Athens, Greece - (ATH);Barcelona, Spain - (BCN);Belgrade, Serbia - (BEG);Berlin, Germany - (TXL);Brussels, Belgium - (BRU);Bucharest, Romania - (OTP);Budapest, Hungary - (BUD);Chișinău, Moldova - (KIV);Copenhagen, Denmark - (CPH);Cork, Ireland -  (ORK);Dublin, Ireland - (DUB);Düsseldorf, Germany - (DUS);Edinburgh, United Kingdom - (EDI);Frankfurt, Germany - (FRA);Geneva, Switzerland - (GVA);Gothenburg, Sweden - (GOT);Hamburg, Germany - (HAM);Helsinki, Finland - (HEL);Istanbul, Turkey - (IST);Kyiv, Ukraine - (KBP);Lisbon, Portugal - (LIS);London, United Kingdom - (LHR);Luxembourg City, Luxembourg - (LUX);Madrid, Spain - (MAD);Manchester, United Kingdom - (MAN);Marseille, France - (MRS);Milan, Italy - (MXP);Moscow, Russia - (DME);Munich, Germany - (MUC);Nicosia, Cyprus - (LCA);Oslo, Norway - (OSL);Paris, France - (CDG);Prague, Czech Republic - (PRG);Reykjavík, Iceland - (KEF);Riga, Latvia - (RIX);Rome, Italy - (FCO);Saint Petersburg, Russia - (LED);Sofia, Bulgaria - (SOF);Stockholm, Sweden - (ARN);Tallinn, Estonia - (TLL);Thessaloniki, Greece - (SKG);Vienna, Austria - (VIE);Vilnius, Lithuania - (VNO);Warsaw, Poland - (WAW);Zagreb, Croatia - (ZAG);Zürich, Switzerland - (ZRH);Arica, Chile - (ARI);Asunción, Paraguay - (ASU);Bogotá, Colombia - (BOG);Buenos Aires, Argentina - (EZE);Curitiba, Brazil - (CWB);Fortaleza, Brazil - (FOR);Guatemala City, Guatemala - (GUA);Lima, Peru - (LIM);Medellín, Colombia - (MDE);Panama City, Panama - (PTY);Porto Alegre, Brazil - (POA);Quito, Ecuador - (UIO);Rio de Janeiro, Brazil - (GIG);São Paulo, Brazil - (GRU);Santiago, Chile - (SCL);Willemstad, Curaçao - (CUR);St. George's, Grenada - (GND);Amman, Jordan - (AMM);Baghdad, Iraq - (BGW);Baku, Azerbaijan - (GYD);Beirut, Lebanon - (BEY);Doha, Qatar - (DOH);Dubai, United Arab Emirates - (DXB);Kuwait City, Kuwait - (KWI);Manama, Bahrain - (BAH);Muscat, Oman - (MCT);Ramallah - (ZDM);Riyadh, Saudi Arabia - (RUH);Tel Aviv, Israel - (TLV);Ashburn, VA, United States - (IAD);Atlanta, GA, United States - (ATL);Boston, MA, United States - (BOS);Buffalo, NY, United States - (BUF);Calgary, AB, Canada - (YYC);Charlotte, NC, United States - (CLT);Chicago, IL, United States - (ORD);Columbus, OH, United States - (CMH);Dallas, TX, United States - (DFW);Denver, CO, United States - (DEN);Detroit, MI, United States - (DTW);Honolulu, HI, United States - (HNL);Houston, TX, United States - (IAH);Indianapolis, IN, United States - (IND);Jacksonville, FL, United States - (JAX);Kansas City, MO, United States - (MCI);Las Vegas, NV, United States - (LAS);Los Angeles, CA, United States - (LAX);McAllen, TX, United States - (MFE);Memphis, TN, United States - (MEM);Mexico City, Mexico - (MEX);Miami, FL, United States - (MIA);Minneapolis, MN, United States - (MSP);Montgomery, AL, United States - (MGM);Montréal, QC, Canada - (YUL);Nashville, TN, United States - (BNA);Newark, NJ, United States - (EWR);Norfolk, VA, United States - (ORF);Omaha, NE, United States - (OMA);Philadelphia, United States - (PHL);Phoenix, AZ, United States - (PHX);Pittsburgh, PA, United States - (PIT);Port-Au-Prince, Haiti - (PAP);Portland, OR, United States - (PDX);Queretaro, MX, Mexico - (QRO);Richmond, Virginia - (RIC);Sacramento, CA, United States - (SMF);Salt Lake City, UT, United States - (SLC);San Diego, CA, United States - (SAN);San Jose, CA, United States - (SJC);Saskatoon, SK, Canada - (YXE);Seattle, WA, United States - (SEA);St. Louis, MO, United States - (STL);Tampa, FL, United States - (TPA);Toronto, ON, Canada - (YYZ);Vancouver, BC, Canada - (YVR);Tallahassee, FL, United States - (TLH);Winnipeg, MB, Canada - (YWG);Adelaide, SA, Australia - (ADL);Auckland, New Zealand - (AKL);Brisbane, QLD, Australia - (BNE);Melbourne, VIC, Australia - (MEL);Noumea, New caledonia - (NOU);Perth, WA, Australia - (PER);Sydney, NSW, Australia - (SYD)".split(";"),e=a.split("colo=")[1].split("\n")[0],t=(a.split("colo=")[1].split("\n")[0],a.split("tls=")[1].split("\n")[0]),o=a.split("http=")[1].split("\n")[0],s=a.split("sni=")[1].split("\n")[0],r=a.split("ip=")[1].split("\n")[0],l=a.split("uag=")[1].split("\n")[0];for(var d=0;d<i.length;d++)if(-1!=i[d].indexOf(e)){document.getElementById("cdn").innerHTML=i[d];break}document.getElementById("tls").innerHTML=t,document.getElementById("http").innerHTML=o,document.getElementById("sni").innerHTML=s,document.getElementById("ip").innerHTML=r,document.getElementById("useragent").innerHTML=l}})},$(document).ready((function(){getCDNinfo()}))</script></p><p style="text-align:center">感谢陪伴与布道，开源之火不灭。​</p><p style="text-align:center"><script>document.write("本次加载耗时: "+(performance.getEntriesByType("navigation").reduce((e,r)=>e+r.responseEnd-r.startTime,0)+performance.getEntriesByType("resource").reduce((e,r)=>e+r.responseEnd-r.startTime,0)).toFixed(0)+"ms")</script></p><p style="text-align:center">当前 SNI 状态： <span id="sni">正在统计！或可能被浏览器防追踪拦截！</span></p><p style="text-align:center">当前 TLS 版本： <span id="tls">正在统计！或可能被浏览器防追踪拦截！</span></p><p style="text-align:center">当前 HTTP 版本： <span id="http">正在统计！或可能被浏览器防追踪拦截！</span></p><p style="text-align:center">当前您的客户端 IP 是： <span id="ip">正在统计！或可能被浏览器防追踪拦截！</span></p><p style="text-align:center">当前分配的 CDN 节点是: <span id="cdn">正在统计！或可能被浏览器防追踪拦截！</span></p><p style="text-align:center">您的 UserAgent 信息是: <span id="useragent">正在统计！或可能被浏览器防追踪拦截！</span></p><p></p></div></div></body></html>