<!doctype html><html lang="en"><head><meta name="description" content="一个LinuxCN的镜像站"><meta name="msvalidate.01" content="D404690CEFCB54C7762AC84935B99171"><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?6618da70c90c8744eead2e9371fb5077";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><script type="text/javascript">!function(t,e,n,c,s,a,r){t[n]=t[n]||function(){(t[n].q=t[n].q||[]).push(arguments)},(a=e.createElement(c)).async=1,a.src="https://www.clarity.ms/tag/s5f3f0tojf",(r=e.getElementsByTagName(c)[0]).parentNode.insertBefore(a,r)}(window,document,"clarity","script")</script><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta http-equiv="X-UA-Compatible" content="ie=edge"><link rel="stylesheet" href="/styles/base.css"><link rel="stylesheet" href="/styles/theme.css"><link rel="shortcut icon" href="/favicon.png"><title>这儿几个字节，那里几个字节，我们说的是真正的内存 - 归墟星火集 又一个 LinuxCN 站点</title><meta name="generator" content="Hexo 7.3.0"></head><body><div class="header-title"><span class="header-light"></span> <span class="header-light"></span> <span class="header-light"></span> <span>归墟星火集 又一个 LinuxCN 站点 linuxcn.undefined.today<span></span></span></div><div class="container"><ul class="nav"><li><a href="/">首页</a></li><li><a target="_blank" rel="noopener" href="https://undefined.today/">Blog</a></li></ul><div class="content"><div class="post-container"><div class="post-header"><span class="ui-tips">标题：</span><h1 class="ui-keyword post-title">这儿几个字节，那里几个字节，我们说的是真正的内存</h1><span class="post-date">2023-11-15</span></div><div class="post-header"><span class="ui-tips">分类：</span> <a href="/categories/%E6%8A%80%E6%9C%AF/">技术</a></div><div class="post-header"><span class="ui-tips">标签：</span> <a href="/tags/%E5%86%85%E5%AD%98/">内存</a> <a href="/tags/Go/">Go</a></div><div class="post-content"><p><img src="https://linuxcn.img.undefined.today/data/attachment/album/202311/15/154636bhoqwdrdxczdhzxg.png"></p><p>今天的帖子来自于最近的 Go 语言的一次小测试，观察下面的测试基础片段 <sup class="footnote-ref"><a href="#fn1" id="fnref1">[1] </a></sup>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">func BenchmarkSortStrings(b *testing.B) &#123;</span><br><span class="line">        s := []string&#123;&quot;heart&quot;, &quot;lungs&quot;, &quot;brain&quot;, &quot;kidneys&quot;, &quot;pancreas&quot;&#125;</span><br><span class="line">        b.ReportAllocs()</span><br><span class="line">        for i := 0; i &lt; b.N; i++ &#123;</span><br><span class="line">                sort.Strings(s)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>sort.Strings</code> 是 <code>sort.StringSlice(s)</code> 的便捷包装器，<code>sort.Strings</code> 在原地对输入进行排序，因此不会分配内存（或至少 43% 回答此问题的 Twitter 用户是这么认为的）。然而，至少在 Go 的最近版本中，基准测试的每次迭代都会导致一次堆分配。为什么会是这种情况？</p><p>正如所有 Go 程序员应该知道的那样，接口是以 <a target="_blank" rel="noopener" href="https://research.swtch.com/interfaces">双词结构</a> 实现的。每个接口值包含一个字段，其中保存接口内容的类型，以及指向接口内容的指针。<sup class="footnote-ref"> <a href="#fn2" id="fnref2">[2]</a></sup></p><p>在 Go 语言伪代码中，一个接口可能是这样的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">type interface struct &#123;</span><br><span class="line">        // the ordinal number for the type of the value</span><br><span class="line">        // assigned to the interface </span><br><span class="line">        type uintptr</span><br><span class="line"></span><br><span class="line">        // (usually) a pointer to the value assigned to</span><br><span class="line">        // the interface</span><br><span class="line">        data uintptr</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>interface.data</code> 可以容纳一个机器字（在大多数情况下为 8 个字节），但一个 <code>[]string</code> 却需要 24 个字节：一个字用于指向切片的底层数组；一个字用于存储切片的长度；另一个字用于存储底层数组的剩余容量。那么，Go 是如何将 24 个字节装入个 8 个字节的呢？通过编程中最古老的技巧，即间接引用。一个 <code>[]string</code>，即 <code>s</code>，需要 24 个字节；但 <code>*[]string</code> —— 即指向字符串切片的指针，只需要 8 个字节。</p><h3 id="逃逸到堆"><a href="#逃逸到堆" class="headerlink" title="逃逸到堆"></a>逃逸到堆</h3><p>为了让示例更加明确，以下是重新编写的基准测试，不使用 <code>sort.Strings</code> 辅助函数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">func BenchmarkSortStrings(b *testing.B) &#123;</span><br><span class="line">        s := []string&#123;&quot;heart&quot;, &quot;lungs&quot;, &quot;brain&quot;, &quot;kidneys&quot;, &quot;pancreas&quot;&#125;</span><br><span class="line">        b.ReportAllocs()</span><br><span class="line">        for i := 0; i &lt; b.N; i++ &#123;</span><br><span class="line">                var ss sort.StringSlice = s</span><br><span class="line">                var si sort.Interface = ss // allocation</span><br><span class="line">                sort.Sort(si)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>为了让接口正常运行，编译器将赋值重写为 <code>var si sort.Interface = &amp;ss</code>，即 <code>ss</code> 的地址分配给接口值。<sup class="footnote-ref"> <a href="#fn3" id="fnref3">[3] </a></sup>我们现在有这么一种情况：出现一个持有指向 <code>ss</code> 的指针的接口值。它指向哪里？还有 <code>ss</code> 存储在哪个内存位置？</p><p>似乎 <code>ss</code> 被移动到了堆上，这也同时导致了基准测试报告中的分配：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Total:    296.01MB   296.01MB (flat, cum) 99.66%</span><br><span class="line">      8            .          .           func BenchmarkSortStrings(b *testing.B) &#123; </span><br><span class="line">      9            .          .           	s := []string&#123;&quot;heart&quot;, &quot;lungs&quot;, &quot;brain&quot;, &quot;kidneys&quot;, &quot;pancreas&quot;&#125; </span><br><span class="line">     10            .          .           	b.ReportAllocs() </span><br><span class="line">     11            .          .           	for i := 0; i &lt; b.N; i++ &#123; </span><br><span class="line">     12            .          .           		var ss sort.StringSlice = s </span><br><span class="line">     13     296.01MB   296.01MB           		var si sort.Interface = ss // allocation </span><br><span class="line">     14            .          .           		sort.Sort(si) </span><br><span class="line">     15            .          .           	&#125; </span><br><span class="line">     16            .          .           &#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>发生这种分配是因为编译器当前无法确认 <code>ss</code> 比 <code>si</code> 生存期更长。Go 编译器开发人员对此的普遍态度是，觉得 <a target="_blank" rel="noopener" href="https://github.com/golang/go/issues/23676">这个问题改进的余地</a>，不过我们另找时间再议。事实上，<code>ss</code> 就是被分配到了堆上。因此，问题变成了：每次迭代会分配多少个字节？为什么不去询问 <code>testing</code> 包呢？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">% go test -bench=. sort_test.go</span><br><span class="line">goos: darwin</span><br><span class="line">goarch: amd64</span><br><span class="line">cpu: Intel(R) Core(TM) i7-5650U CPU @ 2.20GHz</span><br><span class="line">BenchmarkSortStrings-4          12591951                91.36 ns/op           24 B/op          1 allocs/op</span><br><span class="line">PASS</span><br><span class="line">ok      command-line-arguments  1.260s</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以看到，在 amd 64 平台的 Go 1.16 beta1 版本上，每次操作会分配 24 字节。<sup class="footnote-ref"> <a href="#fn4" id="fnref4">[4] </a></sup>然而，在同一平台先前的 Go 版本中，每次操作则消耗了 32 字节。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">% go1.15 test -bench=. sort_test.go</span><br><span class="line">goos: darwin</span><br><span class="line">goarch: amd64</span><br><span class="line">BenchmarkSortStrings-4          11453016                96.4 ns/op            32 B/op          1 allocs/op</span><br><span class="line">PASS</span><br><span class="line">ok      command-line-arguments  1.225s</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这引出了本文的主题，即 Go 1.16 版本中即将推出的一项便利改进。不过在讨论这个内容之前，我需要聊聊 “<ruby>尺寸类别 <rt>size class</rt></ruby>”。</p><h3 id="尺寸类别"><a href="#尺寸类别" class="headerlink" title="尺寸类别"></a>尺寸类别</h3><p>在解释什么是 “<ruby>尺寸类别 <rt>size class</rt></ruby>” 之前，我们先考虑个问题，理论上的 Go 语言在运行时是如何在其堆上分配 24 字节的。有一个简单的方法：追踪目前为止已分配到的所有内存的动向——利用指向堆上最后分配的字节的指针。分配 24 字节，堆指针就会增加 24，然后将前一个值返回给调用函数。只要写入的请求 24 字节的代码不超出该标记的范围，这种机制就没有额外开销。不过，现实情况下，内存分配器不仅要分配内存，有时还得释放内存。</p><p>最终，Go 语言程序在运行时将释放这些 24 字节，但从运行的视角来看，它只知道它给调用者的开始地址。它不知道从该地址起始之后又分配了多少字节。为了允许释放内存，我们假设的 Go 语言程序运行时分配器必须记录堆上每个分配的长度值。那么这些长度值的分配存储在何处？当然是在堆上。</p><p>在我们的设想中，当程序运行需要分配内存的时候，它可以请求稍微多一点，并把它用来存储请求的数量。而对于我们的切片示例而言，当我们请求 24 字节时，实际上会消耗 24 字节加上存储数字 <code>24</code> 的一些开销。这些开销有多大？事实上，实际上的最小开销量是一个字。<sup class="footnote-ref"> <a href="#fn5" id="fnref5">[5]</a></sup></p><p>用来记录 24 字节分配的开销将是 8 字节。25% 不是很大，但也不算糟糕，随着分配的大小增加，开销将变得微不足道。然而，如果我们只想在堆上存储一个字节，会发生什么？开销将是请求数据量的 8 倍！是否有一种更高效的方式在堆上分配少量内存？</p><p>与其在每个分配旁边存储长度，不如将相同大小的内容存储在一起，这个主意如何？如果所有的 24 字节的内容都存储在一起，那么运行时会自动获取它们的大小。运行时所需要的是一个单一的位，指示 24 字节区域是否在使用中。在 Go 语言中，这些区域被称为 Size Classes，因为相同大小的所有内容都会存储在一起（类似学校班级，所有学生都按同一年级分班，而不是 C++ 中的类）。当运行时需要分配少量内存时，它会使用能够容纳该分配的最小的尺寸类别。</p><h3 id="无限制的尺寸类别"><a href="#无限制的尺寸类别" class="headerlink" title="无限制的尺寸类别"></a>无限制的尺寸类别</h3><p>现在我们知道尺寸类别是如何工作的了，那么问题又来了，它们存储在哪里？和我们想的一样，尺寸类别的内存来自堆。为了最小化开销，运行时会从堆上分配较大的内存块（通常是系统页面大小的倍数），然后将该空间用于单个大小的分配。不过，这里存在一个问题————</p><p>将大块区域用于存储同一大小的事物的模式很好用 <sup class="footnote-ref"><a href="#fn6" id="fnref6">[6] </a></sup>，如果分配大小的数量是固定的，最好是少数几个。那么在通用语言中，程序可以要求运行时以任何大小分配内存<sup class="footnote-ref"> <a href="#fn7" id="fnref7">[7] </a></sup>。</p><p>例如，想象一下向运行时请求 9 字节。9 字节是一个不常见的大小，因此可能需要一个新的尺寸类别来存储 9 字节大小的物品。因为 9 字节大小的物品不常见，所以分配的其余部分（通常为 4KB 或更多）可能会被浪费。由于尺寸类别的集合是固定的，如果没有精确匹配的 size class 可用，分配将并入到下一个尺寸类别。在我们的示例中，9 字节可能会在 12 字节的尺寸类别中分配。未使用的 3 字节的开销要比几乎未使用的整个尺寸类别分配好。</p><h3 id="总结一下"><a href="#总结一下" class="headerlink" title="总结一下"></a>总结一下</h3><p>这是谜题的最后一块拼图。Go 1.15 版本没有 24 字节的尺寸类别，因此 <code>ss</code> 的堆分配是在 32 字节的尺寸类别中分配的。由于 Martin Möhrmann 的工作，Go 1.16 版本有一个 24 字节的尺寸类别，非常适合分配给接口的切片值。</p><h3 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h3><ol><li><a target="_blank" rel="noopener" href="https://dave.cheney.net/2017/08/23/im-talking-about-go-at-devfest-siberia-2017">我在 Devfest 2017年西伯利亚大会谈 Go 语言</a></li><li><a target="_blank" rel="noopener" href="https://dave.cheney.net/2018/01/06/if-aligned-memory-writes-are-atomic-why-do-we-need-the-sync-atomic-package">如果对齐的内存写操作是原子性的，为什么我们还需要 sync&#x2F;atomic 包呢？</a></li><li><a target="_blank" rel="noopener" href="https://dave.cheney.net/2014/01/05/a-real-serial-console-for-your-raspberry-pi">为你的树莓派创建一个真实的串行控制台</a></li><li><a target="_blank" rel="noopener" href="https://dave.cheney.net/2013/06/02/why-is-a-goroutines-stack-infinite">为什么 Go 语言线程的栈是无限制的？</a></li></ol><p><em>（题图：MJ&#x2F;01d5fe46-778f-48fe-9481-162f4d0289dc）</em></p><hr><ol><li>这不是正确的对排序函数进行基准测试的方式，因为在第一次迭代之后，输入已经排序。但这又是另外一个话题了。 <a href="#fnref1">↩︎</a></li><li>此语句的准确性取决于所使用的 Go 版本。例如，Go 1.15 版本添加了直接将一些 <a target="_blank" rel="noopener" href="https://golang.org/doc/go1.15#runtime">整数存储在接口值</a> 中的功能，从而节省了分配和间接性。然而，对于大多数值来说，如果它不是指针类型，它的地址将被取出并存储在接口值中。 <a href="#fnref2">↩︎</a></li><li>编译器在接口值的类型字段中跟踪了这种手法，因此它记住了分配给 <code>si</code> 的类型是 <code>sort.StringSlice</code> 而不是 <code>*sort.StringSlice</code>。 <a href="#fnref3">↩︎</a></li><li>在 32 位平台上，这个数字减半，<a target="_blank" rel="noopener" href="https://www.tallengestore.com/products/i-never-look-back-darling-it-distracts-from-the-now-edna-mode-inspirational-quote-tallenge-motivational-poster-collection-large-art-prints">但我们不再关注它</a>。 <a href="#fnref4">↩︎</a></li><li>如果你准备限制分配为 4G 或者可能是 64KB，你可以使用较少内存来存储分配的尺寸，但实际上使用小于一个字来存储长度标头的节省会受到填充的影响。 <a href="#fnref5">↩︎</a></li><li>将相同大小的物品存储在一起也是一种有效的对抗碎片化的策略。 <a href="#fnref6">↩︎</a></li><li>这并不是一个不切实际的设想，字符串有各种形状和大小，生成以前未见过的大小的字符串可能就像附加空格一样简单。 <a href="#fnref7">↩︎</a></li></ol><hr><p>via: <a target="_blank" rel="noopener" href="https://dave.cheney.net/2021/01/05/a-few-bytes-here-a-few-there-pretty-soon-youre-talking-real-memory">https://dave.cheney.net/2021/01/05/a-few-bytes-here-a-few-there-pretty-soon-youre-talking-real-memory</a></p><p>作者：<a target="_blank" rel="noopener" href="https://dave.cheney.net/">Dave Cheney</a> 选题：<a target="_blank" rel="noopener" href="https://github.com/lujun9972">lujun9972</a> 译者：<a target="_blank" rel="noopener" href="https://github.com/Drwhooooo">Drwhooooo</a> 校对：<a target="_blank" rel="noopener" href="https://github.com/wxy">wxy</a></p><p>本文由 <a target="_blank" rel="noopener" href="https://github.com/LCTT/TranslateProject">LCTT</a> 原创编译，<a target="_blank" rel="noopener" href="https://linux.cn/">Linux中国</a> 荣誉推出</p></div></div></div><div class="footer"><p class="footer-copyright"><span>Powered by <a target="_blank" href="https://hexo.io">Hexo</a></span> <span>Theme <a target="_blank" href="https://github.com/tinkink-co/hexo-theme-terminal">Terminal</a></span><script type="text/javascript" src="https://cdn.staticfile.net/jquery/3.4.1/jquery.min.js"></script><script>getCDNinfo=function(){$.ajax({url:"/cdn-cgi/trace",success:function(a,n){let i="Antananarivo, Madagascar - (TNR);Cape Town, South Africa - (CPT);Casablanca, Morocco - (CMN);Dar Es Salaam, Tanzania - (DAR);Djibouti City, Djibouti - (JIB);Durban, South Africa - (DUR);Johannesburg, South Africa - (JNB);Kigali, Rwanda - (KGL);Lagos, Nigeria - (LOS);Luanda, Angola - (LAD);Maputo, MZ - (MPM);Mombasa, Kenya - (MBA);Port Louis, Mauritius - (MRU);Réunion, France - (RUN);Bangalore, India - (BLR);Bangkok, Thailand - (BKK);Bandar Seri Begawan, Brunei - (BWN);Cebu, Philippines - (CEB);Chengdu, China - (CTU);Chennai, India - (MAA);Chittagong, Bangladesh - (CGP);Chongqing, China - (CKG);Colombo, Sri Lanka - (CMB);Dhaka, Bangladesh - (DAC);Dongguan, China - (SZX);Foshan, China - (FUO);Fuzhou, China - (FOC);Guangzhou, China - (CAN);Hangzhou, China - (HGH);Hanoi, Vietnam - (HAN);Hengyang, China - (HNY);Ho Chi Minh City, Vietnam - (SGN);Hong Kong - (HKG);Hyderabad, India - (HYD);Islamabad, Pakistan - (ISB);Jakarta, Indonesia - (CGK);Jinan, China - (TNA);Karachi, Pakistan - (KHI);Kathmandu, Nepal - (KTM);Kolkata, India - (CCU);Kuala Lumpur, Malaysia - (KUL);Lahore, Pakistan - (LHE);Langfang, China - (NAY);Luoyang, China - (LYA);Macau - (MFM);Malé, Maldives - (MLE);Manila, Philippines - (MNL);Mumbai, India - (BOM);Nagpur, India - (NAG);Nanning, China - (NNG);New Delhi, India - (DEL);Osaka, Japan - (KIX);Phnom Penh, Cambodia - (PNH);Qingdao, China - (TAO);Seoul, South Korea - (ICN);Shanghai, China - (SHA);Shenyang, China - (SHE);Shijiazhuang, China - (SJW);Singapore, Singapore - (SIN);Suzhou, China - (SZV);Taipei - (TPE);Thimphu, Bhutan - (PBH);Tianjin, China - (TSN);Tokyo, Japan - (NRT);Ulaanbaatar, Mongolia - (ULN);Vientiane, Laos - (VTE);Wuhan, China - (WUH);Wuxi, China - (WUX);Xi'an, China - (XIY);Yerevan, Armenia - (EVN);Zhengzhou, China - (CGO);Zuzhou, China - (CSX);Amsterdam, Netherlands - (AMS);Athens, Greece - (ATH);Barcelona, Spain - (BCN);Belgrade, Serbia - (BEG);Berlin, Germany - (TXL);Brussels, Belgium - (BRU);Bucharest, Romania - (OTP);Budapest, Hungary - (BUD);Chișinău, Moldova - (KIV);Copenhagen, Denmark - (CPH);Cork, Ireland -  (ORK);Dublin, Ireland - (DUB);Düsseldorf, Germany - (DUS);Edinburgh, United Kingdom - (EDI);Frankfurt, Germany - (FRA);Geneva, Switzerland - (GVA);Gothenburg, Sweden - (GOT);Hamburg, Germany - (HAM);Helsinki, Finland - (HEL);Istanbul, Turkey - (IST);Kyiv, Ukraine - (KBP);Lisbon, Portugal - (LIS);London, United Kingdom - (LHR);Luxembourg City, Luxembourg - (LUX);Madrid, Spain - (MAD);Manchester, United Kingdom - (MAN);Marseille, France - (MRS);Milan, Italy - (MXP);Moscow, Russia - (DME);Munich, Germany - (MUC);Nicosia, Cyprus - (LCA);Oslo, Norway - (OSL);Paris, France - (CDG);Prague, Czech Republic - (PRG);Reykjavík, Iceland - (KEF);Riga, Latvia - (RIX);Rome, Italy - (FCO);Saint Petersburg, Russia - (LED);Sofia, Bulgaria - (SOF);Stockholm, Sweden - (ARN);Tallinn, Estonia - (TLL);Thessaloniki, Greece - (SKG);Vienna, Austria - (VIE);Vilnius, Lithuania - (VNO);Warsaw, Poland - (WAW);Zagreb, Croatia - (ZAG);Zürich, Switzerland - (ZRH);Arica, Chile - (ARI);Asunción, Paraguay - (ASU);Bogotá, Colombia - (BOG);Buenos Aires, Argentina - (EZE);Curitiba, Brazil - (CWB);Fortaleza, Brazil - (FOR);Guatemala City, Guatemala - (GUA);Lima, Peru - (LIM);Medellín, Colombia - (MDE);Panama City, Panama - (PTY);Porto Alegre, Brazil - (POA);Quito, Ecuador - (UIO);Rio de Janeiro, Brazil - (GIG);São Paulo, Brazil - (GRU);Santiago, Chile - (SCL);Willemstad, Curaçao - (CUR);St. George's, Grenada - (GND);Amman, Jordan - (AMM);Baghdad, Iraq - (BGW);Baku, Azerbaijan - (GYD);Beirut, Lebanon - (BEY);Doha, Qatar - (DOH);Dubai, United Arab Emirates - (DXB);Kuwait City, Kuwait - (KWI);Manama, Bahrain - (BAH);Muscat, Oman - (MCT);Ramallah - (ZDM);Riyadh, Saudi Arabia - (RUH);Tel Aviv, Israel - (TLV);Ashburn, VA, United States - (IAD);Atlanta, GA, United States - (ATL);Boston, MA, United States - (BOS);Buffalo, NY, United States - (BUF);Calgary, AB, Canada - (YYC);Charlotte, NC, United States - (CLT);Chicago, IL, United States - (ORD);Columbus, OH, United States - (CMH);Dallas, TX, United States - (DFW);Denver, CO, United States - (DEN);Detroit, MI, United States - (DTW);Honolulu, HI, United States - (HNL);Houston, TX, United States - (IAH);Indianapolis, IN, United States - (IND);Jacksonville, FL, United States - (JAX);Kansas City, MO, United States - (MCI);Las Vegas, NV, United States - (LAS);Los Angeles, CA, United States - (LAX);McAllen, TX, United States - (MFE);Memphis, TN, United States - (MEM);Mexico City, Mexico - (MEX);Miami, FL, United States - (MIA);Minneapolis, MN, United States - (MSP);Montgomery, AL, United States - (MGM);Montréal, QC, Canada - (YUL);Nashville, TN, United States - (BNA);Newark, NJ, United States - (EWR);Norfolk, VA, United States - (ORF);Omaha, NE, United States - (OMA);Philadelphia, United States - (PHL);Phoenix, AZ, United States - (PHX);Pittsburgh, PA, United States - (PIT);Port-Au-Prince, Haiti - (PAP);Portland, OR, United States - (PDX);Queretaro, MX, Mexico - (QRO);Richmond, Virginia - (RIC);Sacramento, CA, United States - (SMF);Salt Lake City, UT, United States - (SLC);San Diego, CA, United States - (SAN);San Jose, CA, United States - (SJC);Saskatoon, SK, Canada - (YXE);Seattle, WA, United States - (SEA);St. Louis, MO, United States - (STL);Tampa, FL, United States - (TPA);Toronto, ON, Canada - (YYZ);Vancouver, BC, Canada - (YVR);Tallahassee, FL, United States - (TLH);Winnipeg, MB, Canada - (YWG);Adelaide, SA, Australia - (ADL);Auckland, New Zealand - (AKL);Brisbane, QLD, Australia - (BNE);Melbourne, VIC, Australia - (MEL);Noumea, New caledonia - (NOU);Perth, WA, Australia - (PER);Sydney, NSW, Australia - (SYD)".split(";"),e=a.split("colo=")[1].split("\n")[0],t=(a.split("colo=")[1].split("\n")[0],a.split("tls=")[1].split("\n")[0]),o=a.split("http=")[1].split("\n")[0],s=a.split("sni=")[1].split("\n")[0],r=a.split("ip=")[1].split("\n")[0],l=a.split("uag=")[1].split("\n")[0];for(var d=0;d<i.length;d++)if(-1!=i[d].indexOf(e)){document.getElementById("cdn").innerHTML=i[d];break}document.getElementById("tls").innerHTML=t,document.getElementById("http").innerHTML=o,document.getElementById("sni").innerHTML=s,document.getElementById("ip").innerHTML=r,document.getElementById("useragent").innerHTML=l}})},$(document).ready((function(){getCDNinfo()}))</script></p><p style="text-align:center">感谢陪伴与布道，开源之火不灭。​</p><p style="text-align:center"><script>document.write("本次加载耗时: "+(performance.getEntriesByType("navigation").reduce((e,r)=>e+r.responseEnd-r.startTime,0)+performance.getEntriesByType("resource").reduce((e,r)=>e+r.responseEnd-r.startTime,0)).toFixed(0)+"ms")</script></p><p style="text-align:center">当前 SNI 状态： <span id="sni">正在统计！或可能被浏览器防追踪拦截！</span></p><p style="text-align:center">当前 TLS 版本： <span id="tls">正在统计！或可能被浏览器防追踪拦截！</span></p><p style="text-align:center">当前 HTTP 版本： <span id="http">正在统计！或可能被浏览器防追踪拦截！</span></p><p style="text-align:center">当前您的客户端 IP 是： <span id="ip">正在统计！或可能被浏览器防追踪拦截！</span></p><p style="text-align:center">当前分配的 CDN 节点是: <span id="cdn">正在统计！或可能被浏览器防追踪拦截！</span></p><p style="text-align:center">您的 UserAgent 信息是: <span id="useragent">正在统计！或可能被浏览器防追踪拦截！</span></p><p></p><script defer src="https://pv.undefined.today/tracker.min.js" data-website-id="LinuxCNMirror-tracker"></script></div></div></body></html>