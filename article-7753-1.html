<!doctype html><html lang="en"><head><meta name="msvalidate.01" content="D404690CEFCB54C7762AC84935B99171"><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?6618da70c90c8744eead2e9371fb5077";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><script type="text/javascript">!function(t,e,n,c,s,a,r){t[n]=t[n]||function(){(t[n].q=t[n].q||[]).push(arguments)},(a=e.createElement(c)).async=1,a.src="https://www.clarity.ms/tag/s5f3f0tojf",(r=e.getElementsByTagName(c)[0]).parentNode.insertBefore(a,r)}(window,document,"clarity","script")</script><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta http-equiv="X-UA-Compatible" content="ie=edge"><link rel="stylesheet" href="/styles/base.css"><link rel="stylesheet" href="/styles/theme.css"><link rel="shortcut icon" href="/favicon.png"><title>用 Python 实现 Python 解释器 - 归墟星火集 又一个 LinuxCN 站点</title><meta name="generator" content="Hexo 7.3.0"></head><body><div class="header-title"><span class="header-light"></span> <span class="header-light"></span> <span class="header-light"></span> <span>归墟星火集 又一个 LinuxCN 站点 linuxcn.undefined.today<span></span></span></div><div class="container"><ul class="nav"><li><a href="/">首页</a></li><li><a target="_blank" rel="noopener" href="https://undefined.today/">Blog</a></li></ul><div class="content"><div class="post-container"><div class="post-header"><span class="ui-tips">标题：</span><h1 class="ui-keyword post-title">用 Python 实现 Python 解释器</h1><span class="post-date">2016-09-08</span></div><div class="post-header"><span class="ui-tips">分类：</span> <a href="/categories/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/">软件开发</a></div><div class="post-header"><span class="ui-tips">标签：</span> <a href="/tags/Python/">Python</a> <a href="/tags/%E8%A7%A3%E9%87%8A%E5%99%A8/">解释器</a></div><div class="post-content"><p><em>Allison 是 Dropbox 的工程师，在那里她维护着这个世界上最大的 Python 客户端网络之一。在去 Dropbox 之前，她是 Recurse Center 的协调人, 是这个位于纽约的程序员深造机构的作者。她在北美的 PyCon 做过关于 Python 内部机制的演讲，并且她喜欢研究奇怪的 bug。她的博客地址是 <a target="_blank" rel="noopener" href="http://akaptur.com/">akaptur.com</a>。</em></p><p><em><img src="https://linuxcn.img.undefined.today/data/attachment/album/201609/08/141608t7xxxasobisyzxm0.jpg"></em></p><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>Byterun 是一个用 Python 实现的 Python 解释器。随着我对 Byterun 的开发，我惊喜地的发现，这个 Python 解释器的基础结构用 500 行代码就能实现。在这一章我们会搞清楚这个解释器的结构，给你足够探索下去的背景知识。我们的目标不是向你展示解释器的每个细节—像编程和计算机科学其他有趣的领域一样，你可能会投入几年的时间去深入了解这个主题。</p><p>Byterun 是 Ned Batchelder 和我完成的，建立在 Paul Swartz 的工作之上。它的结构和主要的 Python 实现（CPython）差不多，所以理解 Byterun 会帮助你理解大多数解释器，特别是 CPython 解释器。（如果你不知道你用的是什么 Python，那么很可能它就是 CPython）。尽管 Byterun 很小，但它能执行大多数简单的 Python 程序（这一章是基于 Python 3.5 及其之前版本生成的字节码的，在 Python 3.6 中生成的字节码有一些改变）。</p><h4 id="Python-解释器"><a href="#Python-解释器" class="headerlink" title="Python 解释器"></a>Python 解释器</h4><p>在开始之前，让我们限定一下“Pyhton 解释器”的意思。在讨论 Python 的时候，“解释器”这个词可以用在很多不同的地方。有的时候解释器指的是 Python REPL，即当你在命令行下敲下 <code>python</code> 时所得到的交互式环境。有时候人们会或多或少的互换使用 “Python 解释器”和“Python”来说明从头到尾执行 Python 代码的这一过程。在本章中，“解释器”有一个更精确的意思：Python 程序的执行过程中的最后一步。</p><p>在解释器接手之前，Python 会执行其他 3 个步骤：词法分析，语法解析和编译。这三步合起来把源代码转换成<ruby>代码对象 <rp>（ </rp><rt>code object</rt> <rp>）</rp></ruby>，它包含着解释器可以理解的指令。而解释器的工作就是解释代码对象中的指令。</p><p>你可能很奇怪执行 Python 代码会有编译这一步。Python 通常被称为解释型语言，就像 Ruby，Perl 一样，它们和像 C，Rust 这样的编译型语言相对。然而，这个术语并不是它看起来的那样精确。大多数解释型语言包括 Python 在内，确实会有编译这一步。而 Python 被称为解释型的原因是相对于编译型语言，它在编译这一步的工作相对较少（解释器做相对多的工作）。在这章后面你会看到，Python 的编译器比 C 语言编译器需要更少的关于程序行为的信息。</p><h4 id="Python-的-Python-解释器"><a href="#Python-的-Python-解释器" class="headerlink" title="Python 的 Python 解释器"></a>Python 的 Python 解释器</h4><p>Byterun 是一个用 Python 写的 Python 解释器，这点可能让你感到奇怪，但没有比用 C 语言写 C 语言编译器更奇怪的了。（事实上，广泛使用的 gcc 编译器就是用 C 语言本身写的）你可以用几乎任何语言写一个 Python 解释器。</p><p>用 Python 写 Python 既有优点又有缺点。最大的缺点就是速度：用 Byterun 执行代码要比用 CPython 执行慢的多，CPython 解释器是用 C 语言实现的，并做了认真优化。然而 Byterun 是为了学习而设计的，所以速度对我们不重要。使用 Python 最大优势是我们可以<em>仅仅</em>实现解释器，而不用担心 Python 运行时部分，特别是对象系统。比如当 Byterun 需要创建一个类时，它就会回退到“真正”的 Python。另外一个优势是 Byterun 很容易理解，部分原因是它是用人们很容易理解的高级语言写的（Python ！）（另外我们不会对解释器做优化 —— 再一次，清晰和简单比速度更重要）</p><h3 id="构建一个解释器"><a href="#构建一个解释器" class="headerlink" title="构建一个解释器"></a>构建一个解释器</h3><p>在我们考察 Byterun 代码之前，我们需要从高层次对解释器结构有一些了解。Python 解释器是如何工作的？</p><p>Python 解释器是一个<ruby>虚拟机 <rp>（ </rp><rt>virtual machine</rt> <rp>）</rp></ruby>，是一个模拟真实计算机的软件。我们这个虚拟机是<ruby>栈机器 <rp>（ </rp><rt>stack machine</rt> <rp>）</rp></ruby>，它用几个栈来完成操作（与之相对的是<ruby>寄存器机器 <rp>（ </rp><rt>register machine</rt> <rp>）</rp></ruby>，它从特定的内存地址读写数据）。</p><p>Python 解释器是一个<ruby>字节码解释器 <rp>（ </rp><rt>bytecode interpreter</rt> <rp>）</rp></ruby>：它的输入是一些称作<ruby>字节码 <rp>（ </rp><rt>bytecode</rt> <rp>）</rp></ruby>的指令集。当你写 Python 代码时，词法分析器、语法解析器和编译器会生成<ruby>代码对象 <rp>（ </rp><rt>code object</rt> <rp>）</rp></ruby>让解释器去操作。每个代码对象都包含一个要被执行的指令集 —— 它就是字节码 —— 以及还有一些解释器需要的信息。字节码是 Python 代码的一个<ruby>中间层表示 <rp>（ </rp><rt>intermediate representation</rt> <rp>）</rp></ruby>：它以一种解释器可以理解的方式来表示源代码。这和汇编语言作为 C 语言和机器语言的中间表示很类似。</p><h4 id="微型解释器"><a href="#微型解释器" class="headerlink" title="微型解释器"></a>微型解释器</h4><p>为了让说明更具体，让我们从一个非常小的解释器开始。它只能计算两个数的和，只能理解三个指令。它执行的所有代码只是这三个指令的不同组合。下面就是这三个指令：</p><ul><li><code>LOAD_VALUE</code></li><li><code>ADD_TWO_VALUES</code></li><li><code>PRINT_ANSWER</code></li></ul><p>我们不关心词法、语法和编译，所以我们也不在乎这些指令集是如何产生的。你可以想象，当你写下 <code>7 + 5</code>，然后一个编译器为你生成那三个指令的组合。如果你有一个合适的编译器，你甚至可以用 Lisp 的语法来写，只要它能生成相同的指令。</p><p>假设</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">7 + 5</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>生成这样的指令集：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">what_to_execute = &#123;</span><br><span class="line">    &quot;instructions&quot;: [(&quot;LOAD_VALUE&quot;, 0),  # the first number</span><br><span class="line">                     (&quot;LOAD_VALUE&quot;, 1),  # the second number</span><br><span class="line">                     (&quot;ADD_TWO_VALUES&quot;, None),</span><br><span class="line">                     (&quot;PRINT_ANSWER&quot;, None)],</span><br><span class="line">    &quot;numbers&quot;: [7, 5] &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Python 解释器是一个<ruby>栈机器 <rp>（ </rp><rt>stack machine</rt> <rp>）</rp></ruby>，所以它必须通过操作栈来完成这个加法（见下图）。解释器先执行第一条指令，<code>LOAD_VALUE</code>，把第一个数压到栈中。接着它把第二个数也压到栈中。然后，第三条指令，<code>ADD_TWO_VALUES</code>，先把两个数从栈中弹出，加起来，再把结果压入栈中。最后一步，把结果弹出并输出。</p><p><img src="https://linuxcn.img.undefined.today/data/attachment/album/201609/08/141623rjyb9yjk8o8tyesc.png" alt="栈机器"></p><p><code>LOAD_VALUE</code>这条指令告诉解释器把一个数压入栈中，但指令本身并没有指明这个数是多少。指令需要一个额外的信息告诉解释器去哪里找到这个数。所以我们的指令集有两个部分：指令本身和一个常量列表。（在 Python 中，字节码就是我们所称的“指令”，而解释器“执行”的是代码对象。）</p><p>为什么不把数字直接嵌入指令之中？想象一下，如果我们加的不是数字，而是字符串。我们可不想把字符串这样的东西加到指令中，因为它可以有任意的长度。另外，我们这种设计也意味着我们只需要对象的一份拷贝，比如这个加法 <code>7 + 7</code>, 现在常量表 <code>&quot;numbers&quot;</code>只需包含一个<code>[7]</code>。</p><p>你可能会想为什么会需要除了<code>ADD_TWO_VALUES</code>之外的指令。的确，对于我们两个数加法，这个例子是有点人为制作的意思。然而，这个指令却是建造更复杂程序的轮子。比如，就我们目前定义的三个指令，只要给出正确的指令组合，我们可以做三个数的加法，或者任意个数的加法。同时，栈提供了一个清晰的方法去跟踪解释器的状态，这为我们增长的复杂性提供了支持。</p><p>现在让我们来完成我们的解释器。解释器对象需要一个栈，它可以用一个列表来表示。它还需要一个方法来描述怎样执行每条指令。比如，<code>LOAD_VALUE</code>会把一个值压入栈中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Interpreter:</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.stack = []</span><br><span class="line"></span><br><span class="line">    def LOAD_VALUE(self, number):</span><br><span class="line">        self.stack.append(number)</span><br><span class="line"></span><br><span class="line">    def PRINT_ANSWER(self):</span><br><span class="line">        answer = self.stack.pop()</span><br><span class="line">        print(answer)</span><br><span class="line"></span><br><span class="line">    def ADD_TWO_VALUES(self):</span><br><span class="line">        first_num = self.stack.pop()</span><br><span class="line">        second_num = self.stack.pop()</span><br><span class="line">        total = first_num + second_num</span><br><span class="line">        self.stack.append(total)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这三个方法完成了解释器所理解的三条指令。但解释器还需要一样东西：一个能把所有东西结合在一起并执行的方法。这个方法就叫做 <code>run_code</code>，它把我们前面定义的字典结构 <code>what-to-execute</code> 作为参数，循环执行里面的每条指令，如果指令有参数就处理参数，然后调用解释器对象中相应的方法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">def run_code(self, what_to_execute):</span><br><span class="line">    instructions = what_to_execute[&quot;instructions&quot;]</span><br><span class="line">    numbers = what_to_execute[&quot;numbers&quot;]</span><br><span class="line">    for each_step in instructions:</span><br><span class="line">        instruction, argument = each_step</span><br><span class="line">        if instruction == &quot;LOAD_VALUE&quot;:</span><br><span class="line">            number = numbers[argument]</span><br><span class="line">            self.LOAD_VALUE(number)</span><br><span class="line">        elif instruction == &quot;ADD_TWO_VALUES&quot;:</span><br><span class="line">            self.ADD_TWO_VALUES()</span><br><span class="line">        elif instruction == &quot;PRINT_ANSWER&quot;:</span><br><span class="line">            self.PRINT_ANSWER()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>为了测试，我们创建一个解释器对象，然后用前面定义的 7 + 5 的指令集来调用 <code>run_code</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">interpreter = Interpreter()</span><br><span class="line">interpreter.run_code(what_to_execute)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>显然，它会输出 12。</p><p>尽管我们的解释器功能十分受限，但这个过程几乎和真正的 Python 解释器处理加法是一样的。这里，我们还有几点要注意。</p><p>首先，一些指令需要参数。在真正的 Python 字节码当中，大概有一半的指令有参数。像我们的例子一样，参数和指令打包在一起。注意指令的参数和传递给对应方法的参数是不同的。</p><p>第二，指令<code>ADD_TWO_VALUES</code>不需要任何参数，它从解释器栈中弹出所需的值。这正是以基于栈的解释器的特点。</p><p>记得我们说过只要给出合适的指令集，不需要对解释器做任何改变，我们就能做多个数的加法。考虑下面的指令集，你觉得会发生什么？如果你有一个合适的编译器，什么代码才能编译出下面的指令集？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">what_to_execute = &#123;</span><br><span class="line">    &quot;instructions&quot;: [(&quot;LOAD_VALUE&quot;, 0),</span><br><span class="line">                     (&quot;LOAD_VALUE&quot;, 1),</span><br><span class="line">                     (&quot;ADD_TWO_VALUES&quot;, None),</span><br><span class="line">                     (&quot;LOAD_VALUE&quot;, 2),</span><br><span class="line">                     (&quot;ADD_TWO_VALUES&quot;, None),</span><br><span class="line">                     (&quot;PRINT_ANSWER&quot;, None)],</span><br><span class="line">    &quot;numbers&quot;: [7, 5, 8] &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>从这点出发，我们开始看到这种结构的可扩展性：我们可以通过向解释器对象增加方法来描述更多的操作（只要有一个编译器能为我们生成组织良好的指令集就行）。</p><h5 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h5><p>接下来给我们的解释器增加变量的支持。我们需要一个保存变量值的指令 <code>STORE_NAME</code>；一个取变量值的指令<code>LOAD_NAME</code>；和一个变量到值的映射关系。目前，我们会忽略命名空间和作用域，所以我们可以把变量和值的映射直接存储在解释器对象中。最后，我们要保证<code>what_to_execute</code>除了一个常量列表，还要有个变量名字的列表。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def s():</span><br><span class="line">...     a = 1</span><br><span class="line">...     b = 2</span><br><span class="line">...     print(a + b)</span><br><span class="line"># a friendly compiler transforms `s` into:</span><br><span class="line">    what_to_execute = &#123;</span><br><span class="line">        &quot;instructions&quot;: [(&quot;LOAD_VALUE&quot;, 0),</span><br><span class="line">                         (&quot;STORE_NAME&quot;, 0),</span><br><span class="line">                         (&quot;LOAD_VALUE&quot;, 1),</span><br><span class="line">                         (&quot;STORE_NAME&quot;, 1),</span><br><span class="line">                         (&quot;LOAD_NAME&quot;, 0),</span><br><span class="line">                         (&quot;LOAD_NAME&quot;, 1),</span><br><span class="line">                         (&quot;ADD_TWO_VALUES&quot;, None),</span><br><span class="line">                         (&quot;PRINT_ANSWER&quot;, None)],</span><br><span class="line">        &quot;numbers&quot;: [1, 2],</span><br><span class="line">        &quot;names&quot;:   [&quot;a&quot;, &quot;b&quot;] &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我们的新的实现在下面。为了跟踪哪个名字绑定到哪个值，我们在<code>__init__</code>方法中增加一个<code>environment</code>字典。我们也增加了<code>STORE_NAME</code>和<code>LOAD_NAME</code>方法，它们获得变量名，然后从<code>environment</code>字典中设置或取出这个变量值。</p><p>现在指令的参数就有两个不同的意思，它可能是<code>numbers</code>列表的索引，也可能是<code>names</code>列表的索引。解释器通过检查所执行的指令就能知道是那种参数。而我们打破这种逻辑 ，把指令和它所用何种参数的映射关系放在另一个单独的方法中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">class Interpreter:</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.stack = []</span><br><span class="line">        self.environment = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    def STORE_NAME(self, name):</span><br><span class="line">        val = self.stack.pop()</span><br><span class="line">        self.environment[name] = val</span><br><span class="line"></span><br><span class="line">    def LOAD_NAME(self, name):</span><br><span class="line">        val = self.environment[name]</span><br><span class="line">        self.stack.append(val)</span><br><span class="line"></span><br><span class="line">    def parse_argument(self, instruction, argument, what_to_execute):</span><br><span class="line">        &quot;&quot;&quot; Understand what the argument to each instruction means.&quot;&quot;&quot;</span><br><span class="line">        numbers = [&quot;LOAD_VALUE&quot;]</span><br><span class="line">        names = [&quot;LOAD_NAME&quot;, &quot;STORE_NAME&quot;]</span><br><span class="line"></span><br><span class="line">        if instruction in numbers:</span><br><span class="line">            argument = what_to_execute[&quot;numbers&quot;][argument]</span><br><span class="line">        elif instruction in names:</span><br><span class="line">            argument = what_to_execute[&quot;names&quot;][argument]</span><br><span class="line"></span><br><span class="line">        return argument</span><br><span class="line"></span><br><span class="line">    def run_code(self, what_to_execute):</span><br><span class="line">        instructions = what_to_execute[&quot;instructions&quot;]</span><br><span class="line">        for each_step in instructions:</span><br><span class="line">            instruction, argument = each_step</span><br><span class="line">            argument = self.parse_argument(instruction, argument, what_to_execute)</span><br><span class="line"></span><br><span class="line">            if instruction == &quot;LOAD_VALUE&quot;:</span><br><span class="line">                self.LOAD_VALUE(argument)</span><br><span class="line">            elif instruction == &quot;ADD_TWO_VALUES&quot;:</span><br><span class="line">                self.ADD_TWO_VALUES()</span><br><span class="line">            elif instruction == &quot;PRINT_ANSWER&quot;:</span><br><span class="line">                self.PRINT_ANSWER()</span><br><span class="line">            elif instruction == &quot;STORE_NAME&quot;:</span><br><span class="line">                self.STORE_NAME(argument)</span><br><span class="line">            elif instruction == &quot;LOAD_NAME&quot;:</span><br><span class="line">                self.LOAD_NAME(argument)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>仅仅五个指令，<code>run_code</code>这个方法已经开始变得冗长了。如果保持这种结构，那么每条指令都需要一个<code>if</code>分支。这里，我们要利用 Python 的动态方法查找。我们总会给一个称为<code>FOO</code>的指令定义一个名为<code>FOO</code>的方法，这样我们就可用 Python 的<code>getattr</code>函数在运行时动态查找方法，而不用这个大大的分支结构。<code>run_code</code>方法现在是这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">def execute(self, what_to_execute):</span><br><span class="line">    instructions = what_to_execute[&quot;instructions&quot;]</span><br><span class="line">    for each_step in instructions:</span><br><span class="line">        instruction, argument = each_step</span><br><span class="line">        argument = self.parse_argument(instruction, argument, what_to_execute)</span><br><span class="line">        bytecode_method = getattr(self, instruction)</span><br><span class="line">        if argument is None:</span><br><span class="line">            bytecode_method()</span><br><span class="line">        else:</span><br><span class="line">            bytecode_method(argument)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="真实的-Python-字节码"><a href="#真实的-Python-字节码" class="headerlink" title="真实的 Python 字节码"></a>真实的 Python 字节码</h3><p>现在，放弃我们的小指令集，去看看真正的 Python 字节码。字节码的结构和我们的小解释器的指令集差不多，除了字节码用一个字节而不是一个名字来代表这条指令。为了理解它的结构，我们将考察一个函数的字节码。考虑下面这个例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def cond():</span><br><span class="line">...     x = 3</span><br><span class="line">...     if x &lt; 5:</span><br><span class="line">...         return &#x27;yes&#x27;</span><br><span class="line">...     else:</span><br><span class="line">...         return &#x27;no&#x27;</span><br><span class="line">...</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Python 在运行时会暴露一大批内部信息，并且我们可以通过 REPL 直接访问这些信息。对于函数对象<code>cond</code>，<code>cond.__code__</code>是与其关联的代码对象，而<code>cond.__code__.co_code</code>就是它的字节码。当你写 Python 代码时，你永远也不会想直接使用这些属性，但是这可以让我们做出各种恶作剧，同时也可以看看内部机制。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; cond.__code__.co_code  # the bytecode as raw bytes</span><br><span class="line">b&#x27;d\x01\x00&#125;\x00\x00|\x00\x00d\x02\x00k\x00\x00r\x16\x00d\x03\x00Sd\x04\x00Sd\x00</span><br><span class="line">   \x00S&#x27;</span><br><span class="line">&gt;&gt;&gt; list(cond.__code__.co_code)  # the bytecode as numbers</span><br><span class="line">[100, 1, 0, 125, 0, 0, 124, 0, 0, 100, 2, 0, 107, 0, 0, 114, 22, 0, 100, 3, 0, 83, </span><br><span class="line"> 100, 4, 0, 83, 100, 0, 0, 83]</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>当我们直接输出这个字节码，它看起来完全无法理解 —— 唯一我们了解的是它是一串字节。很幸运，我们有一个很强大的工具可以用：Python 标准库中的<code>dis</code>模块。</p><p><code>dis</code>是一个字节码反汇编器。反汇编器以为机器而写的底层代码作为输入，比如汇编代码和字节码，然后以人类可读的方式输出。当我们运行<code>dis.dis</code>，它输出每个字节码的解释。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; dis.dis(cond)</span><br><span class="line">  2           0 LOAD_CONST               1 (3)</span><br><span class="line">              3 STORE_FAST               0 (x)</span><br><span class="line"></span><br><span class="line">  3           6 LOAD_FAST                0 (x)</span><br><span class="line">              9 LOAD_CONST               2 (5)</span><br><span class="line">             12 COMPARE_OP               0 (&lt;)</span><br><span class="line">             15 POP_JUMP_IF_FALSE       22</span><br><span class="line"></span><br><span class="line">  4          18 LOAD_CONST               3 (&#x27;yes&#x27;)</span><br><span class="line">             21 RETURN_VALUE</span><br><span class="line"></span><br><span class="line">  6     &gt;&gt;   22 LOAD_CONST               4 (&#x27;no&#x27;)</span><br><span class="line">             25 RETURN_VALUE</span><br><span class="line">             26 LOAD_CONST               0 (None)</span><br><span class="line">             29 RETURN_VALUE</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这些都是什么意思？让我们以第一条指令<code>LOAD_CONST</code>为例子。第一列的数字（<code>2</code>）表示对应源代码的行数。第二列的数字是字节码的索引，告诉我们指令<code>LOAD_CONST</code>在位置 0 。第三列是指令本身对应的人类可读的名字。如果第四列存在，它表示指令的参数。如果第五列存在，它是一个关于参数是什么的提示。</p><p>考虑这个字节码的前几个字节：[100, 1, 0, 125, 0, 0]。这 6 个字节表示两条带参数的指令。我们可以使用<code>dis.opname</code>，一个字节到可读字符串的映射，来找到指令 100 和指令 125 代表的是什么：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; dis.opname[100]</span><br><span class="line">&#x27;LOAD_CONST&#x27;</span><br><span class="line">&gt;&gt;&gt; dis.opname[125]</span><br><span class="line">&#x27;STORE_FAST&#x27;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>第二和第三个字节 —— 1 、0 ——是<code>LOAD_CONST</code>的参数，第五和第六个字节 —— 0、0 —— 是<code>STORE_FAST</code>的参数。就像我们前面的小例子，<code>LOAD_CONST</code>需要知道的到哪去找常量，<code>STORE_FAST</code>需要知道要存储的名字。（Python 的<code>LOAD_CONST</code>和我们小例子中的<code>LOAD_VALUE</code>一样，<code>LOAD_FAST</code>和<code>LOAD_NAME</code>一样）。所以这六个字节代表第一行源代码<code>x = 3</code> （为什么用两个字节表示指令的参数？如果 Python 使用一个字节，每个代码对象你只能有 256 个常量&#x2F;名字，而用两个字节，就增加到了 256 的平方，65536个）。</p><h4 id="条件语句与循环语句"><a href="#条件语句与循环语句" class="headerlink" title="条件语句与循环语句"></a>条件语句与循环语句</h4><p>到目前为止，我们的解释器只能一条接着一条的执行指令。这有个问题，我们经常会想多次执行某个指令，或者在特定的条件下跳过它们。为了可以写循环和分支结构，解释器必须能够在指令中跳转。在某种程度上，Python 在字节码中使用<code>GOTO</code>语句来处理循环和分支！让我们再看一个<code>cond</code>函数的反汇编结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; dis.dis(cond)</span><br><span class="line">  2           0 LOAD_CONST               1 (3)</span><br><span class="line">              3 STORE_FAST               0 (x)</span><br><span class="line"></span><br><span class="line">  3           6 LOAD_FAST                0 (x)</span><br><span class="line">              9 LOAD_CONST               2 (5)</span><br><span class="line">             12 COMPARE_OP               0 (&lt;)</span><br><span class="line">             15 POP_JUMP_IF_FALSE       22</span><br><span class="line"></span><br><span class="line">  4          18 LOAD_CONST               3 (&#x27;yes&#x27;)</span><br><span class="line">             21 RETURN_VALUE</span><br><span class="line"></span><br><span class="line">  6     &gt;&gt;   22 LOAD_CONST               4 (&#x27;no&#x27;)</span><br><span class="line">             25 RETURN_VALUE</span><br><span class="line">             26 LOAD_CONST               0 (None)</span><br><span class="line">             29 RETURN_VALUE</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>第三行的条件表达式<code>if x &lt; 5</code>被编译成四条指令：<code>LOAD_FAST</code>、 <code>LOAD_CONST</code>、 <code>COMPARE_OP</code>和 <code>POP_JUMP_IF_FALSE</code>。<code>x &lt; 5</code>对应加载<code>x</code>、加载 5、比较这两个值。指令<code>POP_JUMP_IF_FALSE</code>完成这个<code>if</code>语句。这条指令把栈顶的值弹出，如果值为真，什么都不发生。如果值为假，解释器会跳转到另一条指令。</p><p>这条将被加载的指令称为跳转目标，它作为指令<code>POP_JUMP</code>的参数。这里，跳转目标是 22，索引为 22 的指令是<code>LOAD_CONST</code>，对应源码的第 6 行。（<code>dis</code>用<code>&gt;&gt;</code>标记跳转目标。）如果<code>X &lt; 5</code>为假，解释器会忽略第四行（<code>return yes</code>），直接跳转到第6行（<code>return &quot;no&quot;</code>）。因此解释器通过跳转指令选择性的执行指令。</p><p>Python 的循环也依赖于跳转。在下面的字节码中，<code>while x &lt; 5</code>这一行产生了和<code>if x &lt; 10</code>几乎一样的字节码。在这两种情况下，解释器都是先执行比较，然后执行<code>POP_JUMP_IF_FALSE</code>来控制下一条执行哪个指令。第四行的最后一条字节码<code>JUMP_ABSOLUT</code>(循环体结束的地方），让解释器返回到循环开始的第 9 条指令处。当 <code>x &lt; 10</code>变为假，<code>POP_JUMP_IF_FALSE</code>会让解释器跳到循环的终止处，第 34 条指令。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def loop():</span><br><span class="line">...      x = 1</span><br><span class="line">...      while x &lt; 5:</span><br><span class="line">...          x = x + 1</span><br><span class="line">...      return x</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; dis.dis(loop)</span><br><span class="line">  2           0 LOAD_CONST               1 (1)</span><br><span class="line">              3 STORE_FAST               0 (x)</span><br><span class="line"></span><br><span class="line">  3           6 SETUP_LOOP              26 (to 35)</span><br><span class="line">        &gt;&gt;    9 LOAD_FAST                0 (x)</span><br><span class="line">             12 LOAD_CONST               2 (5)</span><br><span class="line">             15 COMPARE_OP               0 (&lt;)</span><br><span class="line">             18 POP_JUMP_IF_FALSE       34</span><br><span class="line"></span><br><span class="line">  4          21 LOAD_FAST                0 (x)</span><br><span class="line">             24 LOAD_CONST               1 (1)</span><br><span class="line">             27 BINARY_ADD</span><br><span class="line">             28 STORE_FAST               0 (x)</span><br><span class="line">             31 JUMP_ABSOLUTE            9</span><br><span class="line">        &gt;&gt;   34 POP_BLOCK</span><br><span class="line"></span><br><span class="line">  5     &gt;&gt;   35 LOAD_FAST                0 (x)</span><br><span class="line">             38 RETURN_VALUE</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="探索字节码"><a href="#探索字节码" class="headerlink" title="探索字节码"></a>探索字节码</h4><p>我希望你用<code>dis.dis</code>来试试你自己写的函数。一些有趣的问题值得探索：</p><ul><li>对解释器而言 for 循环和 while 循环有什么不同？</li><li>能不能写出两个不同函数，却能产生相同的字节码?</li><li><code>elif</code>是怎么工作的？列表推导呢？</li></ul><h3 id="帧"><a href="#帧" class="headerlink" title="帧"></a>帧</h3><p>到目前为止，我们已经知道了 Python 虚拟机是一个栈机器。它能顺序执行指令，在指令间跳转，压入或弹出栈值。但是这和我们期望的解释器还有一定距离。在前面的那个例子中，最后一条指令是<code>RETURN_VALUE</code>，它和<code>return</code>语句相对应。但是它返回到哪里去呢？</p><p>为了回答这个问题，我们必须再增加一层复杂性：<ruby>帧 <rp>（ </rp><rt>frame</rt> <rp>）</rp></ruby>。一个帧是一些信息的集合和代码的执行上下文。帧在 Python 代码执行时动态地创建和销毁。每个帧对应函数的一次调用 —— 所以每个帧只有一个代码对象与之关联，而一个代码对象可以有多个帧。比如你有一个函数递归的调用自己 10 次，这会产生 11 个帧，每次调用对应一个，再加上启动模块对应的一个帧。总的来说，Python 程序的每个作用域都有一个帧，比如，模块、函数、类定义。</p><p>帧存在于<ruby>调用栈 <rp>（ </rp><rt>call stack</rt> <rp>）</rp></ruby>中，一个和我们之前讨论的完全不同的栈。（你最熟悉的栈就是调用栈，就是你经常看到的异常回溯，每个以”File ‘program.py’”开始的回溯对应一个帧。）解释器在执行字节码时操作的栈，我们叫它<ruby>数据栈 <rp>（ </rp><rt>data stack</rt> <rp>）</rp></ruby>。其实还有第三个栈，叫做<ruby>块栈 <rp>（ </rp><rt>block stack</rt> <rp>）</rp></ruby>，用于特定的控制流块，比如循环和异常处理。调用栈中的每个帧都有它自己的数据栈和块栈。</p><p>让我们用一个具体的例子来说明一下。假设 Python 解释器执行到下面标记为 3 的地方。解释器正处于<code>foo</code>函数的调用中，它接着调用<code>bar</code>。下面是帧调用栈、块栈和数据栈的示意图。我们感兴趣的是解释器先从最底下的<code>foo()</code>开始，接着执行<code>foo</code>的函数体，然后到达<code>bar</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def bar(y):</span><br><span class="line">...     z = y + 3     # &lt;--- (3) ... and the interpreter is here.</span><br><span class="line">...     return z</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; def foo():</span><br><span class="line">...     a = 1</span><br><span class="line">...     b = 2</span><br><span class="line">...     return a + bar(b) # &lt;--- (2) ... which is returning a call to bar ...</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; foo()             # &lt;--- (1) We&#x27;re in the middle of a call to foo ...</span><br><span class="line">3</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://linuxcn.img.undefined.today/data/attachment/album/201609/08/141633dwztqktnwthtttto.png" alt="调用栈"></p><p>现在，解释器处于<code>bar</code>函数的调用中。调用栈中有 3 个帧：一个对应于模块层，一个对应函数<code>foo</code>，另一个对应函数<code>bar</code>。（见上图）一旦<code>bar</code>返回，与它对应的帧就会从调用栈中弹出并丢弃。</p><p>字节码指令<code>RETURN_VALUE</code>告诉解释器在帧之间传递一个值。首先，它把位于调用栈栈顶的帧中的数据栈的栈顶值弹出。然后把整个帧弹出丢弃。最后把这个值压到下一个帧的数据栈中。</p><p>当 Ned Batchelder 和我在写 Byterun 时，很长一段时间我们的实现中一直有个重大的错误。我们整个虚拟机中只有一个数据栈，而不是每个帧都有一个。我们写了很多测试代码，同时在 Byterun 和真正的 Python 上运行，希望得到一致结果。我们几乎通过了所有测试，只有一样东西不能通过，那就是<ruby>生成器 <rp>（ </rp><rt>generators</rt> <rp>）</rp></ruby>。最后，通过仔细的阅读 CPython 的源码，我们发现了错误所在（感谢 Michael Arntzenius 对这个 bug 的洞悉）。把数据栈移到每个帧就解决了这个问题。</p><p>回头在看看这个 bug，我惊讶的发现 Python 真的很少依赖于每个帧有一个数据栈这个特性。在 Python 中几乎所有的操作都会清空数据栈，所以所有的帧公用一个数据栈是没问题的。在上面的例子中，当<code>bar</code>执行完后，它的数据栈为空。即使<code>foo</code>公用这一个栈，它的值也不会受影响。然而，对应生成器，它的一个关键的特点是它能暂停一个帧的执行，返回到其他的帧，一段时间后它能返回到原来的帧，并以它离开时的相同状态继续执行。</p><h3 id="Byterun"><a href="#Byterun" class="headerlink" title="Byterun"></a>Byterun</h3><p>现在我们有足够的 Python 解释器的知识背景去考察 Byterun。</p><p>Byterun 中有四种对象。</p><ul><li><code>VirtualMachine</code>类，它管理高层结构，尤其是帧调用栈，并包含了指令到操作的映射。这是一个比前面<code>Inteprter</code>对象更复杂的版本。</li><li><code>Frame</code>类，每个<code>Frame</code>类都有一个代码对象，并且管理着其他一些必要的状态位，尤其是全局和局部命名空间、指向调用它的整的指针和最后执行的字节码指令。</li><li><code>Function</code>类，它被用来代替真正的 Python 函数。回想一下，调用函数时会创建一个新的帧。我们自己实现了<code>Function</code>，以便我们控制新的<code>Frame</code>的创建。</li><li><code>Block</code>类，它只是包装了块的 3 个属性。（块的细节不是解释器的核心，我们不会花时间在它身上，把它列在这里，是因为 Byterun 需要它。）</li></ul><h4 id="VirtualMachine-类"><a href="#VirtualMachine-类" class="headerlink" title="VirtualMachine 类"></a><code>VirtualMachine</code> 类</h4><p>每次程序运行时只会创建一个<code>VirtualMachine</code>实例，因为我们只有一个 Python 解释器。<code>VirtualMachine</code> 保存调用栈、异常状态、在帧之间传递的返回值。它的入口点是<code>run_code</code>方法，它以编译后的代码对象为参数，以创建一个帧为开始，然后运行这个帧。这个帧可能再创建出新的帧；调用栈随着程序的运行而增长和缩短。当第一个帧返回时，执行结束。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class VirtualMachineError(Exception):</span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line">class VirtualMachine(object):</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.frames = []   # The call stack of frames.</span><br><span class="line">        self.frame = None  # The current frame.</span><br><span class="line">        self.return_value = None</span><br><span class="line">        self.last_exception = None</span><br><span class="line"></span><br><span class="line">    def run_code(self, code, global_names=None, local_names=None):</span><br><span class="line">        &quot;&quot;&quot; An entry point to execute code using the virtual machine.&quot;&quot;&quot;</span><br><span class="line">        frame = self.make_frame(code, global_names=global_names, </span><br><span class="line">                                local_names=local_names)</span><br><span class="line">        self.run_frame(frame)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="Frame-类"><a href="#Frame-类" class="headerlink" title="Frame 类"></a><code>Frame</code> 类</h4><p>接下来，我们来写<code>Frame</code>对象。帧是一个属性的集合，它没有任何方法。前面提到过，这些属性包括由编译器生成的代码对象；局部、全局和内置命名空间；前一个帧的引用；一个数据栈；一个块栈；最后执行的指令指针。（对于内置命名空间我们需要多做一点工作，Python 在不同模块中对这个命名空间有不同的处理；但这个细节对我们的虚拟机不重要。）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Frame(object):</span><br><span class="line">    def __init__(self, code_obj, global_names, local_names, prev_frame):</span><br><span class="line">        self.code_obj = code_obj</span><br><span class="line">        self.global_names = global_names</span><br><span class="line">        self.local_names = local_names</span><br><span class="line">        self.prev_frame = prev_frame</span><br><span class="line">        self.stack = []</span><br><span class="line">        if prev_frame:</span><br><span class="line">            self.builtin_names = prev_frame.builtin_names</span><br><span class="line">        else:</span><br><span class="line">            self.builtin_names = local_names[&#x27;__builtins__&#x27;]</span><br><span class="line">            if hasattr(self.builtin_names, &#x27;__dict__&#x27;):</span><br><span class="line">                self.builtin_names = self.builtin_names.__dict__</span><br><span class="line"></span><br><span class="line">        self.last_instruction = 0</span><br><span class="line">        self.block_stack = []</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>接着，我们在虚拟机中增加对帧的操作。这有 3 个帮助函数：一个创建新的帧的方法（它负责为新的帧找到名字空间），和压栈和出栈的方法。第四个函数，<code>run_frame</code>，完成执行帧的主要工作，待会我们再讨论这个方法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">class VirtualMachine(object):</span><br><span class="line">    [... 删节 ...]</span><br><span class="line"></span><br><span class="line">    # Frame manipulation</span><br><span class="line">    def make_frame(self, code, callargs=&#123;&#125;, global_names=None, local_names=None):</span><br><span class="line">        if global_names is not None and local_names is not None:</span><br><span class="line">            local_names = global_names</span><br><span class="line">        elif self.frames:</span><br><span class="line">            global_names = self.frame.global_names</span><br><span class="line">            local_names = &#123;&#125;</span><br><span class="line">        else:</span><br><span class="line">            global_names = local_names = &#123;</span><br><span class="line">                &#x27;__builtins__&#x27;: __builtins__,</span><br><span class="line">                &#x27;__name__&#x27;: &#x27;__main__&#x27;,</span><br><span class="line">                &#x27;__doc__&#x27;: None,</span><br><span class="line">                &#x27;__package__&#x27;: None,</span><br><span class="line">            &#125;</span><br><span class="line">        local_names.update(callargs)</span><br><span class="line">        frame = Frame(code, global_names, local_names, self.frame)</span><br><span class="line">        return frame</span><br><span class="line"></span><br><span class="line">    def push_frame(self, frame):</span><br><span class="line">        self.frames.append(frame)</span><br><span class="line">        self.frame = frame</span><br><span class="line"></span><br><span class="line">    def pop_frame(self):</span><br><span class="line">        self.frames.pop()</span><br><span class="line">        if self.frames:</span><br><span class="line">            self.frame = self.frames[-1]</span><br><span class="line">        else:</span><br><span class="line">            self.frame = None</span><br><span class="line"></span><br><span class="line">    def run_frame(self):</span><br><span class="line">        pass</span><br><span class="line">        # we&#x27;ll come back to this shortly</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="Function-类"><a href="#Function-类" class="headerlink" title="Function 类"></a><code>Function</code> 类</h4><p><code>Function</code>的实现有点曲折，但是大部分的细节对理解解释器不重要。重要的是当调用函数时 —— 即调用 <code>__call__</code>方法 —— 它创建一个新的<code>Frame</code>并运行它。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">class Function(object):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    Create a realistic function object, defining the things the interpreter expects.</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    __slots__ = [</span><br><span class="line">        &#x27;func_code&#x27;, &#x27;func_name&#x27;, &#x27;func_defaults&#x27;, &#x27;func_globals&#x27;,</span><br><span class="line">        &#x27;func_locals&#x27;, &#x27;func_dict&#x27;, &#x27;func_closure&#x27;,</span><br><span class="line">        &#x27;__name__&#x27;, &#x27;__dict__&#x27;, &#x27;__doc__&#x27;,</span><br><span class="line">        &#x27;_vm&#x27;, &#x27;_func&#x27;,</span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line">    def __init__(self, name, code, globs, defaults, closure, vm):</span><br><span class="line">        &quot;&quot;&quot;You don&#x27;t need to follow this closely to understand the interpreter.&quot;&quot;&quot;</span><br><span class="line">        self._vm = vm</span><br><span class="line">        self.func_code = code</span><br><span class="line">        self.func_name = self.__name__ = name or code.co_name</span><br><span class="line">        self.func_defaults = tuple(defaults)</span><br><span class="line">        self.func_globals = globs</span><br><span class="line">        self.func_locals = self._vm.frame.f_locals</span><br><span class="line">        self.__dict__ = &#123;&#125;</span><br><span class="line">        self.func_closure = closure</span><br><span class="line">        self.__doc__ = code.co_consts[0] if code.co_consts else None</span><br><span class="line"></span><br><span class="line">        # Sometimes, we need a real Python function.  This is for that.</span><br><span class="line">        kw = &#123;</span><br><span class="line">            &#x27;argdefs&#x27;: self.func_defaults,</span><br><span class="line">        &#125;</span><br><span class="line">        if closure:</span><br><span class="line">            kw[&#x27;closure&#x27;] = tuple(make_cell(0) for _ in closure)</span><br><span class="line">        self._func = types.FunctionType(code, globs, **kw)</span><br><span class="line"></span><br><span class="line">    def __call__(self, *args, **kwargs):</span><br><span class="line">        &quot;&quot;&quot;When calling a Function, make a new frame and run it.&quot;&quot;&quot;</span><br><span class="line">        callargs = inspect.getcallargs(self._func, *args, **kwargs)</span><br><span class="line">        # Use callargs to provide a mapping of arguments: values to pass into the new </span><br><span class="line">        # frame.</span><br><span class="line">        frame = self._vm.make_frame(</span><br><span class="line">            self.func_code, callargs, self.func_globals, &#123;&#125;</span><br><span class="line">        )</span><br><span class="line">        return self._vm.run_frame(frame)</span><br><span class="line"></span><br><span class="line">def make_cell(value):</span><br><span class="line">    &quot;&quot;&quot;Create a real Python closure and grab a cell.&quot;&quot;&quot;</span><br><span class="line">    # Thanks to Alex Gaynor for help with this bit of twistiness.</span><br><span class="line">    fn = (lambda x: lambda: x)(value)</span><br><span class="line">    return fn.__closure__[0]</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>接着，回到<code>VirtualMachine</code>对象，我们对数据栈的操作也增加一些帮助方法。字节码操作的栈总是在当前帧的数据栈。这些帮助函数让我们的<code>POP_TOP</code>、<code>LOAD_FAST</code>以及其他操作栈的指令的实现可读性更高。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class VirtualMachine(object):</span><br><span class="line">    [... 删节 ...]</span><br><span class="line"></span><br><span class="line">    # Data stack manipulation</span><br><span class="line">    def top(self):</span><br><span class="line">        return self.frame.stack[-1]</span><br><span class="line"></span><br><span class="line">    def pop(self):</span><br><span class="line">        return self.frame.stack.pop()</span><br><span class="line"></span><br><span class="line">    def push(self, *vals):</span><br><span class="line">        self.frame.stack.extend(vals)</span><br><span class="line"></span><br><span class="line">    def popn(self, n):</span><br><span class="line">        &quot;&quot;&quot;Pop a number of values from the value stack.</span><br><span class="line">        A list of `n` values is returned, the deepest value first.</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        if n:</span><br><span class="line">            ret = self.frame.stack[-n:]</span><br><span class="line">            self.frame.stack[-n:] = []</span><br><span class="line">            return ret</span><br><span class="line">        else:</span><br><span class="line">            return []</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在我们运行帧之前，我们还需两个方法。</p><p>第一个方法，<code>parse_byte_and_args</code> 以一个字节码为输入，先检查它是否有参数，如果有，就解析它的参数。这个方法同时也更新帧的<code>last_instruction</code>属性，它指向最后执行的指令。一条没有参数的指令只有一个字节长度，而有参数的字节有3个字节长。参数的意义依赖于指令是什么。比如，前面说过，指令<code>POP_JUMP_IF_FALSE</code>，它的参数指的是跳转目标。<code>BUILD_LIST</code>，它的参数是列表的个数。<code>LOAD_CONST</code>，它的参数是常量的索引。</p><p>一些指令用简单的数字作为参数。对于另一些，虚拟机需要一点努力去发现它含意。标准库中的<code>dis</code>模块中有一个备忘单，它解释什么参数有什么意思，这让我们的代码更加简洁。比如，列表<code>dis.hasname</code>告诉我们<code>LOAD_NAME</code>、 <code>IMPORT_NAME</code>、<code>LOAD_GLOBAL</code>，以及另外的 9 个指令的参数都有同样的意义：对于这些指令，它们的参数代表了代码对象中的名字列表的索引。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">class VirtualMachine(object):</span><br><span class="line">    [... 删节 ...]</span><br><span class="line"></span><br><span class="line">    def parse_byte_and_args(self):</span><br><span class="line">        f = self.frame</span><br><span class="line">        opoffset = f.last_instruction</span><br><span class="line">        byteCode = f.code_obj.co_code[opoffset]</span><br><span class="line">        f.last_instruction += 1</span><br><span class="line">        byte_name = dis.opname[byteCode]</span><br><span class="line">        if byteCode &gt;= dis.HAVE_ARGUMENT:</span><br><span class="line">            # index into the bytecode</span><br><span class="line">            arg = f.code_obj.co_code[f.last_instruction:f.last_instruction+2]  </span><br><span class="line">            f.last_instruction += 2   # advance the instruction pointer</span><br><span class="line">            arg_val = arg[0] + (arg[1] * 256)</span><br><span class="line">            if byteCode in dis.hasconst:   # Look up a constant</span><br><span class="line">                arg = f.code_obj.co_consts[arg_val]</span><br><span class="line">            elif byteCode in dis.hasname:  # Look up a name</span><br><span class="line">                arg = f.code_obj.co_names[arg_val]</span><br><span class="line">            elif byteCode in dis.haslocal: # Look up a local name</span><br><span class="line">                arg = f.code_obj.co_varnames[arg_val]</span><br><span class="line">            elif byteCode in dis.hasjrel:  # Calculate a relative jump</span><br><span class="line">                arg = f.last_instruction + arg_val</span><br><span class="line">            else:</span><br><span class="line">                arg = arg_val</span><br><span class="line">            argument = [arg]</span><br><span class="line">        else:</span><br><span class="line">            argument = []</span><br><span class="line"></span><br><span class="line">        return byte_name, argument</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>下一个方法是<code>dispatch</code>，它查找给定的指令并执行相应的操作。在 CPython 中，这个分派函数用一个巨大的 switch 语句实现，有超过 1500 行的代码。幸运的是，我们用的是 Python，我们的代码会简洁的多。我们会为每一个字节码名字定义一个方法，然后用<code>getattr</code>来查找。就像我们前面的小解释器一样，如果一条指令叫做<code>FOO_BAR</code>，那么它对应的方法就是<code>byte_FOO_BAR</code>。现在，我们先把这些方法当做一个黑盒子。每个指令方法都会返回<code>None</code>或者一个字符串<code>why</code>,有些情况下虚拟机需要这个额外<code>why</code>信息。这些指令方法的返回值，仅作为解释器状态的内部指示，千万不要和执行帧的返回值相混淆。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">class VirtualMachine(object):</span><br><span class="line">    [... 删节 ...]</span><br><span class="line"></span><br><span class="line">    def dispatch(self, byte_name, argument):</span><br><span class="line">        &quot;&quot;&quot; Dispatch by bytename to the corresponding methods.</span><br><span class="line">        Exceptions are caught and set on the virtual machine.&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">        # When later unwinding the block stack,</span><br><span class="line">        # we need to keep track of why we are doing it.</span><br><span class="line">        why = None</span><br><span class="line">        try:</span><br><span class="line">            bytecode_fn = getattr(self, &#x27;byte_%s&#x27; % byte_name, None)</span><br><span class="line">            if bytecode_fn is None:</span><br><span class="line">                if byte_name.startswith(&#x27;UNARY_&#x27;):</span><br><span class="line">                    self.unaryOperator(byte_name[6:])</span><br><span class="line">                elif byte_name.startswith(&#x27;BINARY_&#x27;):</span><br><span class="line">                    self.binaryOperator(byte_name[7:])</span><br><span class="line">                else:</span><br><span class="line">                    raise VirtualMachineError(</span><br><span class="line">                        &quot;unsupported bytecode type: %s&quot; % byte_name</span><br><span class="line">                    )</span><br><span class="line">            else:</span><br><span class="line">                why = bytecode_fn(*argument)</span><br><span class="line">        except:</span><br><span class="line">            # deal with exceptions encountered while executing the op.</span><br><span class="line">            self.last_exception = sys.exc_info()[:2] + (None,)</span><br><span class="line">            why = &#x27;exception&#x27;</span><br><span class="line"></span><br><span class="line">        return why</span><br><span class="line"></span><br><span class="line">    def run_frame(self, frame):</span><br><span class="line">        &quot;&quot;&quot;Run a frame until it returns (somehow).</span><br><span class="line">        Exceptions are raised, the return value is returned.</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        self.push_frame(frame)</span><br><span class="line">        while True:</span><br><span class="line">            byte_name, arguments = self.parse_byte_and_args()</span><br><span class="line"></span><br><span class="line">            why = self.dispatch(byte_name, arguments)</span><br><span class="line"></span><br><span class="line">            # Deal with any block management we need to do</span><br><span class="line">            while why and frame.block_stack:</span><br><span class="line">                why = self.manage_block_stack(why)</span><br><span class="line"></span><br><span class="line">            if why:</span><br><span class="line">                break</span><br><span class="line"></span><br><span class="line">        self.pop_frame()</span><br><span class="line"></span><br><span class="line">        if why == &#x27;exception&#x27;:</span><br><span class="line">            exc, val, tb = self.last_exception</span><br><span class="line">            e = exc(val)</span><br><span class="line">            e.__traceback__ = tb</span><br><span class="line">            raise e</span><br><span class="line"></span><br><span class="line">        return self.return_value</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="Block-类"><a href="#Block-类" class="headerlink" title="Block 类"></a><code>Block</code> 类</h4><p>在我们完成每个字节码方法前，我们简单的讨论一下块。一个块被用于某种控制流，特别是异常处理和循环。它负责保证当操作完成后数据栈处于正确的状态。比如，在一个循环中，一个特殊的迭代器会存在栈中，当循环完成时它从栈中弹出。解释器需要检查循环仍在继续还是已经停止。</p><p>为了跟踪这些额外的信息，解释器设置了一个标志来指示它的状态。我们用一个变量<code>why</code>实现这个标志，它可以是<code>None</code>或者是下面几个字符串之一：<code>&quot;continue&quot;</code>、<code>&quot;break&quot;</code>、<code>&quot;excption&quot;</code>、<code>return</code>。它们指示对块栈和数据栈进行什么操作。回到我们迭代器的例子，如果块栈的栈顶是一个<code>loop</code>块，<code>why</code>的代码是<code>continue</code>，迭代器就应该保存在数据栈上，而如果<code>why</code>是<code>break</code>，迭代器就会被弹出。</p><p>块操作的细节比这个还要繁琐，我们不会花时间在这上面，但是有兴趣的读者值得仔细的看看。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">Block = collections.namedtuple(&quot;Block&quot;, &quot;type, handler, stack_height&quot;)</span><br><span class="line"></span><br><span class="line">class VirtualMachine(object):</span><br><span class="line">    [... 删节 ...]</span><br><span class="line"></span><br><span class="line">    # Block stack manipulation</span><br><span class="line">    def push_block(self, b_type, handler=None):</span><br><span class="line">        level = len(self.frame.stack)</span><br><span class="line">        self.frame.block_stack.append(Block(b_type, handler, stack_height))</span><br><span class="line"></span><br><span class="line">    def pop_block(self):</span><br><span class="line">        return self.frame.block_stack.pop()</span><br><span class="line"></span><br><span class="line">    def unwind_block(self, block):</span><br><span class="line">        &quot;&quot;&quot;Unwind the values on the data stack corresponding to a given block.&quot;&quot;&quot;</span><br><span class="line">        if block.type == &#x27;except-handler&#x27;:</span><br><span class="line">            # The exception itself is on the stack as type, value, and traceback.</span><br><span class="line">            offset = 3  </span><br><span class="line">        else:</span><br><span class="line">            offset = 0</span><br><span class="line"></span><br><span class="line">        while len(self.frame.stack) &gt; block.level + offset:</span><br><span class="line">            self.pop()</span><br><span class="line"></span><br><span class="line">        if block.type == &#x27;except-handler&#x27;:</span><br><span class="line">            traceback, value, exctype = self.popn(3)</span><br><span class="line">            self.last_exception = exctype, value, traceback</span><br><span class="line"></span><br><span class="line">    def manage_block_stack(self, why):</span><br><span class="line">        &quot;&quot;&quot; &quot;&quot;&quot;</span><br><span class="line">        frame = self.frame</span><br><span class="line">        block = frame.block_stack[-1]</span><br><span class="line">        if block.type == &#x27;loop&#x27; and why == &#x27;continue&#x27;:</span><br><span class="line">            self.jump(self.return_value)</span><br><span class="line">            why = None</span><br><span class="line">            return why</span><br><span class="line"></span><br><span class="line">        self.pop_block()</span><br><span class="line">        self.unwind_block(block)</span><br><span class="line"></span><br><span class="line">        if block.type == &#x27;loop&#x27; and why == &#x27;break&#x27;:</span><br><span class="line">            why = None</span><br><span class="line">            self.jump(block.handler)</span><br><span class="line">            return why</span><br><span class="line"></span><br><span class="line">        if (block.type in [&#x27;setup-except&#x27;, &#x27;finally&#x27;] and why == &#x27;exception&#x27;):</span><br><span class="line">            self.push_block(&#x27;except-handler&#x27;)</span><br><span class="line">            exctype, value, tb = self.last_exception</span><br><span class="line">            self.push(tb, value, exctype)</span><br><span class="line">            self.push(tb, value, exctype) # yes, twice</span><br><span class="line">            why = None</span><br><span class="line">            self.jump(block.handler)</span><br><span class="line">            return why</span><br><span class="line"></span><br><span class="line">        elif block.type == &#x27;finally&#x27;:</span><br><span class="line">            if why in (&#x27;return&#x27;, &#x27;continue&#x27;):</span><br><span class="line">                self.push(self.return_value)</span><br><span class="line"></span><br><span class="line">            self.push(why)</span><br><span class="line"></span><br><span class="line">            why = None</span><br><span class="line">            self.jump(block.handler)</span><br><span class="line">            return why</span><br><span class="line">        return why</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h3><p>剩下了的就是完成那些指令方法了：<code>byte_LOAD_FAST</code>、<code>byte_BINARY_MODULO</code>等等。而这些指令的实现并不是很有趣，这里我们只展示了一小部分，完整的实现<a target="_blank" rel="noopener" href="https://github.com/nedbat/byterun">在 GitHub 上</a>。（这里包括的指令足够执行我们前面所述的所有代码了。）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br></pre></td><td class="code"><pre><span class="line">class VirtualMachine(object):</span><br><span class="line">    [... 删节 ...]</span><br><span class="line"></span><br><span class="line">    ## Stack manipulation</span><br><span class="line"></span><br><span class="line">    def byte_LOAD_CONST(self, const):</span><br><span class="line">        self.push(const)</span><br><span class="line"></span><br><span class="line">    def byte_POP_TOP(self):</span><br><span class="line">        self.pop()</span><br><span class="line"></span><br><span class="line">    ## Names</span><br><span class="line">    def byte_LOAD_NAME(self, name):</span><br><span class="line">        frame = self.frame</span><br><span class="line">        if name in frame.f_locals:</span><br><span class="line">            val = frame.f_locals[name]</span><br><span class="line">        elif name in frame.f_globals:</span><br><span class="line">            val = frame.f_globals[name]</span><br><span class="line">        elif name in frame.f_builtins:</span><br><span class="line">            val = frame.f_builtins[name]</span><br><span class="line">        else:</span><br><span class="line">            raise NameError(&quot;name &#x27;%s&#x27; is not defined&quot; % name)</span><br><span class="line">        self.push(val)</span><br><span class="line"></span><br><span class="line">    def byte_STORE_NAME(self, name):</span><br><span class="line">        self.frame.f_locals[name] = self.pop()</span><br><span class="line"></span><br><span class="line">    def byte_LOAD_FAST(self, name):</span><br><span class="line">        if name in self.frame.f_locals:</span><br><span class="line">            val = self.frame.f_locals[name]</span><br><span class="line">        else:</span><br><span class="line">            raise UnboundLocalError(</span><br><span class="line">                &quot;local variable &#x27;%s&#x27; referenced before assignment&quot; % name</span><br><span class="line">            )</span><br><span class="line">        self.push(val)</span><br><span class="line"></span><br><span class="line">    def byte_STORE_FAST(self, name):</span><br><span class="line">        self.frame.f_locals[name] = self.pop()</span><br><span class="line"></span><br><span class="line">    def byte_LOAD_GLOBAL(self, name):</span><br><span class="line">        f = self.frame</span><br><span class="line">        if name in f.f_globals:</span><br><span class="line">            val = f.f_globals[name]</span><br><span class="line">        elif name in f.f_builtins:</span><br><span class="line">            val = f.f_builtins[name]</span><br><span class="line">        else:</span><br><span class="line">            raise NameError(&quot;global name &#x27;%s&#x27; is not defined&quot; % name)</span><br><span class="line">        self.push(val)</span><br><span class="line"></span><br><span class="line">    ## Operators</span><br><span class="line"></span><br><span class="line">    BINARY_OPERATORS = &#123;</span><br><span class="line">        &#x27;POWER&#x27;:    pow,</span><br><span class="line">        &#x27;MULTIPLY&#x27;: operator.mul,</span><br><span class="line">        &#x27;FLOOR_DIVIDE&#x27;: operator.floordiv,</span><br><span class="line">        &#x27;TRUE_DIVIDE&#x27;:  operator.truediv,</span><br><span class="line">        &#x27;MODULO&#x27;:   operator.mod,</span><br><span class="line">        &#x27;ADD&#x27;:      operator.add,</span><br><span class="line">        &#x27;SUBTRACT&#x27;: operator.sub,</span><br><span class="line">        &#x27;SUBSCR&#x27;:   operator.getitem,</span><br><span class="line">        &#x27;LSHIFT&#x27;:   operator.lshift,</span><br><span class="line">        &#x27;RSHIFT&#x27;:   operator.rshift,</span><br><span class="line">        &#x27;AND&#x27;:      operator.and_,</span><br><span class="line">        &#x27;XOR&#x27;:      operator.xor,</span><br><span class="line">        &#x27;OR&#x27;:       operator.or_,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    def binaryOperator(self, op):</span><br><span class="line">        x, y = self.popn(2)</span><br><span class="line">        self.push(self.BINARY_OPERATORS[op](x, y))</span><br><span class="line"></span><br><span class="line">    COMPARE_OPERATORS = [</span><br><span class="line">        operator.lt,</span><br><span class="line">        operator.le,</span><br><span class="line">        operator.eq,</span><br><span class="line">        operator.ne,</span><br><span class="line">        operator.gt,</span><br><span class="line">        operator.ge,</span><br><span class="line">        lambda x, y: x in y,</span><br><span class="line">        lambda x, y: x not in y,</span><br><span class="line">        lambda x, y: x is y,</span><br><span class="line">        lambda x, y: x is not y,</span><br><span class="line">        lambda x, y: issubclass(x, Exception) and issubclass(x, y),</span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line">    def byte_COMPARE_OP(self, opnum):</span><br><span class="line">        x, y = self.popn(2)</span><br><span class="line">        self.push(self.COMPARE_OPERATORS[opnum](x, y))</span><br><span class="line"></span><br><span class="line">    ## Attributes and indexing</span><br><span class="line"></span><br><span class="line">    def byte_LOAD_ATTR(self, attr):</span><br><span class="line">        obj = self.pop()</span><br><span class="line">        val = getattr(obj, attr)</span><br><span class="line">        self.push(val)</span><br><span class="line"></span><br><span class="line">    def byte_STORE_ATTR(self, name):</span><br><span class="line">        val, obj = self.popn(2)</span><br><span class="line">        setattr(obj, name, val)</span><br><span class="line"></span><br><span class="line">    ## Building</span><br><span class="line"></span><br><span class="line">    def byte_BUILD_LIST(self, count):</span><br><span class="line">        elts = self.popn(count)</span><br><span class="line">        self.push(elts)</span><br><span class="line"></span><br><span class="line">    def byte_BUILD_MAP(self, size):</span><br><span class="line">        self.push(&#123;&#125;)</span><br><span class="line"></span><br><span class="line">    def byte_STORE_MAP(self):</span><br><span class="line">        the_map, val, key = self.popn(3)</span><br><span class="line">        the_map[key] = val</span><br><span class="line">        self.push(the_map)</span><br><span class="line"></span><br><span class="line">    def byte_LIST_APPEND(self, count):</span><br><span class="line">        val = self.pop()</span><br><span class="line">        the_list = self.frame.stack[-count] # peek</span><br><span class="line">        the_list.append(val)</span><br><span class="line"></span><br><span class="line">    ## Jumps</span><br><span class="line"></span><br><span class="line">    def byte_JUMP_FORWARD(self, jump):</span><br><span class="line">        self.jump(jump)</span><br><span class="line"></span><br><span class="line">    def byte_JUMP_ABSOLUTE(self, jump):</span><br><span class="line">        self.jump(jump)</span><br><span class="line"></span><br><span class="line">    def byte_POP_JUMP_IF_TRUE(self, jump):</span><br><span class="line">        val = self.pop()</span><br><span class="line">        if val:</span><br><span class="line">            self.jump(jump)</span><br><span class="line"></span><br><span class="line">    def byte_POP_JUMP_IF_FALSE(self, jump):</span><br><span class="line">        val = self.pop()</span><br><span class="line">        if not val:</span><br><span class="line">            self.jump(jump)</span><br><span class="line"></span><br><span class="line">    ## Blocks</span><br><span class="line"></span><br><span class="line">    def byte_SETUP_LOOP(self, dest):</span><br><span class="line">        self.push_block(&#x27;loop&#x27;, dest)</span><br><span class="line"></span><br><span class="line">    def byte_GET_ITER(self):</span><br><span class="line">        self.push(iter(self.pop()))</span><br><span class="line"></span><br><span class="line">    def byte_FOR_ITER(self, jump):</span><br><span class="line">        iterobj = self.top()</span><br><span class="line">        try:</span><br><span class="line">            v = next(iterobj)</span><br><span class="line">            self.push(v)</span><br><span class="line">        except StopIteration:</span><br><span class="line">            self.pop()</span><br><span class="line">            self.jump(jump)</span><br><span class="line"></span><br><span class="line">    def byte_BREAK_LOOP(self):</span><br><span class="line">        return &#x27;break&#x27;</span><br><span class="line"></span><br><span class="line">    def byte_POP_BLOCK(self):</span><br><span class="line">        self.pop_block()</span><br><span class="line"></span><br><span class="line">    ## Functions</span><br><span class="line"></span><br><span class="line">    def byte_MAKE_FUNCTION(self, argc):</span><br><span class="line">        name = self.pop()</span><br><span class="line">        code = self.pop()</span><br><span class="line">        defaults = self.popn(argc)</span><br><span class="line">        globs = self.frame.f_globals</span><br><span class="line">        fn = Function(name, code, globs, defaults, None, self)</span><br><span class="line">        self.push(fn)</span><br><span class="line"></span><br><span class="line">    def byte_CALL_FUNCTION(self, arg):</span><br><span class="line">        lenKw, lenPos = divmod(arg, 256) # KWargs not supported here</span><br><span class="line">        posargs = self.popn(lenPos)</span><br><span class="line"></span><br><span class="line">        func = self.pop()</span><br><span class="line">        frame = self.frame</span><br><span class="line">        retval = func(*posargs)</span><br><span class="line">        self.push(retval)</span><br><span class="line"></span><br><span class="line">    def byte_RETURN_VALUE(self):</span><br><span class="line">        self.return_value = self.pop()</span><br><span class="line">        return &quot;return&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="动态类型：编译器不知道它是什么"><a href="#动态类型：编译器不知道它是什么" class="headerlink" title="动态类型：编译器不知道它是什么"></a>动态类型：编译器不知道它是什么</h3><p>你可能听过 Python 是一种动态语言 —— 它是动态类型的。在我们建造解释器的过程中，已经透露出这样的信息。</p><p>动态的一个意思是很多工作是在运行时完成的。前面我们看到 Python 的编译器没有很多关于代码真正做什么的信息。举个例子，考虑下面这个简单的函数<code>mod</code>。它取两个参数，返回它们的模运算值。从它的字节码中，我们看到变量<code>a</code>和<code>b</code>首先被加载，然后字节码<code>BINAY_MODULO</code>完成这个模运算。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def mod(a, b):</span><br><span class="line">...    return a % b</span><br><span class="line">&gt;&gt;&gt; dis.dis(mod)</span><br><span class="line">  2           0 LOAD_FAST                0 (a)</span><br><span class="line">              3 LOAD_FAST                1 (b)</span><br><span class="line">              6 BINARY_MODULO</span><br><span class="line">              7 RETURN_VALUE</span><br><span class="line">&gt;&gt;&gt; mod(19, 5)</span><br><span class="line">4</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>计算 19 % 5 得4，—— 一点也不奇怪。如果我们用不同类的参数呢？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; mod(&quot;by%sde&quot;, &quot;teco&quot;)</span><br><span class="line">&#x27;bytecode&#x27;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>刚才发生了什么？你可能在其它地方见过这样的语法，格式化字符串。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; print(&quot;by%sde&quot; % &quot;teco&quot;)</span><br><span class="line">bytecode</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>用符号<code>%</code>去格式化字符串会调用字节码<code>BUNARY_MODULO</code>。它取栈顶的两个值求模，不管这两个值是字符串、数字或是你自己定义的类的实例。字节码在函数编译时生成（或者说，函数定义时）相同的字节码会用于不同类的参数。</p><p>Python 的编译器关于字节码的功能知道的很少，而取决于解释器来决定<code>BINAYR_MODULO</code>应用于什么类型的对象并完成正确的操作。这就是为什么 Python 被描述为<ruby>动态类型 <rp>（ </rp><rt>dynamically typed</rt> <rp>）</rp></ruby>：直到运行前你不必知道这个函数参数的类型。相反，在一个静态类型语言中，程序员需要告诉编译器参数的类型是什么（或者编译器自己推断出参数的类型。）</p><p>编译器的无知是优化 Python 的一个挑战 —— 只看字节码，而不真正运行它，你就不知道每条字节码在干什么！你可以定义一个类，实现<code>__mod__</code>方法，当你对这个类的实例使用<code>%</code>时，Python 就会自动调用这个方法。所以，<code>BINARY_MODULO</code>其实可以运行任何代码。</p><p>看看下面的代码，第一个<code>a % b</code>看起来没有用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">def mod(a,b):</span><br><span class="line">    a % b</span><br><span class="line">    return a %b</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>不幸的是，对这段代码进行静态分析 —— 不运行它 —— 不能确定第一个<code>a % b</code>没有做任何事。用 <code>%</code>调用<code>__mod__</code>可能会写一个文件，或是和程序的其他部分交互，或者其他任何可以在 Python 中完成的事。很难优化一个你不知道它会做什么的函数。在 Russell Power 和 Alex Rubinsteyn 的优秀论文中写道，“我们可以用多快的速度解释 Python？”，他们说，“在普遍缺乏类型信息下，每条指令必须被看作一个<code>INVOKE_ARBITRARY_METHOD</code>。”</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Byterun 是一个比 CPython 容易理解的简洁的 Python 解释器。Byterun 复制了 CPython 的主要结构：一个基于栈的解释器对称之为字节码的指令集进行操作，它们顺序执行或在指令间跳转，向栈中压入和从中弹出数据。解释器随着函数和生成器的调用和返回，动态的创建、销毁帧，并在帧之间跳转。Byterun 也有着和真正解释器一样的限制：因为 Python 使用动态类型，解释器必须在运行时决定指令的正确行为。</p><p>我鼓励你去反汇编你的程序，然后用 Byterun 来运行。你很快会发现这个缩短版的 Byterun 所没有实现的指令。完整的实现在 <a target="_blank" rel="noopener" href="https://github.com/nedbat/byterun">https://github.com/nedbat/byterun</a>，或者你可以仔细阅读真正的 CPython 解释器<code>ceval.c</code>，你也可以实现自己的解释器！</p><h3 id="致谢"><a href="#致谢" class="headerlink" title="致谢"></a>致谢</h3><p>感谢 Ned Batchelder 发起这个项目并引导我的贡献，感谢 Michael Arntzenius 帮助调试代码和这篇文章的修订，感谢 Leta Montopoli 的修订，以及感谢整个 Recurse Center 社区的支持和鼓励。所有的不足全是我自己没搞好。</p><hr><p>via: <a target="_blank" rel="noopener" href="http://aosabook.org/en/500L/a-python-interpreter-written-in-python.html">http://aosabook.org/en/500L/a-python-interpreter-written-in-python.html</a></p><p>作者： Allison Kaptur 译者：<a target="_blank" rel="noopener" href="https://github.com/qingyunha">qingyunha</a> 校对：<a target="_blank" rel="noopener" href="https://github.com/wxy">wxy</a></p><p>本文由 <a target="_blank" rel="noopener" href="https://github.com/LCTT/TranslateProject">LCTT</a> 原创翻译，<a target="_blank" rel="noopener" href="http://linux.cn/">Linux中国</a> 荣誉推出</p></div></div></div><div class="footer"><p class="footer-copyright"><span>Powered by <a target="_blank" href="https://hexo.io">Hexo</a></span> <span>Theme <a target="_blank" href="https://github.com/tinkink-co/hexo-theme-terminal">Terminal</a></span><script type="text/javascript" src="https://cdn.staticfile.net/jquery/3.4.1/jquery.min.js"></script><script>getCDNinfo=function(){$.ajax({url:"/cdn-cgi/trace",success:function(a,n){let i="Antananarivo, Madagascar - (TNR);Cape Town, South Africa - (CPT);Casablanca, Morocco - (CMN);Dar Es Salaam, Tanzania - (DAR);Djibouti City, Djibouti - (JIB);Durban, South Africa - (DUR);Johannesburg, South Africa - (JNB);Kigali, Rwanda - (KGL);Lagos, Nigeria - (LOS);Luanda, Angola - (LAD);Maputo, MZ - (MPM);Mombasa, Kenya - (MBA);Port Louis, Mauritius - (MRU);Réunion, France - (RUN);Bangalore, India - (BLR);Bangkok, Thailand - (BKK);Bandar Seri Begawan, Brunei - (BWN);Cebu, Philippines - (CEB);Chengdu, China - (CTU);Chennai, India - (MAA);Chittagong, Bangladesh - (CGP);Chongqing, China - (CKG);Colombo, Sri Lanka - (CMB);Dhaka, Bangladesh - (DAC);Dongguan, China - (SZX);Foshan, China - (FUO);Fuzhou, China - (FOC);Guangzhou, China - (CAN);Hangzhou, China - (HGH);Hanoi, Vietnam - (HAN);Hengyang, China - (HNY);Ho Chi Minh City, Vietnam - (SGN);Hong Kong - (HKG);Hyderabad, India - (HYD);Islamabad, Pakistan - (ISB);Jakarta, Indonesia - (CGK);Jinan, China - (TNA);Karachi, Pakistan - (KHI);Kathmandu, Nepal - (KTM);Kolkata, India - (CCU);Kuala Lumpur, Malaysia - (KUL);Lahore, Pakistan - (LHE);Langfang, China - (NAY);Luoyang, China - (LYA);Macau - (MFM);Malé, Maldives - (MLE);Manila, Philippines - (MNL);Mumbai, India - (BOM);Nagpur, India - (NAG);Nanning, China - (NNG);New Delhi, India - (DEL);Osaka, Japan - (KIX);Phnom Penh, Cambodia - (PNH);Qingdao, China - (TAO);Seoul, South Korea - (ICN);Shanghai, China - (SHA);Shenyang, China - (SHE);Shijiazhuang, China - (SJW);Singapore, Singapore - (SIN);Suzhou, China - (SZV);Taipei - (TPE);Thimphu, Bhutan - (PBH);Tianjin, China - (TSN);Tokyo, Japan - (NRT);Ulaanbaatar, Mongolia - (ULN);Vientiane, Laos - (VTE);Wuhan, China - (WUH);Wuxi, China - (WUX);Xi'an, China - (XIY);Yerevan, Armenia - (EVN);Zhengzhou, China - (CGO);Zuzhou, China - (CSX);Amsterdam, Netherlands - (AMS);Athens, Greece - (ATH);Barcelona, Spain - (BCN);Belgrade, Serbia - (BEG);Berlin, Germany - (TXL);Brussels, Belgium - (BRU);Bucharest, Romania - (OTP);Budapest, Hungary - (BUD);Chișinău, Moldova - (KIV);Copenhagen, Denmark - (CPH);Cork, Ireland -  (ORK);Dublin, Ireland - (DUB);Düsseldorf, Germany - (DUS);Edinburgh, United Kingdom - (EDI);Frankfurt, Germany - (FRA);Geneva, Switzerland - (GVA);Gothenburg, Sweden - (GOT);Hamburg, Germany - (HAM);Helsinki, Finland - (HEL);Istanbul, Turkey - (IST);Kyiv, Ukraine - (KBP);Lisbon, Portugal - (LIS);London, United Kingdom - (LHR);Luxembourg City, Luxembourg - (LUX);Madrid, Spain - (MAD);Manchester, United Kingdom - (MAN);Marseille, France - (MRS);Milan, Italy - (MXP);Moscow, Russia - (DME);Munich, Germany - (MUC);Nicosia, Cyprus - (LCA);Oslo, Norway - (OSL);Paris, France - (CDG);Prague, Czech Republic - (PRG);Reykjavík, Iceland - (KEF);Riga, Latvia - (RIX);Rome, Italy - (FCO);Saint Petersburg, Russia - (LED);Sofia, Bulgaria - (SOF);Stockholm, Sweden - (ARN);Tallinn, Estonia - (TLL);Thessaloniki, Greece - (SKG);Vienna, Austria - (VIE);Vilnius, Lithuania - (VNO);Warsaw, Poland - (WAW);Zagreb, Croatia - (ZAG);Zürich, Switzerland - (ZRH);Arica, Chile - (ARI);Asunción, Paraguay - (ASU);Bogotá, Colombia - (BOG);Buenos Aires, Argentina - (EZE);Curitiba, Brazil - (CWB);Fortaleza, Brazil - (FOR);Guatemala City, Guatemala - (GUA);Lima, Peru - (LIM);Medellín, Colombia - (MDE);Panama City, Panama - (PTY);Porto Alegre, Brazil - (POA);Quito, Ecuador - (UIO);Rio de Janeiro, Brazil - (GIG);São Paulo, Brazil - (GRU);Santiago, Chile - (SCL);Willemstad, Curaçao - (CUR);St. George's, Grenada - (GND);Amman, Jordan - (AMM);Baghdad, Iraq - (BGW);Baku, Azerbaijan - (GYD);Beirut, Lebanon - (BEY);Doha, Qatar - (DOH);Dubai, United Arab Emirates - (DXB);Kuwait City, Kuwait - (KWI);Manama, Bahrain - (BAH);Muscat, Oman - (MCT);Ramallah - (ZDM);Riyadh, Saudi Arabia - (RUH);Tel Aviv, Israel - (TLV);Ashburn, VA, United States - (IAD);Atlanta, GA, United States - (ATL);Boston, MA, United States - (BOS);Buffalo, NY, United States - (BUF);Calgary, AB, Canada - (YYC);Charlotte, NC, United States - (CLT);Chicago, IL, United States - (ORD);Columbus, OH, United States - (CMH);Dallas, TX, United States - (DFW);Denver, CO, United States - (DEN);Detroit, MI, United States - (DTW);Honolulu, HI, United States - (HNL);Houston, TX, United States - (IAH);Indianapolis, IN, United States - (IND);Jacksonville, FL, United States - (JAX);Kansas City, MO, United States - (MCI);Las Vegas, NV, United States - (LAS);Los Angeles, CA, United States - (LAX);McAllen, TX, United States - (MFE);Memphis, TN, United States - (MEM);Mexico City, Mexico - (MEX);Miami, FL, United States - (MIA);Minneapolis, MN, United States - (MSP);Montgomery, AL, United States - (MGM);Montréal, QC, Canada - (YUL);Nashville, TN, United States - (BNA);Newark, NJ, United States - (EWR);Norfolk, VA, United States - (ORF);Omaha, NE, United States - (OMA);Philadelphia, United States - (PHL);Phoenix, AZ, United States - (PHX);Pittsburgh, PA, United States - (PIT);Port-Au-Prince, Haiti - (PAP);Portland, OR, United States - (PDX);Queretaro, MX, Mexico - (QRO);Richmond, Virginia - (RIC);Sacramento, CA, United States - (SMF);Salt Lake City, UT, United States - (SLC);San Diego, CA, United States - (SAN);San Jose, CA, United States - (SJC);Saskatoon, SK, Canada - (YXE);Seattle, WA, United States - (SEA);St. Louis, MO, United States - (STL);Tampa, FL, United States - (TPA);Toronto, ON, Canada - (YYZ);Vancouver, BC, Canada - (YVR);Tallahassee, FL, United States - (TLH);Winnipeg, MB, Canada - (YWG);Adelaide, SA, Australia - (ADL);Auckland, New Zealand - (AKL);Brisbane, QLD, Australia - (BNE);Melbourne, VIC, Australia - (MEL);Noumea, New caledonia - (NOU);Perth, WA, Australia - (PER);Sydney, NSW, Australia - (SYD)".split(";"),e=a.split("colo=")[1].split("\n")[0],t=(a.split("colo=")[1].split("\n")[0],a.split("tls=")[1].split("\n")[0]),o=a.split("http=")[1].split("\n")[0],s=a.split("sni=")[1].split("\n")[0],r=a.split("ip=")[1].split("\n")[0],l=a.split("uag=")[1].split("\n")[0];for(var d=0;d<i.length;d++)if(-1!=i[d].indexOf(e)){document.getElementById("cdn").innerHTML=i[d];break}document.getElementById("tls").innerHTML=t,document.getElementById("http").innerHTML=o,document.getElementById("sni").innerHTML=s,document.getElementById("ip").innerHTML=r,document.getElementById("useragent").innerHTML=l}})},$(document).ready((function(){getCDNinfo()}))</script></p><p style="text-align:center">感谢陪伴与布道，开源之火不灭。​</p><p style="text-align:center"><script>document.write("本次加载耗时: "+(performance.getEntriesByType("navigation").reduce((e,r)=>e+r.responseEnd-r.startTime,0)+performance.getEntriesByType("resource").reduce((e,r)=>e+r.responseEnd-r.startTime,0)).toFixed(0)+"ms")</script></p><p style="text-align:center">当前 SNI 状态： <span id="sni">正在统计！或可能被浏览器防追踪拦截！</span></p><p style="text-align:center">当前 TLS 版本： <span id="tls">正在统计！或可能被浏览器防追踪拦截！</span></p><p style="text-align:center">当前 HTTP 版本： <span id="http">正在统计！或可能被浏览器防追踪拦截！</span></p><p style="text-align:center">当前您的客户端 IP 是： <span id="ip">正在统计！或可能被浏览器防追踪拦截！</span></p><p style="text-align:center">当前分配的 CDN 节点是: <span id="cdn">正在统计！或可能被浏览器防追踪拦截！</span></p><p style="text-align:center">您的 UserAgent 信息是: <span id="useragent">正在统计！或可能被浏览器防追踪拦截！</span></p><p></p></div></div></body></html>