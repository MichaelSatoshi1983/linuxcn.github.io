<!doctype html><html lang="en"><head><meta name="msvalidate.01" content="D404690CEFCB54C7762AC84935B99171"><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?6618da70c90c8744eead2e9371fb5077";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><script type="text/javascript">!function(t,e,n,c,s,a,r){t[n]=t[n]||function(){(t[n].q=t[n].q||[]).push(arguments)},(a=e.createElement(c)).async=1,a.src="https://www.clarity.ms/tag/s5f3f0tojf",(r=e.getElementsByTagName(c)[0]).parentNode.insertBefore(a,r)}(window,document,"clarity","script")</script><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta http-equiv="X-UA-Compatible" content="ie=edge"><link rel="stylesheet" href="/styles/base.css"><link rel="stylesheet" href="/styles/theme.css"><link rel="shortcut icon" href="/favicon.png"><title>Linux 的 EXT4 文件系统的历史、特性以及最佳实践 - 归墟星火集</title><meta name="generator" content="Hexo 7.3.0"></head><body><div class="header-title"><span class="header-light"></span> <span class="header-light"></span> <span class="header-light"></span> <span>归墟星火集 linuxcn.undefined.today<span></span></span></div><div class="container"><ul class="nav"><li><a href="/">首页</a></li><li><a href="/about/">关于</a></li><li><a target="_blank" rel="noopener" href="https://undefined.today/">Blog</a></li></ul><div class="content"><div class="post-container"><div class="post-header"><span class="ui-tips">标题：</span><h1 class="ui-keyword post-title">Linux 的 EXT4 文件系统的历史、特性以及最佳实践</h1><span class="post-date">2017-07-11</span></div><div class="post-header"><span class="ui-tips">分类：</span> <a href="/categories/%E6%8A%80%E6%9C%AF/">技术</a></div><div class="post-header"><span class="ui-tips">标签：</span> <a href="/tags/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/">文件系统</a> <a href="/tags/EXT4/">EXT4</a> <a href="/tags/EXT/">EXT</a></div><div class="post-content"><blockquote><p>让我们大概地从 EXT4 的历史、特性以及最佳实践这几个方面来学习它和之前的几代 EXT 文件系统有何不同。</p></blockquote><p><img src="https://linuxcn.img.undefined.today/data/attachment/album/201707/11/153812r3lq9bqq7om791hf.jpg"></p><p>在之前关于 Linux 文件系统的文章里，我写过一篇 <a target="_blank" rel="noopener" href="https://opensource.com/life/16/10/introduction-linux-filesystems">Linux 文件系统介绍</a> 和一些更高级的概念例如 <a target="_blank" rel="noopener" href="https://opensource.com/life/15/9/everything-is-a-file">一切都是文件</a>。现在我想要更深入地了解 EXT 文件系统的特性的详细内容，但是首先让我们来回答一个问题，“什么样才算是一个文件系统 ？” 一个文件系统应该涵盖以下所有特点：</p><ol><li><strong>数据存储：</strong> 对于任何一个文件系统来说，一个最主要的功能就是能够被当作一个结构化的容器来存储和获取数据。</li><li><strong>命名空间：</strong> 命名空间是一个提供了用于命名与组织数据的命名规则和数据结构的方法学。</li><li><strong>安全模型：</strong> 一个用于定义访问权限的策略。</li><li><strong>API：</strong> 操作这个系统的对象的系统功能调用，这些对象诸如目录和文件。</li><li><strong>实现：</strong> 能够实现以上几点的软件。</li></ol><p>本文内容的讨论主要集中于上述几点中的第一项，并探索为一个 EXT 文件系统的数据存储提供逻辑框架的元数据结构。</p><h3 id="EXT-文件系统历史"><a href="#EXT-文件系统历史" class="headerlink" title="EXT 文件系统历史"></a>EXT 文件系统历史</h3><p>虽然 EXT 文件系统是为 Linux 编写的，但其真正起源于 Minix 操作系统和 Minix 文件系统，而 Minix 最早发布于 1987，早于 Linux 5 年。如果我们从 EXT 文件系统大家族的 Minix 起源来观察其历史与技术发展那么理解 EXT4 文件系统就会简单得多。</p><h3 id="Minix"><a href="#Minix" class="headerlink" title="Minix"></a>Minix</h3><p>当 Linux Torvalds 在写最初的 Linux 内核的时候，他需要一个文件系统但是他又不想自己写一个。于是他简单地把 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/MINIX_file_system">Minix 文件系统</a> 加了进去，这个 Minix 文件系统是由 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Andrew_S._Tanenbaum">Andrew S. Tanenbaum</a> 写的，同时它也是 Tanenbaum 的 Minix 操作系统的一部分。<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/MINIX">Minix</a> 是一个类 Unix 风格的操作系统，最初编写它的原因是用于教育用途。Minix 的代码是自由可用的并有适当的许可协议，所以 Torvalds 可以把它用 Linux 的最初版本里。</p><p>Minix 有以下这些结构，其中的大部分位于生成文件系统的分区中：</p><ul><li><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Boot_sector"><strong>引导扇区</strong></a> 是硬盘安装后的第一个扇区。这个引导块包含了一个非常小的引导记录和一个分区表。</li><li>每一个分区的第一个块都是一个包含了元数据的<ruby>超级块 <rp>（ </rp><rt>superblock</rt> <rp>）</rp></ruby> ，这些元数据定义了其他的文件系统结构并将其定位于物理硬盘的具体分区上。</li><li>一个 <strong>inode 位图块</strong> 决定了哪些 inode 是在使用中的，哪一些是未使用的。</li><li><strong>inode</strong> 在硬盘上有它们自己的空间。每一个 inode 都包含了一个文件的信息，包括其所处的数据块的位置，也就是该文件所处的区域。</li><li>一个 <strong>区位图</strong> 用于保持追踪数据区域的使用和未使用情况。</li><li>一个 <strong>数据区</strong>, 这里是数据存储的地方。</li></ul><p>对上述了两种位图类型来说，一个<ruby>位 <rp>（ </rp><rt>bit</rt> <rp>）</rp></ruby>表示一个指定的数据区或者一个指定的 inode。 如果这个位是 0 则表示这个数据区或者这个 inode 是未使用的，如果是 1 则表示正在使用中。</p><p>那么，<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Inode">inode</a> 又是什么呢 ? 就是 index-node（索引节点）的简写。 inode 是位于磁盘上的一个 256 字节的块，用于存储和该 inode 对应的文件的相关数据。这些数据包含了文件的大小、文件的所有者和所属组的用户 ID、文件模式（即访问权限）以及三个时间戳用于指定：该文件最后的访问时间、该文件的最后修改时间和该 inode 中的数据的最后修改时间。</p><p>同时，这个 inode 还包含了位置数据，指向了其所对应的文件数据在硬盘中的位置。在 Minix 和 EXT 1-3 文件系统中，这是一个数据区和块的列表。Minix 文件系统的 inode 支持 9 个数据块，包括 7 个直接数据块和 2 个间接数据块。如果你想要更深入的了解，这里有一个优秀的 PDF 详细地描述了 <a target="_blank" rel="noopener" href="http://ohm.hgesser.de/sp-ss2012/Intro-MinixFS.pdf">Minix 文件系统结构</a> 。同时你也可以在维基百科上对 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Inode_pointer_structure">inode 指针结构</a> 做一个快速了解。</p><h3 id="EXT"><a href="#EXT" class="headerlink" title="EXT"></a>EXT</h3><p>原生的 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Extended_file_system">EXT 文件系统</a> (意即<ruby>扩展的 <rp>（ </rp><rt>extended</rt> <rp>）</rp></ruby>) 是由 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/R%C3%A9my_Card">Rémy Card</a> 编写并于 1992 年与 Linux 一同发行。主要是为了克服 Minix 文件系统中的一些文件大小限制的问题。其中，最主要的结构变化就是文件系统中的元数据。它基于 Unix 文件系统 （UFS），其也被称为伯克利快速文件系统（FFS）。我发现只有很少一部分关于 EXT 文件系统的发行信息是可以被确证的，显然这是因为其存在着严重的问题，并且它很快地被 EXT2 文件系统取代了。</p><h3 id="EXT2"><a href="#EXT2" class="headerlink" title="EXT2"></a>EXT2</h3><p><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Ext2">EXT2 文件系统</a> 就相当地成功，它在 Linux 发行版中存活了多年。它是我在 1997 年开始使用 Red Hat Linux 5.0 时接触的第一个文件系统。实际上，EXT2 文件系统有着和 EXT 文件系统基本相同的元数据结构。然而 EXT2 更高瞻远瞩，因为其元数据结构之间留有很多供将来使用的磁盘空间。</p><p>和 Minix 类似，EXT2 也有一个<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Boot_sector">引导扇区</a> ，它是硬盘安装后的第一个扇区。它包含了非常小的引导记录和一个分区表。接着引导扇区之后是一些保留的空间，它填充了引导记录和硬盘驱动器上的第一个分区（通常位于下一个柱面）之间的空间。<a target="_blank" rel="noopener" href="https://opensource.com/article/17/2/linux-boot-and-startup">GRUB2</a> - 也可能是 GRUB1 - 将此空间用于其部分引导代码。</p><p>每个 EXT2 分区中的空间被分为<ruby>柱面组 <rp>（ </rp><rt>cylinder group</rt> <rp>）</rp></ruby>，它允许更精细地管理数据空间。 根据我的经验，每一组大小通常约为 8MB。 下面的图 1 显示了一个柱面组的基本结构。 柱面中的数据分配单元是块，通常大小为 4K。</p><p><img src="https://linuxcn.img.undefined.today/data/attachment/album/201707/11/154011lxv9mpu50c5v0xa5.png" alt="cylindergroup-01_1.png"></p><p><em>图 1： EXT 文件系统中的柱面组的结构</em></p><p>柱面组中的第一个块是一个<ruby>超级块 <rp>（ </rp><rt>superblock</rt> <rp>）</rp></ruby>，它包含了元数据，定义了其它文件系统的结构并将其定位于物理硬盘的具体分区上。分区中有一些柱面组还会有备用超级块，但并不是所有的柱面组都有。我们可以使用例如 <code>dd</code> 等磁盘工具来拷贝备用超级块的内容到主超级块上，以达到修复损坏的超级块的目的。虽然这种情况不会经常发生，但是在几年前我的一个超级块损坏了，我就是用这种方法来修复的。幸好，我很有先见之明地使用了 <code>dumpe2fs</code> 命令来备份了我的系统上的分区描述符信息。</p><p>以下是 <code>dumpe2fs</code> 命令的一部分输出。这部分输出主要是超级块上包含的一些元数据，同时也是文件系统上的前两个柱面组的数据。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"># dumpe2fs /dev/sda1</span><br><span class="line">Filesystem volume name:   boot </span><br><span class="line">Last mounted on:          /boot </span><br><span class="line">Filesystem UUID:          79fc5ed8-5bbc-4dfe-8359-b7b36be6eed3 </span><br><span class="line">Filesystem magic number:  0xEF53 </span><br><span class="line">Filesystem revision #:    1 (dynamic) </span><br><span class="line">Filesystem features:      has_journal ext_attr resize_inode dir_index filetype needs_recovery extent 64bit flex_bg sparse_super large_file huge_file dir nlink extra_isize </span><br><span class="line">Filesystem flags:         signed_directory_hash </span><br><span class="line">Default mount options:    user_xattr acl </span><br><span class="line">Filesystem state:         clean </span><br><span class="line">Errors behavior:          Continue </span><br><span class="line">Filesystem OS type:       Linux </span><br><span class="line">Inode count:              122160 </span><br><span class="line">Block count:              488192 </span><br><span class="line">Reserved block count:     24409 </span><br><span class="line">Free blocks:              376512 </span><br><span class="line">Free inodes:              121690 </span><br><span class="line">First block:              0 </span><br><span class="line">Block size:               4096 </span><br><span class="line">Fragment size:            4096 </span><br><span class="line">Group descriptor size:    64 </span><br><span class="line">Reserved GDT blocks:      238 </span><br><span class="line">Blocks per group:         32768 </span><br><span class="line">Fragments per group:      32768 </span><br><span class="line">Inodes per group:         8144 </span><br><span class="line">Inode blocks per group:   509 </span><br><span class="line">Flex block group size:    16 </span><br><span class="line">Filesystem created:       Tue Feb  7 09:33:34 2017 </span><br><span class="line">Last mount time:          Sat Apr 29 21:42:01 2017 </span><br><span class="line">Last write time:          Sat Apr 29 21:42:01 2017 </span><br><span class="line">Mount count:              25 </span><br><span class="line">Maximum mount count:      -1 </span><br><span class="line">Last checked:             Tue Feb  7 09:33:34 2017 </span><br><span class="line">Check interval:           0 (&lt;none&gt;) </span><br><span class="line">Lifetime writes:          594 MB </span><br><span class="line">Reserved blocks uid:      0 (user root) </span><br><span class="line">Reserved blocks gid:      0 (group root) </span><br><span class="line">First inode:              11 </span><br><span class="line">Inode size:               256 </span><br><span class="line">Required extra isize:     32 </span><br><span class="line">Desired extra isize:      32 </span><br><span class="line">Journal inode:            8 </span><br><span class="line">Default directory hash:   half_md4 </span><br><span class="line">Directory Hash Seed:      c780bac9-d4bf-4f35-b695-0fe35e8d2d60 </span><br><span class="line">Journal backup:           inode blocks </span><br><span class="line">Journal features:         journal_64bit </span><br><span class="line">Journal size:             32M </span><br><span class="line">Journal length:           8192 </span><br><span class="line">Journal sequence:         0x00000213 </span><br><span class="line">Journal start:            0 </span><br><span class="line"></span><br><span class="line">Group 0: (Blocks 0-32767) </span><br><span class="line"> Primary superblock at 0, Group descriptors at 1-1 </span><br><span class="line"> Reserved GDT blocks at 2-239 </span><br><span class="line"> Block bitmap at 240 (+240) </span><br><span class="line"> Inode bitmap at 255 (+255) </span><br><span class="line"> Inode table at 270-778 (+270) </span><br><span class="line"> 24839 free blocks, 7676 free inodes, 16 directories </span><br><span class="line"> Free blocks: 7929-32767 </span><br><span class="line"> Free inodes: 440, 470-8144 </span><br><span class="line">Group 1: (Blocks 32768-65535) </span><br><span class="line"> Backup superblock at 32768, Group descriptors at 32769-32769 </span><br><span class="line"> Reserved GDT blocks at 32770-33007 </span><br><span class="line"> Block bitmap at 241 (bg #0 + 241) </span><br><span class="line"> Inode bitmap at 256 (bg #0 + 256)</span><br><span class="line"> Inode table at 779-1287 (bg #0 + 779) </span><br><span class="line"> 8668 free blocks, 8142 free inodes, 2 directories </span><br><span class="line"> Free blocks: 33008-33283, 33332-33791, 33974-33975, 34023-34092, 34094-34104, 34526-34687, 34706-34723, 34817-35374, 35421-35844, 35935-36355, 36357-36863, 38912-39935, 39940-40570, 42620-42623, 42655, 42674-42687, 42721-42751, 42798-42815, 42847, 42875-42879, 42918-42943, 42975, 43000-43007, 43519, 43559-44031, 44042-44543, 44545-45055, 45116-45567, 45601-45631, 45658-45663, 45689-45695, 45736-45759, 45802-45823, 45857-45887, 45919, 45950-45951, 45972-45983, 46014-46015, 46057-46079, 46112-46591, 46921-47103, 49152-49395, 50027-50355, 52237-52255, 52285-52287, 52323-52351, 52383, 52450-52479, 52518-52543, 52584-52607, 52652-52671, 52734-52735, 52743-53247 </span><br><span class="line"> Free inodes: 8147-16288 </span><br><span class="line">Group 2: (Blocks 65536-98303) </span><br><span class="line"> Block bitmap at 242 (bg #0 + 242) </span><br><span class="line"> Inode bitmap at 257 (bg #0 + 257) </span><br><span class="line"> Inode table at 1288-1796 (bg #0 + 1288) </span><br><span class="line"> 6326 free blocks, 8144 free inodes, 0 directories </span><br><span class="line"> Free blocks: 67042-67583, 72201-72994, 80185-80349, 81191-81919, 90112-94207 </span><br><span class="line"> Free inodes: 16289-24432 </span><br><span class="line">Group 3: (Blocks 98304-131071)</span><br><span class="line"></span><br><span class="line">&lt;截断&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>每一个柱面组都有自己的 inode 位图，用于判定该柱面组中的哪些 inode 是使用中的而哪些又是未被使用的。每一个柱面组的 inode 都有它们自己的空间。每一个 inode 都包含了一个文件的相关信息，包括属于该文件的数据块的位置。而块位图纪录了文件系统中的使用中和非使用中的数据块。请注意，在上面的输出中有大量关于文件系统的数据。在非常大的文件系统上，柱面组的数据可以多达数百页的长度。柱面组的元数据包括组中所有空闲数据块的列表。</p><p>EXT 文件系统实现了数据分配策略以确保产生最少的文件碎片。减少文件碎片可以提高文件系统的性能。这些策略会在下面的 EXT4 中描述到。</p><p>我所遇见的关于 EXT2 文件系统最大的问题是 <code>fsck</code> (文件系统检查) 程序这一环节占用了很长一段时间来定位和校准文件系统中的所有的不一致性，从而导致在系统<ruby>崩溃 <rp>（ </rp><rt>crash</rt> <rp>）</rp></ruby>后其会花费了数个小时来修复。有一次我的其中一台电脑在崩溃后重新启动时共花费了 28 个小时恢复磁盘，而且并且是在磁盘被检测量只有几百兆字节大小的情况下。</p><h3 id="EXT3"><a href="#EXT3" class="headerlink" title="EXT3"></a>EXT3</h3><p><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Ext3">EXT3 文件系统</a>是应一个目标而生的，就是克服 <code>fsck</code> 程序需要完全恢复在文件更新操作期间发生的不正确关机而损坏的磁盘结构所需的大量时间。它对 EXT 文件系统的唯一新增功能就是 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Journaling_file_system">日志</a>，它将提前记录将对文件系统执行的更改。 EXT3 的磁盘结构的其余部分与 EXT2 中的相同。</p><p>除了同先前的版本一样直接写入数据到磁盘的数据区域外，EXT3 上的日志会将文件数据随同元数据写入到磁盘上的一个指定数据区域。一旦这些（日志）数据安全地到达硬盘，它就可以几乎零丢失率地被合并或被追加到目标文件上。当这些数据被提交到磁盘上的数据区域上，这些日志就会随即更新，这样在日志中的所有数据提交之前，系统发生故障时文件系统将保持一致状态。在下次启动时，将检查文件系统的不一致性，然后将仍保留在日志中的数据提交到磁盘的数据区，以完成对目标文件的更新。</p><p>日志功能确实降低了数据写入性能，但是有三个可用于日志的选项，允许用户在性能和数据完整性、安全性之间进行选择。 我的个人更偏向于选择安全性，因为我的环境不需要大量的磁盘写入活动。</p><p>日志功能将失败后检查硬盘驱动器所需的时间从几小时（甚至几天）减少到了几分钟。 多年来，我遇到了很多导致我的系统崩溃的问题。要详细说的话恐怕还得再写一篇文章，但这里需要说明的是大多数是我自己造成的，就比如不小心踢掉电源插头。 幸运的是，EXT 日志文件系统将启动恢复时间缩短到两三分钟。此外，自从我开始使用带日志记录的 EXT3，我从来没有遇到丢失数据的问题。</p><p>EXT3 的日志功能可以关闭，然后其功能就等同于 EXT2 文件系统了。 该日志本身仍然是存在的，只是状态为空且未使用。 只需在 <code>mount</code> 命令中使用文件系统类型参数来重新挂载即可指定为 EXT2。 你可以从命令行执行此操作，但是具体还是取决于你正在使用的文件系统，不过你也可以更改 <code>/etc/fstab</code> 文件中的类型说明符，然后重新启动。 我强烈建议不要将 EXT3 文件系统挂载为 EXT2 ，因为这会有丢失数据和增加恢复时间的潜在可能性。</p><p>EXT2 文件系统可以使用如下命令来通过日志升级到 EXT3 。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tune2fs -j /dev/sda1</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>/dev/sda1</code> 表示驱动器和分区的标识符。同时要注意修改 <code>/etc/fstab</code> 中的文件系统类型标识符并重新挂载分区，或者重启系统以确保修改生效。</p><h3 id="EXT4"><a href="#EXT4" class="headerlink" title="EXT4"></a>EXT4</h3><p><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Ext4">EXT4 文件系统</a>主要提高了性能、可靠性和容量。为了提高可靠性，它新增了元数据和日志校验和。同时为了满足各种关键任务要求，文件系统新增了纳秒级别的时间戳，并在时间戳字段中添加了两个高位来延缓时间戳的 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Year_2038_problem">2038 年问题</a> ，这样 EXT4 文件系统至少可用到 2446 年。</p><p>在 EXT4 中，数据分配从固定块改为<ruby>扩展盘区 <rp>（ </rp><rt>extent</rt> <rp>）</rp></ruby>方式，扩展盘区由硬盘驱动器上的开始和结束位置来描述。这使得可以在单个 inode 指针条目中描述非常长的物理上连续的文件，这可以显著减少描述大文件中所有数据的位置所需的指针数。其它在 EXT4 中已经实施的分配策略可以进一步减少碎片化。</p><p>EXT4 通过将新创建的文件散布在磁盘上，使其不会像早期的 PC 文件系统一样全部聚集在磁盘起始位置，从而减少了碎片。文件分配算法尝试在柱面组中尽可能均匀地散布文件，并且当文件（由于太大）需要分段存储时，使不连续的文件扩展盘区尽可能靠近同一文件中的其他部分，以尽可能减少磁头寻道和电机旋转等待时间。当创建新文件或扩展现有文件时，使用其它策略来预先分配额外的磁盘空间。这有助于确保扩展文件时不会自动导致其分段。新文件不会紧挨这现有文件立即分配空间，这也可以防止现有文件的碎片化。</p><p>除了磁盘上数据的实际位置外，EXT4 使用诸如延迟分配的功能策略，以允许文件系统在分配空间之前收集到所有正在写入磁盘的数据，这可以提高数据空间连续的可能性。</p><p>较旧的 EXT 文件系统（如 EXT2 和 EXT3）可以作为 EXT4 进行 <code>mount</code> ，以使其性能获得较小的提升。但不幸的是，这需要关闭 EXT4 的一些重要的新功能，所以我建议不要这样做。</p><p>自 Fedora 14 以来，EXT4 一直是 Fedora 的默认文件系统。我们可以使用 Fedora 文档中描述的 <a target="_blank" rel="noopener" href="https://docs.fedoraproject.org/en-US/Fedora/14/html/Storage_Administration_Guide/ext4converting.html">流程</a> 将 EXT3 文件系统升级到 EXT4，但是由于仍然存留的之前的 EXT3 元数据结构，它的性能仍将受到影响。从 EXT3 升级到 EXT4 的最佳方法是备份目标文件系统分区上的所有数据，使用 <code>mkfs</code> 命令将空 EXT4 文件系统写入分区，然后从备份中恢复所有数据。</p><h3 id="Inode"><a href="#Inode" class="headerlink" title="Inode"></a>Inode</h3><p>之前介绍过的 inode 是 EXT 文件系统中的元数据的关键组件。 图 2 显示了 inode 和存储在硬盘驱动器上的数据之间的关系。 该图是单个文件的目录和 inode，在这种情况下，可能会产生高度碎片化。 EXT 文件系统可以主动地减少碎片，所以不太可能会看到有这么多间接数据块或扩展盘区的文件。 实际上，你在下面将会看到，EXT 文件系统中的碎片非常低，所以大多数 inode 只使用一个或两个直接数据指针，而不使用间接指针。</p><p><img src="https://linuxcn.img.undefined.today/data/attachment/album/201707/11/154012v1jru7qjxs47fc71.png" alt="inodesanddataallocation-01_0.png"></p><p><em>图 2 ：inode 存储有关每个文件的信息，并使 EXT 文件系统能够查找属于它的所有数据。</em></p><p>inode 不包含文件的名称。通过目录项访问文件，目录项本身就是文件的名称，并包含指向 inode 的指针。该指针的值是 inode 号。文件系统中的每个 inode 都具有唯一的 ID 号，但同一台计算机上的其它文件系统（甚至是相同的硬盘驱动器）中的 inode 可以具有相同的 inode 号。这对 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Hard_link">硬链接</a> 存在影响，但是这个讨论超出了本文的范围。</p><p>inode 包含有关该文件的元数据，包括其类型和权限以及其大小。 inode 还包含 15 个指针的空位，用于描述柱面组数据部分中数据块或扩展盘区的位置和长度。12 个指针提供对数据扩展盘区的直接访问，应该足以满足大多数文件的需求。然而，对于具有明显分段的文件，需要以间接<ruby>节点 <rp>（ </rp><rt>node</rt> <rp>）</rp></ruby>的形式提供一些额外的容量——从技术上讲，这些不是真正的“inode”，所以为了方便起见我在这里使用这个术语“<ruby>节点 <rp>（ </rp><rt>node</rt> <rp>）</rp></ruby>”。</p><p>间接节点是文件系统中的正常数据块，它仅用于描述数据而不用于存储元数据，因此可以支持超过 15 个条目。例如，4K 的块大小可以支持 512 个 4 字节的间接节点，允许单个文件有 <strong>12（直接）+ 512（间接）&#x3D; 524</strong> 个扩展盘区。还支持双重和三重间接节点，但我们大多数人不太可能遇到需要那么多扩展盘区的文件。</p><h3 id="数据碎片"><a href="#数据碎片" class="headerlink" title="数据碎片"></a>数据碎片</h3><p>对于许多较旧的 PC 文件系统，如 FAT（及其所有变体）和 NTFS，碎片一直是导致磁盘性能下降的重大问题。 碎片整理本身就成为一个行业，有各种品牌的整理软件，其效果范围从非常有效到仅仅是微乎其微。</p><p>Linux 的扩展文件系统使用数据分配策略，有助于最小化硬盘驱动器上的文件碎片，并在发生碎片时减少碎片的影响。 你可以使用 EXT 文件系统上的 <code>fsck</code> 命令检查整个文件系统的碎片。 以下示例检查我的主工作站的家目录，只有 1.5％ 的碎片。 确保使用 <code>-n</code> 参数，因为它会防止 <code>fsck</code> 对扫描的文件系统采取任何操作。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fsck -fn /dev/mapper/vg_01-home</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我曾经进行过一些理论计算，以确定磁盘碎片整理是否会产生任何明显的性能提升。 我做了一些假设条件，我使用的磁盘性能数据来自一个新的 300GB 的西部数字硬盘驱动器，具有 2.0ms 的轨到轨寻道时间。 此示例中的文件数是我在计算的当天的文件系统中存在的实际数。 我假设每天有相当大量的碎片化文件（约 20％）会被用到。</p><table><thead><tr><th><strong>全部文件</strong></th><th><strong>271,794</strong></th></tr></thead><tbody><tr><td>碎片率 %</td><td>5.00%</td></tr><tr><td>不连续数</td><td>13,590</td></tr><tr><td></td><td></td></tr><tr><td>% 每天用到的碎片化文件</td><td>20% （假设）</td></tr><tr><td>额外寻道次数</td><td>2,718</td></tr><tr><td>平均寻道时间</td><td>10.90 ms</td></tr><tr><td>每天全部的额外寻道时间</td><td>29.63 sec</td></tr><tr><td></td><td>0.49 min</td></tr><tr><td></td><td></td></tr><tr><td>轨到轨寻道时间</td><td>2.00 ms</td></tr><tr><td>每天全部的额外寻道时间</td><td>5.44 sec</td></tr><tr><td></td><td>0.091 min</td></tr></tbody></table><p><em>表 1: 碎片对磁盘性能的理论影响</em></p><p>我对每天的全部的额外寻道时间进行了两次计算，一次是轨到轨寻道时间，这是由于 EXT 文件分配策略而导致大多数文件最可能的情况，一个是平均寻道时间，我假设这是一个合理的最坏情况。</p><p>从表 1 可以看出，对绝大多数应用程序而言，碎片化甚至对性能适中的硬盘驱动器上的现代 EXT 文件系统的影响是微乎其微的。您可以将您的环境中的数字插入到您自己的类似电子表格中，以了解你对性能影响的期望。这种类型的计算不一定能够代表实际的性能，但它可以提供一些对碎片化及其对系统的理论影响的洞察。</p><p>我的大部分分区的碎片率都在 1.5％ 左右或 1.6％，我有一个分区有 3.3％ 的碎片，但是这是一个大约 128GB 文件系统，具有不到 100 个非常大的 ISO 映像文件；多年来，我扩展过该分区几次，因为它已经太满了。</p><p>这并不是说一些应用的环境并不需要更少的碎片的环境。 EXT 文件系统可以由有经验和知识的管理员小心调整，管理员可以针对特定的工作负载类型调整参数。这个工作可以在文件系统创建的时候或稍后使用 <code>tune2fs</code> 命令时完成。每一次调整变化的结果应进行测试，精心的记录和分析，以确保目标环境的最佳性能。在最坏的情况下，如果性能不能提高到期望的水平，则其他文件系统类型可能更适合特定的工作负载。并记住，在单个主机系统上混用文件系统类型以匹配每个文件系统上的不同负载是常见的。</p><p>由于大多数 EXT 文件系统的碎片数量较少，因此无需进行碎片整理。目前，EXT 文件系统没有安全的碎片整理工具。有几个工具允许你检查单个文件的碎片程度或文件系统中剩余可用空间的碎片程度。有一个工具，<code>e4defrag</code>，它可以对允许使用的剩余可用空间、目录或文件系统进行碎片整理。顾名思义，它只适用于 EXT4 文件系统中的文件，并且它还有一其它的些限制。</p><p>如果有必要在 EXT 文件系统上执行完整的碎片整理，则只有一种方法能够可靠地工作。你必须将文件系统中的所有要进行碎片整理的文件移动从而进行碎片整理，并在确保安全复制到其他位置后将其删除。如果可能，你可以增加文件系统的大小，以帮助减少将来的碎片。然后将文件复制回目标文件系统。但是其实即使这样也不能保证所有文件都被完全去碎片化。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>EXT 文件系统在一些 Linux 发行版本上作为默认文件系统已经超过二十多年了。它们用最少的维护代价提供了稳定性、高可用性、可靠性和性能。我尝试过一些其它的文件系统但最终都还是回归到 EXT。每一个我在工作中使用到 Linux 的地方都使用到了 EXT 文件系统，同时我发现了它们适用于任何主流负载。毫无疑问，EXT4 文件系统应该被用于大部分的 Linux 文件系统上，除非我们有明显需要使用其它文件系统的理由。</p><hr><p>作者简介：</p><p>David Both - David Both 是一名 Linux 于开源的贡献者，目前居住在北卡罗莱纳州的罗利。他从事 IT 行业有 40 余年并在 IBM 中从事 OS&#x2F;2 培训约 20 余年。在 IBM 就职期间，他在 1981 年为最早的 IBM PC 写了一个培训课程。他已经为红帽教授了 RHCE 课程，曾在 MCI Worldcom，思科和北卡罗来纳州工作。 他使用 Linux 和开源软件工作了近 20 年。</p><hr><p>via: <a target="_blank" rel="noopener" href="https://opensource.com/article/17/5/introduction-ext4-filesystem">https://opensource.com/article/17/5/introduction-ext4-filesystem</a></p><p>作者：<a target="_blank" rel="noopener" href="https://opensource.com/users/dboth">David Both</a> 译者：<a target="_blank" rel="noopener" href="https://github.com/chenxinlong">chenxinlong</a> 校对：<a target="_blank" rel="noopener" href="https://github.com/wxy">wxy</a></p><p>本文由 <a target="_blank" rel="noopener" href="https://github.com/LCTT/TranslateProject">LCTT</a> 原创编译，<a target="_blank" rel="noopener" href="https://linux.cn/">Linux中国</a> 荣誉推出</p></div></div></div><div class="footer"><p class="footer-copyright"><span>Powered by <a target="_blank" href="https://hexo.io">Hexo</a></span> <span>Theme <a target="_blank" href="https://github.com/tinkink-co/hexo-theme-terminal">Terminal</a></span><script type="text/javascript" src="https://cdn.staticfile.net/jquery/3.4.1/jquery.min.js"></script><script>getCDNinfo=function(){$.ajax({url:"/cdn-cgi/trace",success:function(a,n){let i="Antananarivo, Madagascar - (TNR);Cape Town, South Africa - (CPT);Casablanca, Morocco - (CMN);Dar Es Salaam, Tanzania - (DAR);Djibouti City, Djibouti - (JIB);Durban, South Africa - (DUR);Johannesburg, South Africa - (JNB);Kigali, Rwanda - (KGL);Lagos, Nigeria - (LOS);Luanda, Angola - (LAD);Maputo, MZ - (MPM);Mombasa, Kenya - (MBA);Port Louis, Mauritius - (MRU);Réunion, France - (RUN);Bangalore, India - (BLR);Bangkok, Thailand - (BKK);Bandar Seri Begawan, Brunei - (BWN);Cebu, Philippines - (CEB);Chengdu, China - (CTU);Chennai, India - (MAA);Chittagong, Bangladesh - (CGP);Chongqing, China - (CKG);Colombo, Sri Lanka - (CMB);Dhaka, Bangladesh - (DAC);Dongguan, China - (SZX);Foshan, China - (FUO);Fuzhou, China - (FOC);Guangzhou, China - (CAN);Hangzhou, China - (HGH);Hanoi, Vietnam - (HAN);Hengyang, China - (HNY);Ho Chi Minh City, Vietnam - (SGN);Hong Kong - (HKG);Hyderabad, India - (HYD);Islamabad, Pakistan - (ISB);Jakarta, Indonesia - (CGK);Jinan, China - (TNA);Karachi, Pakistan - (KHI);Kathmandu, Nepal - (KTM);Kolkata, India - (CCU);Kuala Lumpur, Malaysia - (KUL);Lahore, Pakistan - (LHE);Langfang, China - (NAY);Luoyang, China - (LYA);Macau - (MFM);Malé, Maldives - (MLE);Manila, Philippines - (MNL);Mumbai, India - (BOM);Nagpur, India - (NAG);Nanning, China - (NNG);New Delhi, India - (DEL);Osaka, Japan - (KIX);Phnom Penh, Cambodia - (PNH);Qingdao, China - (TAO);Seoul, South Korea - (ICN);Shanghai, China - (SHA);Shenyang, China - (SHE);Shijiazhuang, China - (SJW);Singapore, Singapore - (SIN);Suzhou, China - (SZV);Taipei - (TPE);Thimphu, Bhutan - (PBH);Tianjin, China - (TSN);Tokyo, Japan - (NRT);Ulaanbaatar, Mongolia - (ULN);Vientiane, Laos - (VTE);Wuhan, China - (WUH);Wuxi, China - (WUX);Xi'an, China - (XIY);Yerevan, Armenia - (EVN);Zhengzhou, China - (CGO);Zuzhou, China - (CSX);Amsterdam, Netherlands - (AMS);Athens, Greece - (ATH);Barcelona, Spain - (BCN);Belgrade, Serbia - (BEG);Berlin, Germany - (TXL);Brussels, Belgium - (BRU);Bucharest, Romania - (OTP);Budapest, Hungary - (BUD);Chișinău, Moldova - (KIV);Copenhagen, Denmark - (CPH);Cork, Ireland -  (ORK);Dublin, Ireland - (DUB);Düsseldorf, Germany - (DUS);Edinburgh, United Kingdom - (EDI);Frankfurt, Germany - (FRA);Geneva, Switzerland - (GVA);Gothenburg, Sweden - (GOT);Hamburg, Germany - (HAM);Helsinki, Finland - (HEL);Istanbul, Turkey - (IST);Kyiv, Ukraine - (KBP);Lisbon, Portugal - (LIS);London, United Kingdom - (LHR);Luxembourg City, Luxembourg - (LUX);Madrid, Spain - (MAD);Manchester, United Kingdom - (MAN);Marseille, France - (MRS);Milan, Italy - (MXP);Moscow, Russia - (DME);Munich, Germany - (MUC);Nicosia, Cyprus - (LCA);Oslo, Norway - (OSL);Paris, France - (CDG);Prague, Czech Republic - (PRG);Reykjavík, Iceland - (KEF);Riga, Latvia - (RIX);Rome, Italy - (FCO);Saint Petersburg, Russia - (LED);Sofia, Bulgaria - (SOF);Stockholm, Sweden - (ARN);Tallinn, Estonia - (TLL);Thessaloniki, Greece - (SKG);Vienna, Austria - (VIE);Vilnius, Lithuania - (VNO);Warsaw, Poland - (WAW);Zagreb, Croatia - (ZAG);Zürich, Switzerland - (ZRH);Arica, Chile - (ARI);Asunción, Paraguay - (ASU);Bogotá, Colombia - (BOG);Buenos Aires, Argentina - (EZE);Curitiba, Brazil - (CWB);Fortaleza, Brazil - (FOR);Guatemala City, Guatemala - (GUA);Lima, Peru - (LIM);Medellín, Colombia - (MDE);Panama City, Panama - (PTY);Porto Alegre, Brazil - (POA);Quito, Ecuador - (UIO);Rio de Janeiro, Brazil - (GIG);São Paulo, Brazil - (GRU);Santiago, Chile - (SCL);Willemstad, Curaçao - (CUR);St. George's, Grenada - (GND);Amman, Jordan - (AMM);Baghdad, Iraq - (BGW);Baku, Azerbaijan - (GYD);Beirut, Lebanon - (BEY);Doha, Qatar - (DOH);Dubai, United Arab Emirates - (DXB);Kuwait City, Kuwait - (KWI);Manama, Bahrain - (BAH);Muscat, Oman - (MCT);Ramallah - (ZDM);Riyadh, Saudi Arabia - (RUH);Tel Aviv, Israel - (TLV);Ashburn, VA, United States - (IAD);Atlanta, GA, United States - (ATL);Boston, MA, United States - (BOS);Buffalo, NY, United States - (BUF);Calgary, AB, Canada - (YYC);Charlotte, NC, United States - (CLT);Chicago, IL, United States - (ORD);Columbus, OH, United States - (CMH);Dallas, TX, United States - (DFW);Denver, CO, United States - (DEN);Detroit, MI, United States - (DTW);Honolulu, HI, United States - (HNL);Houston, TX, United States - (IAH);Indianapolis, IN, United States - (IND);Jacksonville, FL, United States - (JAX);Kansas City, MO, United States - (MCI);Las Vegas, NV, United States - (LAS);Los Angeles, CA, United States - (LAX);McAllen, TX, United States - (MFE);Memphis, TN, United States - (MEM);Mexico City, Mexico - (MEX);Miami, FL, United States - (MIA);Minneapolis, MN, United States - (MSP);Montgomery, AL, United States - (MGM);Montréal, QC, Canada - (YUL);Nashville, TN, United States - (BNA);Newark, NJ, United States - (EWR);Norfolk, VA, United States - (ORF);Omaha, NE, United States - (OMA);Philadelphia, United States - (PHL);Phoenix, AZ, United States - (PHX);Pittsburgh, PA, United States - (PIT);Port-Au-Prince, Haiti - (PAP);Portland, OR, United States - (PDX);Queretaro, MX, Mexico - (QRO);Richmond, Virginia - (RIC);Sacramento, CA, United States - (SMF);Salt Lake City, UT, United States - (SLC);San Diego, CA, United States - (SAN);San Jose, CA, United States - (SJC);Saskatoon, SK, Canada - (YXE);Seattle, WA, United States - (SEA);St. Louis, MO, United States - (STL);Tampa, FL, United States - (TPA);Toronto, ON, Canada - (YYZ);Vancouver, BC, Canada - (YVR);Tallahassee, FL, United States - (TLH);Winnipeg, MB, Canada - (YWG);Adelaide, SA, Australia - (ADL);Auckland, New Zealand - (AKL);Brisbane, QLD, Australia - (BNE);Melbourne, VIC, Australia - (MEL);Noumea, New caledonia - (NOU);Perth, WA, Australia - (PER);Sydney, NSW, Australia - (SYD)".split(";"),e=a.split("colo=")[1].split("\n")[0],t=(a.split("colo=")[1].split("\n")[0],a.split("tls=")[1].split("\n")[0]),o=a.split("http=")[1].split("\n")[0],s=a.split("sni=")[1].split("\n")[0],r=a.split("ip=")[1].split("\n")[0],l=a.split("uag=")[1].split("\n")[0];for(var d=0;d<i.length;d++)if(-1!=i[d].indexOf(e)){document.getElementById("cdn").innerHTML=i[d];break}document.getElementById("tls").innerHTML=t,document.getElementById("http").innerHTML=o,document.getElementById("sni").innerHTML=s,document.getElementById("ip").innerHTML=r,document.getElementById("useragent").innerHTML=l}})},$(document).ready((function(){getCDNinfo()}))</script></p><p style="text-align:center">感谢陪伴与布道，开源之火不灭。​</p><p style="text-align:center"><script>document.write("本次加载耗时: "+(performance.getEntriesByType("navigation").reduce((e,r)=>e+r.responseEnd-r.startTime,0)+performance.getEntriesByType("resource").reduce((e,r)=>e+r.responseEnd-r.startTime,0)).toFixed(0)+"ms")</script></p><p style="text-align:center">当前 SNI 状态： <span id="sni">正在统计！或可能被浏览器防追踪拦截！</span></p><p style="text-align:center">当前 TLS 版本： <span id="tls">正在统计！或可能被浏览器防追踪拦截！</span></p><p style="text-align:center">当前 HTTP 版本： <span id="http">正在统计！或可能被浏览器防追踪拦截！</span></p><p style="text-align:center">当前您的客户端 IP 是： <span id="ip">正在统计！或可能被浏览器防追踪拦截！</span></p><p style="text-align:center">当前分配的 CDN 节点是: <span id="cdn">正在统计！或可能被浏览器防追踪拦截！</span></p><p style="text-align:center">您的 UserAgent 信息是: <span id="useragent">正在统计！或可能被浏览器防追踪拦截！</span></p><p></p></div></div></body></html>