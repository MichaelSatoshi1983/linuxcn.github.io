<!doctype html><html lang="en"><head><meta name="msvalidate.01" content="D404690CEFCB54C7762AC84935B99171"><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?6618da70c90c8744eead2e9371fb5077";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><script type="text/javascript">!function(t,e,n,c,s,a,r){t[n]=t[n]||function(){(t[n].q=t[n].q||[]).push(arguments)},(a=e.createElement(c)).async=1,a.src="https://www.clarity.ms/tag/s5f3f0tojf",(r=e.getElementsByTagName(c)[0]).parentNode.insertBefore(a,r)}(window,document,"clarity","script")</script><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta http-equiv="X-UA-Compatible" content="ie=edge"><link rel="stylesheet" href="/styles/base.css"><link rel="stylesheet" href="/styles/theme.css"><link rel="shortcut icon" href="/favicon.png"><title>互联网扫描器 ZMap 完全手册 - 归墟星火集</title><meta name="generator" content="Hexo 7.3.0"></head><body><div class="header-title"><span class="header-light"></span> <span class="header-light"></span> <span class="header-light"></span> <span>归墟星火集 linuxcn.undefined.today<span></span></span></div><div class="container"><ul class="nav"><li><a href="/">首页</a></li><li><a href="/about/">关于</a></li><li><a target="_blank" rel="noopener" href="https://undefined.today/">Blog</a></li></ul><div class="content"><div class="post-container"><div class="post-header"><span class="ui-tips">标题：</span><h1 class="ui-keyword post-title">互联网扫描器 ZMap 完全手册</h1><span class="post-date">2015-07-21</span></div><div class="post-header"><span class="ui-tips">分类：</span> <a href="/categories/%E6%8A%80%E6%9C%AF/">技术</a></div><div class="post-header"><span class="ui-tips">标签：</span> <a href="/tags/%E6%89%AB%E6%8F%8F%E5%99%A8/">扫描器</a> <a href="/tags/ZMap/">ZMap</a></div><div class="post-content"><h3 id="初识-ZMap"><a href="#初识-ZMap" class="headerlink" title="初识 ZMap"></a>初识 ZMap</h3><p><img src="https://linuxcn.img.undefined.today/data/attachment/album/201507/21/003713ar4fq4gq4g7zqb4q.png"></p><p>ZMap被设计用来针对整个IPv4地址空间或其中的大部分实施综合扫描的工具。ZMap是研究者手中的利器，但在运行ZMap时，请注意，您很有可能正在以每秒140万个包的速度扫描整个IPv4地址空间 。我们建议用户即使在实施小范围扫描之前，也联系一下本地网络的管理员并参考我们列举的<a href="/article-5860-1.html#bestpractices">最佳扫描体验</a>。</p><p>默认情况下，ZMap会对于指定端口实施尽可能大速率的TCP SYN扫描。较为保守的情况下，对10,000个随机的地址的80端口以10Mbps的速度扫描，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ zmap --bandwidth=10M --target-port=80 --max-targets=10000 --output-file=results.csv </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>或者更加简洁地写成：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ zmap -B 10M -p 80 -n 10000 -o results.csv</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>ZMap也可用于扫描特定子网或CIDR地址块。例如，仅扫描10.0.0.0&#x2F;8和192.168.0.0&#x2F;16的80端口，运行指令如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">zmap -p 80 -o results.csv 10.0.0.0/8 192.168.0.0/16</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如果扫描进行的顺利，ZMap会每秒输出类似以下内容的状态更新：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0% (1h51m left); send: 28777 562 Kp/s (560 Kp/s avg); recv: 1192 248 p/s (231 p/s avg); hits: 0.04%</span><br><span class="line">0% (1h51m left); send: 34320 554 Kp/s (559 Kp/s avg); recv: 1442 249 p/s (234 p/s avg); hits: 0.04%</span><br><span class="line">0% (1h50m left); send: 39676 535 Kp/s (555 Kp/s avg); recv: 1663 220 p/s (232 p/s avg); hits: 0.04%</span><br><span class="line">0% (1h50m left); send: 45372 570 Kp/s (557 Kp/s avg); recv: 1890 226 p/s (232 p/s avg); hits: 0.04%</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这些更新信息提供了扫描的即时状态并表示成：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">完成进度% (剩余时间); send: 发出包的数量 即时速率 (平均发送速率); recv: 接收包的数量 接收率 (平均接收率); hits: 命中率</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如果您不知道您所在网络能支持的扫描速率，您可能要尝试不同的扫描速率和带宽限制直到扫描效果开始下降，借此找出当前网络能够支持的最快速度。</p><p>默认情况下，ZMap会输出不同IP地址的列表（例如，根据SYN ACK数据包的情况），像下面这样。其<a href="/article-5860-1.html#output">输出结果</a>还有几种附加的格式（如，JSON和Redis），可以用作生成<a href="/article-5860-1.html#verbosity">程序可解析的扫描统计</a>。 同样，可以指定附加的<a href="/article-5860-1.html#outputfields">输出字段</a>并使用<a href="/article-5860-1.html#outputfilter">输出过滤</a>来过滤输出的结果。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">115.237.116.119</span><br><span class="line">23.9.117.80</span><br><span class="line">207.118.204.141</span><br><span class="line">217.120.143.111</span><br><span class="line">50.195.22.82</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我们强烈建议您使用<a href="/article-5860-1.html#blacklisting">黑名单文件</a>，以排除预留的&#x2F;未分配的IP地址空间（如，RFC1918 规定的私有地址、组播地址），以及网络中需要排除在您扫描之外的地址。默认情况下，ZMap将采用位于 <code>/etc/zmap/blacklist.conf</code>的这个简单的<a href="/article-5860-1.html#blacklisting">黑名单文件</a>中所包含的预留和未分配地址。如果您需要某些特定设置，比如每次运行ZMap时的最大带宽或<a href="/article-5860-1.html#blacklisting">黑名单文件</a>，您可以在文件<code>/etc/zmap/zmap.conf</code>中指定或使用自定义<a href="/article-5860-1.html#config">配置文件</a>。</p><p>如果您正试图解决扫描的相关问题，有几个选项可以帮助您调试。首先，您可以通过添加<code>--dryrun</code>实施<a href="/article-5860-1.html#dryrun">预扫</a>，以此来分析包可能会发送到网络的何处。此外，还可以通过设置’–verbosity&#x3D;n&#96;来更改<a href="/article-5860-1.html#verbosity">日志详细程度</a>。</p><h3 id="最佳扫描体验"><a href="#最佳扫描体验" class="headerlink" title="最佳扫描体验"></a>最佳扫描体验</h3><p>我们为针对互联网进行扫描的研究者提供了一些建议，以此来引导养成良好的互联网合作氛围。</p><ul><li>密切协同本地的网络管理员，以减少风险和调查</li><li>确认扫描不会使本地网络或上游供应商瘫痪</li><li>在发起扫描的源地址的网页和DNS条目中申明你的扫描是善意的</li><li>明确解释你的扫描中所有连接的目的和范围</li><li>提供一个简单的退出扫描的方法并及时响应请求</li><li>实施扫描时，不使用比研究对象需求更大的扫描范围或更快的扫描频率</li><li>如果可以，将扫描流量分布到不同的时间或源地址上</li></ul><p>即使不声明，使用扫描的研究者也应该避免利用漏洞或访问受保护的资源，并遵守其辖区内任何特殊的法律规定。</p><h3 id="命令行参数"><a href="#命令行参数" class="headerlink" title="命令行参数"></a>命令行参数</h3><h4 id="通用选项"><a href="#通用选项" class="headerlink" title="通用选项"></a>通用选项</h4><p>这些选项是实施简单扫描时最常用的选项。我们注意到某些选项取决于所使用的<a href="/article-5860-1.html#probemodule">探测模块</a>或<a href="/article-5860-1.html#outputmodule">输出模块</a>（如，在实施ICMP Echo扫描时是不需要使用目的端口的）。</p><p><strong>-p, –target-port&#x3D;port</strong></p><p>要扫描的目标TCP端口号（例如，443）</p><p><strong>-o, –output-file&#x3D;name</strong></p><p>将结果写入该文件，使用<code>-</code>代表输出到标准输出。</p><p><strong>-b, –blacklist-file&#x3D;path</strong></p><p>文件中被排除的子网使用CIDR表示法（如192.168.0.0&#x2F;16），一个一行。建议您使用此方法排除RFC 1918地址、组播地址、IANA预留空间等IANA专用地址。在conf&#x2F;blacklist.example中提供了一个以此为目的示例黑名单文件。</p><h4 id="扫描选项"><a href="#扫描选项" class="headerlink" title="扫描选项"></a>扫描选项</h4><p><strong>-n, –max-targets&#x3D;n</strong></p><p>限制探测目标的数量。后面跟的可以是一个数字（例如’-n 1000<code>），或可扫描地址空间的百分比（例如，</code>-n 0.1％&#96;，不包括黑名单）</p><p><strong>-N, –max-results&#x3D;n</strong></p><p>收到多少结果后退出</p><p><strong>-t, –max-runtime&#x3D;secs</strong></p><p>限制发送报文的时间</p><p><strong>-r, –rate&#x3D;pps</strong></p><p>设置发包速率，以包&#x2F;秒为单位</p><p><strong>-B, –bandwidth&#x3D;bps</strong></p><p>以比特&#x2F;秒设置传输速率（支持使用后缀G，M或K（如<code>-B 10M</code>就是速度10 mbps）的。设置会覆盖<code>--rate</code>。</p><p><strong>-c, –cooldown-time&#x3D;secs</strong></p><p>发送完成后等待多久继续接收回包（默认值&#x3D; 8）</p><p><strong>-e, –seed&#x3D;n</strong></p><p>地址排序种子。如果要用多个ZMap以相同的顺序扫描地址，那么就可以使用这个参数。</p><p><strong>–shards&#x3D;n</strong></p><p>将扫描分片&#x2F;区，使其可多个ZMap中执行（默认值&#x3D; 1）。启用分片时，<code>--seed</code>参数是必需的。</p><p><strong>–shard&#x3D;n</strong></p><p>选择扫描的分片（默认值&#x3D; 0）。n的范围在[0，N)，其中N为碎片的总数。启用分片时，<code>--seed</code>参数是必需的。</p><p><strong>-T, –sender-threads&#x3D;n</strong></p><p>用于发送数据包的线程数（默认值&#x3D; 1）</p><p><strong>-P, –probes&#x3D;n</strong></p><p>发送到每个IP的探测数（默认值&#x3D; 1）</p><p><strong>-d, –dryrun</strong></p><p>用标准输出打印出每个包，而不是将其发送（用于调试）</p><h4 id="网络选项"><a href="#网络选项" class="headerlink" title="网络选项"></a>网络选项</h4><p><strong>-s, –source-port&#x3D;port|range</strong></p><p>发送数据包的源端口</p><p><strong>-S, –source-ip&#x3D;ip|range</strong></p><p>发送数据包的源地址。可以仅仅是一个IP，也可以是一个范围（如，10.0.0.1-10.0.0.9）</p><p><strong>-G, –gateway-mac&#x3D;addr</strong></p><p>数据包发送到的网关MAC地址（用以防止自动检测不工作的情况）</p><p><strong>-i, –interface&#x3D;name</strong></p><p>使用的网络接口</p><h4 id="探测选项"><a href="#探测选项" class="headerlink" title="探测选项"></a>探测选项</h4><p>ZMap允许用户指定并添加自己所需要的<a href="/article-5860-1.html#probemodule">探测模块</a>。 探测模块的职责就是生成要发送的探测包，并处理主机回复的响应包。</p><p><strong>–list-probe-modules</strong></p><p>列出可用探测模块（如tcp_synscan）</p><p><strong>-M, –probe-module&#x3D;name</strong></p><p>选择<a href="/article-5860-1.html#probemodule">探测模块</a>（默认值&#x3D; tcp_synscan）</p><p><strong>–probe-args&#x3D;args</strong></p><p>向模块传递参数</p><p><strong>–list-output-fields</strong></p><p>列出可用的输出模块</p><h4 id="输出选项"><a href="#输出选项" class="headerlink" title="输出选项"></a>输出选项</h4><p>ZMap允许用户指定和编写他们自己的<a href="/article-5860-1.html#outputmodule">输出模块</a>。输出模块负责处理由探测模块返回的字段，并将它们输出给用户。用户可以指定输出的字段，并过滤相应字段。</p><p><strong>–list-output-modules</strong></p><p>列出可用输出模块（如tcp_synscan）</p><p><strong>-O, –output-module&#x3D;name</strong></p><p>选择<a href="/article-5860-1.html#outputmodule">输出模块</a>（默认值为csv）</p><p><strong>–output-args&#x3D;args</strong></p><p>传递给输出模块的参数</p><p><strong>-f, –output-fields&#x3D;fields</strong></p><p>输出的字段列表，以逗号分割</p><p><strong>–output-filter</strong></p><p>指定输出<a href="/article-5860-1.html#outputfilter">过滤器</a>对<a href="/article-5860-1.html#probemodule">探测模块</a>定义字段进行过滤</p><h4 id="附加选项"><a href="#附加选项" class="headerlink" title="附加选项"></a>附加选项</h4><p><strong>-C, –config&#x3D;filename</strong></p><p>加载<a href="/article-5860-1.html#config">配置文件</a>，可以指定其他路径。</p><p><strong>-q, –quiet</strong></p><p>不必每秒刷新输出</p><p><strong>-g, –summary</strong></p><p>在扫描结束后打印配置和结果汇总信息</p><p><strong>-v, –verbosity&#x3D;n</strong></p><p>日志详细程度（0-5，默认值&#x3D; 3）</p><p><strong>-h, –help</strong></p><p>打印帮助并退出</p><p><strong>-V, –version</strong></p><p>打印版本并退出</p><h3 id="附加信息"><a href="#附加信息" class="headerlink" title="附加信息"></a>附加信息</h3><h4 id="TCP-SYN-扫描"><a href="#TCP-SYN-扫描" class="headerlink" title="TCP SYN 扫描"></a>TCP SYN 扫描</h4><p>在执行TCP SYN扫描时，ZMap需要指定一个目标端口，也支持指定发起扫描的源端口范围。</p><p><strong>-p, –target-port&#x3D;port</strong></p><p>扫描的TCP端口（例如 443）</p><p><strong>-s, –source-port&#x3D;port|range</strong></p><p>发送扫描数据包的源端口（例如 40000-50000）</p><p><strong>警示！</strong> ZMap基于Linux内核使用RST包来应答SYN&#x2F;ACK包响应，以关闭扫描器打开的连接。ZMap是在Ethernet层完成包的发送的，这样做是为了减少跟踪打开的TCP连接和路由寻路带来的内核开销。因此，如果您有跟踪连接建立的防火墙规则，如类似于<code>-A INPUT -m state --state RELATED,ESTABLISHED -j ACCEPT</code>的netfilter规则，将阻止SYN&#x2F;ACK包到达内核。这不会妨碍到ZMap记录应答，但它会阻止RST包被送回，最终被扫描主机的连接会一直打开，直到超时后断开。我们强烈建议您在执行ZMap时，选择一组主机上未使用且防火墙允许访问的端口，加在<code>-s</code>后（如 <code>-s &#39;50000-60000&#39;</code> ）。</p><h4 id="ICMP-Echo-请求扫描"><a href="#ICMP-Echo-请求扫描" class="headerlink" title="ICMP Echo 请求扫描"></a>ICMP Echo 请求扫描</h4><p>虽然在默认情况下ZMap执行的是TCP SYN扫描，但它也支持使用ICMP echo请求扫描。在这种扫描方式下ICMP echo请求包被发送到每个主机，并以收到ICMP应答包作为答复。实施ICMP扫描可以通过选择icmp_echoscan扫描模块来执行，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ zmap --probe-module=icmp_echoscan</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="UDP-数据报扫描"><a href="#UDP-数据报扫描" class="headerlink" title="UDP 数据报扫描"></a>UDP 数据报扫描</h4><p>ZMap还额外支持UDP探测，它会发出任意UDP数据报给每个主机，并接收UDP或ICMP不可达的应答。ZMap可以通过使用–probe-args命令行选项来设置四种不同的UDP载荷。这些是：可在命令行设置可打印的ASCII 码的‘text’载荷和十六进制载荷的‘hex’，外部文件中包含载荷的‘file’，和通过动态字段生成的载荷的‘template’。为了得到UDP响应，请使用-f参数确保您指定的“data”字段处于输出范围。</p><p>下面的例子将发送两个字节’ST’，即PCAnwywhere的’status’请求，到UDP端口5632。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ zmap -M udp -p 5632 --probe-args=text:ST -N 100 -f saddr,data -o -</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>下面的例子将发送字节“0X02”，即SQL Server的’client broadcast’请求，到UDP端口1434。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ zmap -M udp -p 1434 --probe-args=hex:02 -N 100 -f saddr,data -o -</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>下面的例子将发送一个NetBIOS状态请求到UDP端口137。使用一个ZMap自带的载荷文件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ zmap -M udp -p 1434 --probe-args=file:netbios_137.pkt -N 100 -f saddr,data -o -</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>下面的例子将发送SIP的’OPTIONS’请求到UDP端口5060。使用附ZMap自带的模板文件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ zmap -M udp -p 1434 --probe-args=file:sip_options.tpl -N 100 -f saddr,data -o -</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>UDP载荷模板仍处于实验阶段。当您在更多的使用一个以上的发送线程（-T）时可能会遇到崩溃和一个明显的相比静态载荷性能降低的表现。模板仅仅是一个由一个或多个使用${}将字段说明封装成序列构成的载荷文件。某些协议，特别是SIP，需要载荷来反射包中的源和目的包。其他协议，如portmapper和DNS，每个请求包含的字段应该是随机的，或降低被Zamp扫描的多宿主系统的风险。</p><p>以下的载荷模板将发送SIP OPTIONS请求到每一个目的地：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">OPTIONS sip:$&#123;RAND_ALPHA=8&#125;@$&#123;DADDR&#125; SIP/2.0</span><br><span class="line">Via: SIP/2.0/UDP $&#123;SADDR&#125;:$&#123;SPORT&#125;;branch=$&#123;RAND_ALPHA=6&#125;.$&#123;RAND_DIGIT=10&#125;;rport;alias</span><br><span class="line">From: sip:$&#123;RAND_ALPHA=8&#125;@$&#123;SADDR&#125;:$&#123;SPORT&#125;;tag=$&#123;RAND_DIGIT=8&#125;</span><br><span class="line">To: sip:$&#123;RAND_ALPHA=8&#125;@$&#123;DADDR&#125;</span><br><span class="line">Call-ID: $&#123;RAND_DIGIT=10&#125;@$&#123;SADDR&#125;</span><br><span class="line">CSeq: 1 OPTIONS</span><br><span class="line">Contact: sip:$&#123;RAND_ALPHA=8&#125;@$&#123;SADDR&#125;:$&#123;SPORT&#125;</span><br><span class="line">Content-Length: 0</span><br><span class="line">Max-Forwards: 20</span><br><span class="line">User-Agent: $&#123;RAND_ALPHA=8&#125;</span><br><span class="line">Accept: text/plain</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>就像在上面的例子中展示的那样，注意每行行末以\r\n结尾，请求以\r\n\r\n结尾，大多数SIP实现都可以正确处理它。一个可以工作的例子放在ZMap的examples&#x2F;udp-payloads目录下 (sip_options.tpl).</p><p>当前实现了下面的模板字段：</p><ul><li><strong>SADDR</strong>: 源IP地址的点分十进制格式</li><li><strong>SADDR_N</strong>: 源IP地址的网络字节序格式</li><li><strong>DADDR</strong>: 目的IP地址的点分十进制格式</li><li><strong>DADDR_N</strong>: 目的IP地址的网络字节序格式</li><li><strong>SPORT</strong>: 源端口的ascii格式</li><li><strong>SPORT_N</strong>: 源端口的网络字节序格式</li><li><strong>DPORT</strong>: 目的端口的ascii格式</li><li><strong>DPORT_N</strong>: 目的端口的网络字节序格式</li><li><strong>RAND_BYTE</strong>: 随机字节(0-255)，长度由&#x3D;(length) 参数决定</li><li><strong>RAND_DIGIT</strong>: 随机数字0-9，长度由&#x3D;(length) 参数决定</li><li><strong>RAND_ALPHA</strong>: 随机大写字母A-Z，长度由&#x3D;(length) 参数决定</li><li><strong>RAND_ALPHANUM</strong>: 随机大写字母A-Z和随机数字0-9，长度由&#x3D;(length) 参数决定</li></ul><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><p>ZMap支持使用配置文件来代替在命令行上指定所有要求的选项。配置中可以通过每行指定一个长名称的选项和对应的值来创建：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">interface &quot;eth1&quot;</span><br><span class="line">source-ip 1.1.1.4-1.1.1.8</span><br><span class="line">gateway-mac b4:23:f9:28:fa:2d # upstream gateway</span><br><span class="line">cooldown-time 300 # seconds</span><br><span class="line">blacklist-file /etc/zmap/blacklist.conf</span><br><span class="line">output-file ~/zmap-output</span><br><span class="line">quiet</span><br><span class="line">summary</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后ZMap就可以按照配置文件并指定一些必要的附加参数运行了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ zmap --config=~/.zmap.conf --target-port=443</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="详细"><a href="#详细" class="headerlink" title="详细"></a>详细</h3><p>ZMap可以在屏幕上生成多种类型的输出。默认情况下，Zmap将每隔1秒打印出相似的基本进度信息。可以通过设置<code>--quiet</code>来禁用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0:01 12%; send: 10000 done (15.1 Kp/s avg); recv: 144 143 p/s (141 p/s avg); hits: 1.44%</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>ZMap同样也可以根据扫描配置打印如下消息，可以通过’–verbosity&#96;参数加以控制。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Aug 11 16:16:12.813 [INFO] zmap: started</span><br><span class="line">Aug 11 16:16:12.817 [DEBUG] zmap: no interface provided. will use eth0</span><br><span class="line">Aug 11 16:17:03.971 [DEBUG] cyclic: primitive root: 3489180582</span><br><span class="line">Aug 11 16:17:03.971 [DEBUG] cyclic: starting point: 46588</span><br><span class="line">Aug 11 16:17:03.975 [DEBUG] blacklist: 3717595507 addresses allowed to be scanned</span><br><span class="line">Aug 11 16:17:03.975 [DEBUG] send: will send from 1 address on 28233 source ports</span><br><span class="line">Aug 11 16:17:03.975 [DEBUG] send: using bandwidth 10000000 bits/s, rate set to 14880 pkt/s</span><br><span class="line">Aug 11 16:17:03.985 [DEBUG] recv: thread started</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>ZMap还支持在扫描之后打印出一个的可grep的汇总信息，类似于下面这样，可以通过调用<code>--summary</code>来实现。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">cnf target-port             443</span><br><span class="line">cnf source-port-range-begin         32768</span><br><span class="line">cnf source-port-range-end           61000</span><br><span class="line">cnf source-addr-range-begin         1.1.1.4</span><br><span class="line">cnf source-addr-range-end           1.1.1.8</span><br><span class="line">cnf maximum-packets             4294967295</span><br><span class="line">cnf maximum-runtime             0</span><br><span class="line">cnf permutation-seed            0</span><br><span class="line">cnf cooldown-period             300</span><br><span class="line">cnf send-interface              eth1</span><br><span class="line">cnf rate                    45000</span><br><span class="line">env nprocessors             16</span><br><span class="line">exc send-start-time             Fri Jan 18 01:47:35 2013</span><br><span class="line">exc send-end-time               Sat Jan 19 00:47:07 2013</span><br><span class="line">exc recv-start-time             Fri Jan 18 01:47:35 2013</span><br><span class="line">exc recv-end-time               Sat Jan 19 00:52:07 2013</span><br><span class="line">exc sent                    3722335150</span><br><span class="line">exc blacklisted             572632145</span><br><span class="line">exc first-scanned               1318129262</span><br><span class="line">exc hit-rate                0.874102</span><br><span class="line">exc synack-received-unique          32537000</span><br><span class="line">exc synack-received-total           36689941</span><br><span class="line">exc synack-cooldown-received-unique     193</span><br><span class="line">exc synack-cooldown-received-total      1543</span><br><span class="line">exc rst-received-unique         141901021</span><br><span class="line">exc rst-received-total          166779002</span><br><span class="line">adv source-port-secret          37952</span><br><span class="line">adv permutation-gen             4215763218</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="结果输出"><a href="#结果输出" class="headerlink" title="结果输出"></a>结果输出</h3><p>ZMap可以通过<strong>输出模块</strong>生成不同格式的结果。默认情况下，ZMap只支持<strong>csv</strong>的输出，但是可以通过编译支持<strong>redis</strong>和<strong>json</strong> 。可以使用<strong>输出过滤</strong>来过滤这些发送到输出模块上的结果。输出模块输出的字段由用户指定。默认情况如果没有指定输出文件，ZMap将以csv格式返回结果，而不会生成特定结果。也可以编写自己的输出模块;请参阅<a href="/article-5860-1.html#exteding">编写输出模块</a>。</p><p><strong>-o, –output-file&#x3D;p</strong></p><p>输出写入文件地址</p><p><strong>-O, –output-module&#x3D;p</strong></p><p>调用自定义输出模块</p><p><strong>-f, –output-fields&#x3D;p</strong></p><p>以逗号分隔的输出的字段列表</p><p><strong>–output-filter&#x3D;filter</strong></p><p>对给定的探测指定字段输出过滤</p><p><strong>–list-output-modules</strong></p><p>列出可用输出模块</p><p><strong>–list-output-fields</strong></p><p>列出给定的探测的可用输出字段</p><h4 id="输出字段"><a href="#输出字段" class="headerlink" title="输出字段"></a>输出字段</h4><p>除了IP地址之外，ZMap有很多字段。这些字段可以通过在给定探测模块上运行<code>--list-output-fields</code>来查看。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">$ zmap --probe-module=&quot;tcp_synscan&quot; --list-output-fields</span><br><span class="line">saddr           string: 应答包中的源IP地址</span><br><span class="line">saddr-raw          int: 网络字节格式的源IP地址</span><br><span class="line">daddr           string: 应答包中的目的IP地址</span><br><span class="line">daddr-raw          int: 网络字节格式的目的IP地址</span><br><span class="line">ipid               int: 应答包中的IP识别号</span><br><span class="line">ttl                int: 应答包中的ttl（存活时间）值</span><br><span class="line">sport              int: TCP 源端口</span><br><span class="line">dport              int: TCP 目的端口</span><br><span class="line">seqnum             int: TCP 序列号</span><br><span class="line">acknum             int: TCP Ack号</span><br><span class="line">window             int: TCP 窗口</span><br><span class="line">classification  string: 包类型</span><br><span class="line">success            int: 是应答包成功</span><br><span class="line">repeat             int: 是否是来自主机的重复响应</span><br><span class="line">cooldown           int: 是否是在冷却时间内收到的响应</span><br><span class="line">timestamp-str   string: 响应抵达时的时间戳使用ISO8601格式</span><br><span class="line">timestamp-ts       int: 响应抵达时的时间戳使用UNIX纪元开始的秒数</span><br><span class="line">timestamp-us       int: 时间戳的微秒部分(例如 从&#x27;timestamp-ts&#x27;的几微秒)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以通过使用<code>--output-fields=fields</code>或<code>-f</code>来选择选择输出字段，任意组合的输出字段可以被指定为逗号分隔的列表。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ zmap -p 80 -f &quot;response,saddr,daddr,sport,seq,ack,in_cooldown,is_repeat,timestamp&quot; -o output.csv</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="过滤输出"><a href="#过滤输出" class="headerlink" title="过滤输出"></a>过滤输出</h4><p>在传到输出模块之前，探测模块生成的结果可以先过滤。过滤是针对探测模块的输出字段的。过滤使用类似于SQL的简单过滤语法写成，通过ZMap的**–output-filter**选项来指定。输出过滤通常用于过滤掉重复的结果，或仅传输成功的响应到输出模块。</p><p>过滤表达式的形式为<code>&lt;字段名&gt; &lt;操作符&gt; &lt;值&gt;</code>。<code>&lt;值&gt;</code>的类型必须是一个字符串或一串无符号整数并且匹配<code>&lt;字段名&gt;</code>类型。对于整数比较有效的操作符是<code>= !=, &lt;, &gt;, &lt;=, &gt;=</code>。字符串比较的操作是&#x3D;，!&#x3D;。<code>--list-output-fields</code>可以打印那些可供探测模块选择的字段和类型，然后退出。</p><p>复合型的过滤操作，可以通过使用<code>&amp;&amp;</code>（逻辑与）和<code>||</code>（逻辑或）这样的运算符来组合出特殊的过滤操作。</p><p><strong>示例</strong></p><p>书写一则过滤仅显示成功的、不重复的应答</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">--output-filter=&quot;success = 1 &amp;&amp; repeat = 0&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>过滤出RST分类并且TTL大于10的包，或者SYNACK分类的包</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">--output-filter=&quot;(classification = rst &amp;&amp; ttl &gt; 10) || classification = synack&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="CSV"><a href="#CSV" class="headerlink" title="CSV"></a>CSV</h4><p>csv模块将会生成以逗号分隔各个要求输出的字段的文件。例如，以下的指令将生成名为<code>output.csv</code>的CSV文件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ zmap -p 80 -f &quot;response,saddr,daddr,sport,seq,ack,in_cooldown,is_repeat,timestamp&quot; -o output.csv</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#响应, 源地址, 目的地址, 源端口, 目的端口, 序列号, 应答, 是否是冷却模式, 是否重复, 时间戳</span><br><span class="line">response, saddr, daddr, sport, dport, seq, ack, in_cooldown, is_repeat, timestamp</span><br><span class="line">synack, 159.174.153.144, 10.0.0.9, 80, 40555, 3050964427, 3515084203, 0, 0,2013-08-15 18:55:47.681</span><br><span class="line">rst, 141.209.175.1, 10.0.0.9, 80, 40136, 0, 3272553764, 0, 0,2013-08-15 18:55:47.683</span><br><span class="line">rst, 72.36.213.231, 10.0.0.9, 80, 56642, 0, 2037447916, 0, 0,2013-08-15 18:55:47.691</span><br><span class="line">rst, 148.8.49.150, 10.0.0.9, 80, 41672, 0, 1135824975, 0, 0,2013-08-15 18:55:47.692</span><br><span class="line">rst, 50.165.166.206, 10.0.0.9, 80, 38858, 0, 535206863, 0, 0,2013-08-15 18:55:47.694</span><br><span class="line">rst, 65.55.203.135, 10.0.0.9, 80, 50008, 0, 4071709905, 0, 0,2013-08-15 18:55:47.700</span><br><span class="line">synack, 50.57.166.186, 10.0.0.9, 80, 60650, 2813653162, 993314545, 0, 0,2013-08-15 18:55:47.704</span><br><span class="line">synack, 152.75.208.114, 10.0.0.9, 80, 52498, 460383682, 4040786862, 0, 0,2013-08-15 18:55:47.707</span><br><span class="line">synack, 23.72.138.74, 10.0.0.9, 80, 33480, 810393698, 486476355, 0, 0,2013-08-15 18:55:47.710</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h4><p>Redis的输出模块允许地址被添加到一个Redis的队列，而不是保存到文件，允许ZMap将它与之后的处理工具结合使用。</p><p><strong>注意!</strong> ZMap默认不会编译Redis功能。如果你从源码构建ZMap，可以在CMake的时候加上<code>-DWITH_REDIS=ON</code>来增加Redis支持。</p><h4 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h4><p>JSON输出模块用起来类似于CSV模块，只是以JSON格式写入到文件。JSON文件能轻松地导入到其它可以读取JSON的程序中。</p><p><strong>注意！</strong>，ZMap默认不会编译JSON功能。如果你从源码构建ZMap，可以在CMake的时候加上<code>-DWITH_JSON=ON</code>来增加JSON支持。</p><h3 id="黑名单和白名单"><a href="#黑名单和白名单" class="headerlink" title="黑名单和白名单"></a>黑名单和白名单</h3><p>ZMap同时支持对网络前缀做黑名单和白名单。如果ZMap不加黑名单和白名单参数，他将会扫描所有的IPv4地址（包括本地的，保留的以及组播地址）。如果指定了黑名单文件，那么在黑名单中的网络前缀将不再扫描；如果指定了白名单文件，只有那些网络前缀在白名单内的才会扫描。白名单和黑名单文件可以协同使用；黑名单优先于白名单（例如：如果您在白名单中指定了10.0.0.0&#x2F;8并在黑名单中指定了10.1.0.0&#x2F;16，那么10.1.0.0&#x2F;16将不会扫描）。白名单和黑名单文件可以在命令行中指定，如下所示：</p><p><strong>-b, –blacklist-file&#x3D;path</strong></p><p>文件用于记录黑名单子网，以CIDR（无类域间路由）的表示法，例如192.168.0.0&#x2F;16</p><p><strong>-w, –whitelist-file&#x3D;path</strong></p><p>文件用于记录限制扫描的子网，以CIDR的表示法，例如192.168.0.0&#x2F;16</p><p>黑名单文件的每行都需要以CIDR的表示格式书写，一行单一的网络前缀。允许使用<code>#</code>加以备注。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"># IANA（英特网编号管理局）记录的用于特殊目的的IPv4地址</span><br><span class="line"># http://www.iana.org/assignments/iana-ipv4-special-registry/iana-ipv4-special-registry.xhtml</span><br><span class="line"># 更新于2013-05-22</span><br><span class="line"></span><br><span class="line">0.0.0.0/8           # RFC1122: 网络中的所有主机</span><br><span class="line">10.0.0.0/8          # RFC1918: 私有地址</span><br><span class="line">100.64.0.0/10       # RFC6598: 共享地址空间</span><br><span class="line">127.0.0.0/8         # RFC1122: 回环地址</span><br><span class="line">169.254.0.0/16      # RFC3927: 本地链路地址</span><br><span class="line">172.16.0.0/12       # RFC1918: 私有地址</span><br><span class="line">192.0.0.0/24        # RFC6890: IETF协议预留</span><br><span class="line">192.0.2.0/24        # RFC5737: 测试地址1</span><br><span class="line">192.88.99.0/24      # RFC3068: IPv6转换到IPv4的任播</span><br><span class="line">192.168.0.0/16      # RFC1918: 私有地址</span><br><span class="line">192.18.0.0/15       # RFC2544: 检测地址</span><br><span class="line">198.51.100.0/24     # RFC5737: 测试地址2</span><br><span class="line">203.0.113.0/24      # RFC5737: 测试地址3</span><br><span class="line">240.0.0.0/4         # RFC1112: 预留地址</span><br><span class="line">255.255.255.255/32  # RFC0919: 限制广播地址</span><br><span class="line"></span><br><span class="line"># IANA记录的用于组播的地址空间</span><br><span class="line"># http://www.iana.org/assignments/multicast-addresses/multicast-addresses.xhtml</span><br><span class="line"># 更新于2013-06-25</span><br><span class="line"></span><br><span class="line">224.0.0.0/4         # RFC5771: 组播/预留地址ed</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如果您只是想扫描因特网中随机的一部分地址，使用<a href="/article-5860-1.html#ratelimiting">抽样</a>检出，来代替使用白名单和黑名单。</p><p>**注意！**ZMap默认设置使用<code>/etc/zmap/blacklist.conf</code>作为黑名单文件，其中包含有本地的地址空间和预留的IP空间。通过编辑<code>/etc/zmap/zmap.conf</code>可以改变默认的配置。</p><h3 id="速度限制与抽样"><a href="#速度限制与抽样" class="headerlink" title="速度限制与抽样"></a>速度限制与抽样</h3><p>默认情况下，ZMap将以您当前网卡所能支持的最快速度扫描。以我们对于常用硬件的经验，这通常是理论上Gbit以太网速度的95-98%，这可能比您的上游提供商可处理的速度还要快。ZMap是不会自动的根据您的上游提供商来调整发送速率的。您可能需要手动的调整发送速率来减少丢包和错误结果。</p><p><strong>-r, –rate&#x3D;pps</strong></p><p>设置最大发送速率以包&#x2F;秒为单位</p><p><strong>-B, –bandwidth&#x3D;bps</strong></p><p>设置发送速率以比特&#x2F;秒(支持G,M和K后缀)。这会覆盖–rate参数。</p><p>ZMap同样支持对IPv4地址空间进行指定最大目标数和&#x2F;或最长运行时间的随机采样。由于每次对主机的扫描是通过随机排序生成的，限制扫描的主机个数为N就会随机抽选N个主机。命令选项如下：</p><p><strong>-n, –max-targets&#x3D;n</strong></p><p>探测目标上限数量</p><p><strong>-N, –max-results&#x3D;n</strong></p><p>结果上限数量（累积收到这么多结果后退出）</p><p><strong>-t, –max-runtime&#x3D;s</strong></p><p>发送数据包时间长度上限（以秒为单位）</p><p><strong>-s, –seed&#x3D;n</strong></p><p>种子用以选择地址的排列方式。使用不同ZMap执行扫描操作时将种子设成相同的值可以保证相同的扫描顺序。</p><p>举个例子，如果您想要多次扫描同样的一百万个互联网主机，您可以设定排序种子和扫描主机的上限数量，大致如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">zmap -p 443 -s 3 -n 1000000 -o results</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>为了确定哪一百万主机将要被扫描，您可以执行预扫，只打印数据包而非发送，并非真的实施扫描。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">zmap -p 443 -s 3 -n 1000000 --dryrun | grep daddr</span><br><span class="line">    | awk -F&#x27;daddr: &#x27; &#x27;&#123;print $2&#125;&#x27; | sed &#x27;s/ |.*//;&#x27; </span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="发送多个数据包"><a href="#发送多个数据包" class="headerlink" title="发送多个数据包"></a>发送多个数据包</h3><p>ZMap支持向每个主机发送多个探测。增加这个数量既增加了扫描时间又增加了到达的主机数量。然而，我们发现，增加的扫描时间（每个额外扫描的增加近100％）远远大于到达的主机数量（每个额外扫描的增加近1％）。</p><p><strong>-P, –probes&#x3D;n</strong></p><p>向每个IP发出的独立探测个数（默认值&#x3D;1）</p><h3 id="示例应用"><a href="#示例应用" class="headerlink" title="示例应用"></a>示例应用</h3><p>ZMap专为向大量主机发起连接并寻找那些正确响应而设计。然而，我们意识到许多用户需要执行一些后续处理，如执行应用程序级别的握手。例如，用户在80端口实施TCP SYN扫描也许想要实施一个简单的GET请求，还有用户扫描443端口可能希望完成TLS握手。</p><h4 id="Banner获取"><a href="#Banner获取" class="headerlink" title="Banner获取"></a>Banner获取</h4><p>我们收录了一个示例程序，banner-grab，伴随ZMap使用可以让用户从监听状态的TCP服务器上接收到消息。Banner-grab连接到提供的服务器上，发送一个可选的消息，然后打印出收到的第一个消息。这个工具可以用来获取banner，例如HTTP服务的回复的具体指令，telnet登陆提示，或SSH服务的字符串。</p><p>下面的例子寻找了1000个监听80端口的服务器，并向每个发送一个简单的GET请求，存储他们的64位编码响应至http-banners.out</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ zmap -p 80 -N 1000 -B 10M -o - | ./banner-grab-tcp -p 80 -c 500 -d ./http-req &gt; out</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如果想知道更多使用<code>banner-grab</code>的细节,可以参考<code>examples/banner-grab</code>中的README文件。</p><p><strong>注意！</strong> ZMap和banner-grab（如例子中）同时运行可能会比较显著的影响对方的表现和精度。确保不让ZMap占满banner-grab-tcp的并发连接，不然banner-grab将会落后于标准输入的读入，导致阻塞ZMap的输出写入。我们推荐使用较慢扫描速率的ZMap，同时提升banner-grab-tcp的并发性至3000以内（注意 并发连接&gt;1000需要您使用<code>ulimit -SHn 100000</code>和<code>ulimit -HHn 100000</code>来增加每个进程的最大文件描述符数量）。当然，这些参数取决于您服务器的性能、连接成功率（hit-rate）；我们鼓励开发者在运行大型扫描之前先进行小样本的试验。</p><h4 id="建立套接字"><a href="#建立套接字" class="headerlink" title="建立套接字"></a>建立套接字</h4><p>我们也收录了另一种形式的banner-grab，就是forge-socket， 重复利用服务器发出的SYN-ACK，连接并最终取得banner。在<code>banner-grab-tcp</code>中，ZMap向每个服务器发送一个SYN，并监听服务器发回的带有SYN+ACK的应答。运行ZMap主机的内核接受应答后发送RST，这样就没有与该包关联活动连接。程序banner-grab必须在这之后创建一个新的TCP连接到从服务器获取数据。</p><p>在forge-socket中，我们利用内核中同名的模块，使我们可以创建任意参数的TCP连接。可以通过抑制内核的RST包，并重用SYN+ACK的参数取代该包而创建套接字，通过这个套接字收发数据和我们平时使用的连接套接字并没有什么不同。</p><p>要使用forge-socket，您需要forge-socket内核模块，从<a target="_blank" rel="noopener" href="https://github.com/ewust/forge_socket/">github</a>上可以获得。您需要<code>git clone git@github.com:ewust/forge_socket.git</code>至ZMap源码根目录，然后cd进入forge_socket目录，运行make。以root身份运行<code>insmod forge_socket.ko</code> 来安装该内核模块。</p><p>您也需要告知内核不要发送RST包。一个简单的在全系统禁用RST包的方法是使用<strong>iptables</strong>。以root身份运行<code>iptables -A OUTPUT -p tcp -m tcp --tcp-flgas RST,RST RST,RST -j DROP</code>即可，当然您也可以加上一项<code>--dport X</code>将禁用局限于所扫描的端口（X）上。扫描完成后移除这项设置，以root身份运行<code>iptables -D OUTPUT -p tcp -m tcp --tcp-flags RST,RST RST,RST -j DROP</code>即可。</p><p>现在应该可以建立forge-socket的ZMap示例程序了。运行需要使用<strong>extended_file</strong>ZMap<a href="/article-5860-1.html#outputmodule">输出模块</a>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ zmap -p 80 -N 1000 -B 10M -O extended_file -o - | \</span><br><span class="line">    ./forge-socket -c 500 -d ./http-req &gt; ./http-banners.out</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>详细内容可以参考<code>examples/forge-socket</code>目录下的README。</p><hr><h3 id="编写探测和输出模块"><a href="#编写探测和输出模块" class="headerlink" title="编写探测和输出模块"></a>编写探测和输出模块</h3><p>ZMap可以通过<strong>探测模块</strong>来扩展支持不同类型的扫描，通过<strong>输出模块</strong>增加不同类型的输出结果。注册过的探测和输出模块可以在命令行中列出：</p><p><strong>–list-probe-modules</strong></p><p>列出安装过的探测模块</p><p><strong>–list-output-modules</strong></p><p>列出安装过的输出模块</p><h4 id="输出模块"><a href="#输出模块" class="headerlink" title="输出模块"></a>输出模块</h4><p>ZMap的输出和输出后处理可以通过实现和注册扫描器的<strong>输出模块</strong>来扩展。输出模块在接收每一个应答包时都会收到一个回调。然而默认提供的模块仅提供简单的输出，这些模块同样支持更多的输出后处理（例如：重复跟踪或输出AS号码来代替IP地址）。</p><p>通过定义一个新的output_module结构来创建输出模块，并在<a target="_blank" rel="noopener" href="https://github.com/zmap/zmap/blob/v1.0.0/src/output_modules/output_modules.c">output_modules.c</a>中注册：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">typedef struct output_module &#123;</span><br><span class="line">    const char          *name;           // 在命令行如何引用输出模块</span><br><span class="line">    unsigned            update_interval; // 以秒为单位的更新间隔</span><br><span class="line"></span><br><span class="line">    output_init_cb      init;            // 在扫描器初始化的时候调用</span><br><span class="line">    output_update_cb    start;           // 在扫描器开始的时候调用</span><br><span class="line">    output_update_cb    update;          // 每次更新间隔调用，秒为单位</span><br><span class="line">    output_update_cb    close;           // 扫描终止后调用</span><br><span class="line"></span><br><span class="line">    output_packet_cb    process_ip;      // 接收到应答时调用</span><br><span class="line"></span><br><span class="line">    const char          *helptext;       // 会在--list-output-modules时打印在屏幕上</span><br><span class="line"></span><br><span class="line">&#125; output_module_t;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>输出模块必须有名称，通过名称可以在命令行调用，并且通常会实现<code>success_ip</code>和常见的<code>other_ip</code>回调。process_ip的回调由每个收到并经由<strong>probe module</strong>过滤的应答包调用。应答是否被认定为成功并不确定（比如，它可以是一个TCP的RST）。这些回调必须定义匹配<code>output_packet_cb</code>定义的函数:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">int (*output_packet_cb) (</span><br><span class="line"></span><br><span class="line">    ipaddr_n_t    saddr,         // 网络字节格式的发起扫描主机IP地址</span><br><span class="line">    ipaddr_n_t    daddr,         // 网络字节格式的目的IP地址</span><br><span class="line"></span><br><span class="line">    const char*   response_type, // 发送模块的数据包分类</span><br><span class="line"></span><br><span class="line">    int           is_repeat,     // &#123;0: 主机的第一个应答, 1: 后续的应答&#125;</span><br><span class="line">    int           in_cooldown,   // &#123;0: 非冷却状态, 1: 扫描器处于冷却中&#125;</span><br><span class="line"></span><br><span class="line">    const u_char* packet,        // 指向IP包的iphdr结构体的指针</span><br><span class="line">    size_t        packet_len     // 包的长度，以字节为单位</span><br><span class="line">);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>输出模块还可以通过注册回调，执行在扫描初始化的时候（诸如打开输出文件的任务）、在扫描开始阶段（诸如记录黑名单的任务）、在扫描的常规间隔（诸如状态更新的任务）、在关闭的时候（诸如关掉所有打开的文件描述符）。提供的这些回调可以完整的访问扫描配置和当前状态：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int (*output_update_cb)(struct state_conf*, struct state_send*, struct state_recv*);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这些定义在<a target="_blank" rel="noopener" href="https://github.com/zmap/zmap/blob/master/src/output_modules/output_modules.h">output_modules.h</a>中。在<a target="_blank" rel="noopener" href="https://github.com/zmap/zmap/blob/master/src/output_modules/module_csv.c">src&#x2F;output<em>modules&#x2F;module</em>csv.c</a>中有可用示例。</p><h4 id="探测模块"><a href="#探测模块" class="headerlink" title="探测模块"></a>探测模块</h4><p>数据包由<strong>探测模块</strong>构造，它可以创建各种包和不同类型的响应。ZMap默认拥有两个扫描模块：<code>tcp_synscan</code>和<code>icmp_echoscan</code>。默认情况下，ZMap使用<code>tcp_synscan</code>来发送TCP SYN包并对每个主机的响应分类，如打开时（收到SYN+ACK）或关闭时（收到RST）。ZMap允许开发者编写自己的ZMap探测模块，使用如下的API：</p><p>任何类型的扫描都必须通过开发和注册<code>send_module_t</code>结构中的回调来实现：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">typedef struct probe_module &#123;</span><br><span class="line">    const char               *name;             // 如何在命令行调用扫描</span><br><span class="line">    size_t                   packet_length;     // 探测包有多长(必须是静态的)</span><br><span class="line"></span><br><span class="line">    const char               *pcap_filter;      // 对收到的响应实施PCAP过滤</span><br><span class="line">    size_t                   pcap_snaplen;      // libpcap 捕获的最大字节数 </span><br><span class="line">    uint8_t                  port_args;         // 设为1，如果ZMap需要用户指定--target-port</span><br><span class="line"></span><br><span class="line">    probe_global_init_cb     global_initialize; // 在扫描初始化会时被调用一次</span><br><span class="line">    probe_thread_init_cb     thread_initialize; // 每个包缓存区的线程中被调用一次</span><br><span class="line">    probe_make_packet_cb     make_packet;       // 每个主机更新包的时候被调用一次</span><br><span class="line">    probe_validate_packet_cb validate_packet;   // 每收到一个包被调用一次，</span><br><span class="line">                                                // 如果包无效返回0，</span><br><span class="line">                                                // 非零则有效。</span><br><span class="line"></span><br><span class="line">    probe_print_packet_cb    print_packet;      // 如果在预扫模式下被每个包都调用</span><br><span class="line">    probe_classify_packet_cb process_packet;    // 由区分响应的接收器调用</span><br><span class="line">    probe_close_cb           close;             // 扫描终止后被调用</span><br><span class="line"></span><br><span class="line">    fielddef_t               *fields            // 该模块指定的字段的定义</span><br><span class="line">    int                      numfields          // 字段的数量</span><br><span class="line"></span><br><span class="line">&#125; probe_module_t;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在扫描操作初始化时会调用一次<code>global_initialize</code>，可以用来实施一些必要的全局配置和初始化操作。然而，<code>global_initialize</code>并不能访问包缓冲区，那里是线程特定的。代替的，<code>thread_initialize</code>在每个发送线程初始化的时候被调用，提供对于缓冲区的访问，可以用来构建探测包和全局的源和目的值。此回调应用于构建主机不可知的包结构，甚至只有特定值（如：目的主机和校验和），需要随着每个主机更新。例如，以太网头部信息在交换时不会变更（减去校验和是由NIC硬件计算的）因此可以事先定义以减少扫描时间开销。</p><p>调用回调参数<code>make\_packet</code>是为了让被扫描的主机允许<strong>探测模块</strong>更新主机指定的值，同时提供IP地址、一个非透明的验证字符串和探测数目（如下所示）。探测模块负责在探测中放置尽可能多的验证字符串，即便当服务器返回的应答为空时，探测模块也能验证它的当前状态。例如，针对TCP SYN扫描，tcp_synscan探测模块会使用TCP源端口和序列号的格式存储验证字符串。响应包（SYN+ACK）将包含目的端口和确认号的预期值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int make_packet(</span><br><span class="line">    void        *packetbuf,  // 包的缓冲区</span><br><span class="line">    ipaddr_n_t  src_ip,      // 网络字节格式源IP</span><br><span class="line">    ipaddr_n_t  dst_ip,      // 网络字节格式目的IP</span><br><span class="line">    uint32_t    *validation, // 探测中的有效字符串</span><br><span class="line">    int         probe_num    // 如果向每个主机发送多重探测，</span><br><span class="line">                             // 该值为我们对于该主机</span><br><span class="line">                             // 正在发送的探测数目</span><br><span class="line">);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>扫描模块也应该定义<code>pcap_filter</code>、<code>validate_packet</code>和<code>process_packet</code>。只有符合PCAP过滤器的包才会被扫描。举个例子，在一个TCP SYN扫描的情况下，我们只想要调查TCP SYN &#x2F; ACK或RST TCP数据包，并利用类似<code>tcp &amp;&amp; tcp[13] &amp; 4 != 0 || tcp[13] == 18</code>的过滤方法。<code>validate_packet</code>函数将会被每个满足PCAP过滤条件的包调用。如果验证返回的值非零，将会调用<code>process_packet</code>函数，并使用<code>fields</code>定义的字段和包中的数据填充字段集。举个例子，如下代码为TCP synscan探测模块处理了一个数据包。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">void synscan_process_packet(const u_char *packet, uint32_t len, fieldset_t *fs)</span><br><span class="line">&#123;</span><br><span class="line">    struct iphdr *ip_hdr = (struct iphdr *)&amp;packet[sizeof(struct ethhdr)];</span><br><span class="line">    struct tcphdr *tcp = (struct tcphdr*)((char *)ip_hdr </span><br><span class="line">            + (sizeof(struct iphdr)));</span><br><span class="line"></span><br><span class="line">    fs_add_uint64(fs, &quot;sport&quot;, (uint64_t) ntohs(tcp-&gt;source)); </span><br><span class="line">    fs_add_uint64(fs, &quot;dport&quot;, (uint64_t) ntohs(tcp-&gt;dest));</span><br><span class="line">    fs_add_uint64(fs, &quot;seqnum&quot;, (uint64_t) ntohl(tcp-&gt;seq));</span><br><span class="line">    fs_add_uint64(fs, &quot;acknum&quot;, (uint64_t) ntohl(tcp-&gt;ack_seq));</span><br><span class="line">    fs_add_uint64(fs, &quot;window&quot;, (uint64_t) ntohs(tcp-&gt;window));</span><br><span class="line"></span><br><span class="line">    if (tcp-&gt;rst) &#123; // RST packet</span><br><span class="line">        fs_add_string(fs, &quot;classification&quot;, (char*) &quot;rst&quot;, 0);</span><br><span class="line">        fs_add_uint64(fs, &quot;success&quot;, 0);</span><br><span class="line">    &#125; else &#123; // SYNACK packet</span><br><span class="line">        fs_add_string(fs, &quot;classification&quot;, (char*) &quot;synack&quot;, 0);</span><br><span class="line">        fs_add_uint64(fs, &quot;success&quot;, 1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><p>via: <a target="_blank" rel="noopener" href="https://zmap.io/documentation.html">https://zmap.io/documentation.html</a></p><p>译者：<a target="_blank" rel="noopener" href="https://github.com/martin2011qi">martin2011qi</a> 校对：<a target="_blank" rel="noopener" href="https://github.com/wxy">wxy</a></p><p>本文由 <a target="_blank" rel="noopener" href="https://github.com/LCTT/TranslateProject">LCTT</a> 原创翻译，<a target="_blank" rel="noopener" href="http://linux.cn/">Linux中国</a> 荣誉推出</p></div></div></div><div class="footer"><p class="footer-copyright"><span>Powered by <a target="_blank" href="https://hexo.io">Hexo</a></span> <span>Theme <a target="_blank" href="https://github.com/tinkink-co/hexo-theme-terminal">Terminal</a></span><script type="text/javascript" src="https://cdn.staticfile.net/jquery/3.4.1/jquery.min.js"></script><script>getCDNinfo=function(){$.ajax({url:"/cdn-cgi/trace",success:function(a,n){let i="Antananarivo, Madagascar - (TNR);Cape Town, South Africa - (CPT);Casablanca, Morocco - (CMN);Dar Es Salaam, Tanzania - (DAR);Djibouti City, Djibouti - (JIB);Durban, South Africa - (DUR);Johannesburg, South Africa - (JNB);Kigali, Rwanda - (KGL);Lagos, Nigeria - (LOS);Luanda, Angola - (LAD);Maputo, MZ - (MPM);Mombasa, Kenya - (MBA);Port Louis, Mauritius - (MRU);Réunion, France - (RUN);Bangalore, India - (BLR);Bangkok, Thailand - (BKK);Bandar Seri Begawan, Brunei - (BWN);Cebu, Philippines - (CEB);Chengdu, China - (CTU);Chennai, India - (MAA);Chittagong, Bangladesh - (CGP);Chongqing, China - (CKG);Colombo, Sri Lanka - (CMB);Dhaka, Bangladesh - (DAC);Dongguan, China - (SZX);Foshan, China - (FUO);Fuzhou, China - (FOC);Guangzhou, China - (CAN);Hangzhou, China - (HGH);Hanoi, Vietnam - (HAN);Hengyang, China - (HNY);Ho Chi Minh City, Vietnam - (SGN);Hong Kong - (HKG);Hyderabad, India - (HYD);Islamabad, Pakistan - (ISB);Jakarta, Indonesia - (CGK);Jinan, China - (TNA);Karachi, Pakistan - (KHI);Kathmandu, Nepal - (KTM);Kolkata, India - (CCU);Kuala Lumpur, Malaysia - (KUL);Lahore, Pakistan - (LHE);Langfang, China - (NAY);Luoyang, China - (LYA);Macau - (MFM);Malé, Maldives - (MLE);Manila, Philippines - (MNL);Mumbai, India - (BOM);Nagpur, India - (NAG);Nanning, China - (NNG);New Delhi, India - (DEL);Osaka, Japan - (KIX);Phnom Penh, Cambodia - (PNH);Qingdao, China - (TAO);Seoul, South Korea - (ICN);Shanghai, China - (SHA);Shenyang, China - (SHE);Shijiazhuang, China - (SJW);Singapore, Singapore - (SIN);Suzhou, China - (SZV);Taipei - (TPE);Thimphu, Bhutan - (PBH);Tianjin, China - (TSN);Tokyo, Japan - (NRT);Ulaanbaatar, Mongolia - (ULN);Vientiane, Laos - (VTE);Wuhan, China - (WUH);Wuxi, China - (WUX);Xi'an, China - (XIY);Yerevan, Armenia - (EVN);Zhengzhou, China - (CGO);Zuzhou, China - (CSX);Amsterdam, Netherlands - (AMS);Athens, Greece - (ATH);Barcelona, Spain - (BCN);Belgrade, Serbia - (BEG);Berlin, Germany - (TXL);Brussels, Belgium - (BRU);Bucharest, Romania - (OTP);Budapest, Hungary - (BUD);Chișinău, Moldova - (KIV);Copenhagen, Denmark - (CPH);Cork, Ireland -  (ORK);Dublin, Ireland - (DUB);Düsseldorf, Germany - (DUS);Edinburgh, United Kingdom - (EDI);Frankfurt, Germany - (FRA);Geneva, Switzerland - (GVA);Gothenburg, Sweden - (GOT);Hamburg, Germany - (HAM);Helsinki, Finland - (HEL);Istanbul, Turkey - (IST);Kyiv, Ukraine - (KBP);Lisbon, Portugal - (LIS);London, United Kingdom - (LHR);Luxembourg City, Luxembourg - (LUX);Madrid, Spain - (MAD);Manchester, United Kingdom - (MAN);Marseille, France - (MRS);Milan, Italy - (MXP);Moscow, Russia - (DME);Munich, Germany - (MUC);Nicosia, Cyprus - (LCA);Oslo, Norway - (OSL);Paris, France - (CDG);Prague, Czech Republic - (PRG);Reykjavík, Iceland - (KEF);Riga, Latvia - (RIX);Rome, Italy - (FCO);Saint Petersburg, Russia - (LED);Sofia, Bulgaria - (SOF);Stockholm, Sweden - (ARN);Tallinn, Estonia - (TLL);Thessaloniki, Greece - (SKG);Vienna, Austria - (VIE);Vilnius, Lithuania - (VNO);Warsaw, Poland - (WAW);Zagreb, Croatia - (ZAG);Zürich, Switzerland - (ZRH);Arica, Chile - (ARI);Asunción, Paraguay - (ASU);Bogotá, Colombia - (BOG);Buenos Aires, Argentina - (EZE);Curitiba, Brazil - (CWB);Fortaleza, Brazil - (FOR);Guatemala City, Guatemala - (GUA);Lima, Peru - (LIM);Medellín, Colombia - (MDE);Panama City, Panama - (PTY);Porto Alegre, Brazil - (POA);Quito, Ecuador - (UIO);Rio de Janeiro, Brazil - (GIG);São Paulo, Brazil - (GRU);Santiago, Chile - (SCL);Willemstad, Curaçao - (CUR);St. George's, Grenada - (GND);Amman, Jordan - (AMM);Baghdad, Iraq - (BGW);Baku, Azerbaijan - (GYD);Beirut, Lebanon - (BEY);Doha, Qatar - (DOH);Dubai, United Arab Emirates - (DXB);Kuwait City, Kuwait - (KWI);Manama, Bahrain - (BAH);Muscat, Oman - (MCT);Ramallah - (ZDM);Riyadh, Saudi Arabia - (RUH);Tel Aviv, Israel - (TLV);Ashburn, VA, United States - (IAD);Atlanta, GA, United States - (ATL);Boston, MA, United States - (BOS);Buffalo, NY, United States - (BUF);Calgary, AB, Canada - (YYC);Charlotte, NC, United States - (CLT);Chicago, IL, United States - (ORD);Columbus, OH, United States - (CMH);Dallas, TX, United States - (DFW);Denver, CO, United States - (DEN);Detroit, MI, United States - (DTW);Honolulu, HI, United States - (HNL);Houston, TX, United States - (IAH);Indianapolis, IN, United States - (IND);Jacksonville, FL, United States - (JAX);Kansas City, MO, United States - (MCI);Las Vegas, NV, United States - (LAS);Los Angeles, CA, United States - (LAX);McAllen, TX, United States - (MFE);Memphis, TN, United States - (MEM);Mexico City, Mexico - (MEX);Miami, FL, United States - (MIA);Minneapolis, MN, United States - (MSP);Montgomery, AL, United States - (MGM);Montréal, QC, Canada - (YUL);Nashville, TN, United States - (BNA);Newark, NJ, United States - (EWR);Norfolk, VA, United States - (ORF);Omaha, NE, United States - (OMA);Philadelphia, United States - (PHL);Phoenix, AZ, United States - (PHX);Pittsburgh, PA, United States - (PIT);Port-Au-Prince, Haiti - (PAP);Portland, OR, United States - (PDX);Queretaro, MX, Mexico - (QRO);Richmond, Virginia - (RIC);Sacramento, CA, United States - (SMF);Salt Lake City, UT, United States - (SLC);San Diego, CA, United States - (SAN);San Jose, CA, United States - (SJC);Saskatoon, SK, Canada - (YXE);Seattle, WA, United States - (SEA);St. Louis, MO, United States - (STL);Tampa, FL, United States - (TPA);Toronto, ON, Canada - (YYZ);Vancouver, BC, Canada - (YVR);Tallahassee, FL, United States - (TLH);Winnipeg, MB, Canada - (YWG);Adelaide, SA, Australia - (ADL);Auckland, New Zealand - (AKL);Brisbane, QLD, Australia - (BNE);Melbourne, VIC, Australia - (MEL);Noumea, New caledonia - (NOU);Perth, WA, Australia - (PER);Sydney, NSW, Australia - (SYD)".split(";"),e=a.split("colo=")[1].split("\n")[0],t=(a.split("colo=")[1].split("\n")[0],a.split("tls=")[1].split("\n")[0]),o=a.split("http=")[1].split("\n")[0],s=a.split("sni=")[1].split("\n")[0],r=a.split("ip=")[1].split("\n")[0],l=a.split("uag=")[1].split("\n")[0];for(var d=0;d<i.length;d++)if(-1!=i[d].indexOf(e)){document.getElementById("cdn").innerHTML=i[d];break}document.getElementById("tls").innerHTML=t,document.getElementById("http").innerHTML=o,document.getElementById("sni").innerHTML=s,document.getElementById("ip").innerHTML=r,document.getElementById("useragent").innerHTML=l}})},$(document).ready((function(){getCDNinfo()}))</script></p><p style="text-align:center">感谢陪伴与布道，开源之火不灭。​</p><p style="text-align:center"><script>document.write("本次加载耗时: "+(performance.getEntriesByType("navigation").reduce((e,r)=>e+r.responseEnd-r.startTime,0)+performance.getEntriesByType("resource").reduce((e,r)=>e+r.responseEnd-r.startTime,0)).toFixed(0)+"ms")</script></p><p style="text-align:center">当前 SNI 状态： <span id="sni">正在统计！或可能被浏览器防追踪拦截！</span></p><p style="text-align:center">当前 TLS 版本： <span id="tls">正在统计！或可能被浏览器防追踪拦截！</span></p><p style="text-align:center">当前 HTTP 版本： <span id="http">正在统计！或可能被浏览器防追踪拦截！</span></p><p style="text-align:center">当前您的客户端 IP 是： <span id="ip">正在统计！或可能被浏览器防追踪拦截！</span></p><p style="text-align:center">当前分配的 CDN 节点是: <span id="cdn">正在统计！或可能被浏览器防追踪拦截！</span></p><p style="text-align:center">您的 UserAgent 信息是: <span id="useragent">正在统计！或可能被浏览器防追踪拦截！</span></p><p></p></div></div></body></html>