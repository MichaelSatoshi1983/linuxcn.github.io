<!doctype html><html lang="en"><head><meta name="msvalidate.01" content="D404690CEFCB54C7762AC84935B99171"><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?6618da70c90c8744eead2e9371fb5077";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><script type="text/javascript">!function(t,e,n,c,s,a,r){t[n]=t[n]||function(){(t[n].q=t[n].q||[]).push(arguments)},(a=e.createElement(c)).async=1,a.src="https://www.clarity.ms/tag/s5f3f0tojf",(r=e.getElementsByTagName(c)[0]).parentNode.insertBefore(a,r)}(window,document,"clarity","script")</script><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta http-equiv="X-UA-Compatible" content="ie=edge"><link rel="stylesheet" href="/styles/base.css"><link rel="stylesheet" href="/styles/theme.css"><link rel="shortcut icon" href="/favicon.png"><title>在 Linux 上使用 Checksec 识别二进制文件的安全属性 - 归墟星火集</title><meta name="generator" content="Hexo 7.3.0"></head><body><div class="header-title"><span class="header-light"></span> <span class="header-light"></span> <span class="header-light"></span> <span>归墟星火集 linuxcn.undefined.today<span></span></span></div><div class="container"><ul class="nav"><li><a href="/">首页</a></li><li><a href="/about/">关于</a></li><li><a target="_blank" rel="noopener" href="https://undefined.today/">Blog</a></li></ul><div class="content"><div class="post-container"><div class="post-header"><span class="ui-tips">标题：</span><h1 class="ui-keyword post-title">在 Linux 上使用 Checksec 识别二进制文件的安全属性</h1><span class="post-date">2022-11-18</span></div><div class="post-header"><span class="ui-tips">分类：</span> <a href="/categories/%E6%8A%80%E6%9C%AF/">技术</a></div><div class="post-header"><span class="ui-tips">标签：</span> <a href="/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6/">二进制</a> <a href="/tags/Checksec/">Checksec</a></div><div class="post-content"><blockquote><p>这篇文章能让你了解如何使用 Checksec ，来识别一个可执行文件的安全属性，了解安全属性的含义，并知道如何使用它们。</p></blockquote><p><img src="https://linuxcn.img.undefined.today/data/attachment/album/202211/18/095702dzvm482460vnrv6y.jpg"></p><p>编译源代码会生成一个二进制文件（LCTT 译注：即 <code>.o</code> 文件）。在编译期间，你可以向 <code>gcc</code> 编译器提供 <ruby>标志 <rt>flags</rt></ruby>，以启用或禁用二进制文件的某些属性，这些属性与安全性相关。</p><p>Checksec 是一个漂亮的小工具，同时它也是一个 shell 脚本。Checksec 可以识别编译时构建到二进制文件中的安全属性。编译器可能会默认启用一些安全属性，你也可以提供特定的标志，来启用其他的安全属性。</p><p>本文将介绍如何使用 Checksec ，来识别二进制文件的安全属性，包括：</p><ol><li>Checksec 在查找有关安全属性的信息时，使用了什么<strong>底层的命令</strong></li><li>在将源代码编译成二进制文件时，如何使用<ruby>GNU 编译器套件 <rt>GNU Compiler Collection</rt></ruby>（即 GCC）来<strong>启用安全属性</strong>。</li></ol><h3 id="安装-checksec"><a href="#安装-checksec" class="headerlink" title="安装 checksec"></a>安装 checksec</h3><p>要在 Fedora 和其他基于 RPM 的 Linux 系统上，安装 Checksec，请使用以下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo dnf install checksec</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>对于基于 Debian 的 Linux 发行版，使用对应的 <code>apt</code> 命令，来安装 Checksec。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt install checksec</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="shell-脚本"><a href="#shell-脚本" class="headerlink" title="shell 脚本"></a>shell 脚本</h3><p>在安装完 Checksec 后，能够发现 Checksec 是一个<strong>单文件</strong>的 shell 脚本，它位于 <code>/usr/bin/checksec</code>，并且这个文件挺大的。Checksec 的一个优点是你可以通过快速通读这个 shell 脚本，从而了解 Checksec 的执行原理、明白所有能查找有关二进制文件或可执行文件的安全属性的<strong>系统命令</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ file /usr/bin/checksec</span><br><span class="line">/usr/bin/checksec: Bourne-Again shell script, ASCII text executable, with very long lines</span><br><span class="line"></span><br><span class="line">$ wc -l /usr/bin/checksec</span><br><span class="line">2111 /usr/bin/checksec</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>以下的命令展示了如何对你每天都会使用的：<code>ls</code> 命令的二进制文件运行 Checksec。Checksec 命令的格式是：<code>checksec --file=</code>，后面再跟上二进制文件的绝对路径：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ checksec --file=/usr/bin/ls</span><br><span class="line">RELRO           STACK CANARY      NX            PIE             RPATH      RUNPATH      Symbols         FORTIFY Fortified       Fortifiable     FILE</span><br><span class="line">Full RELRO      Canary found      NX enabled    PIE enabled     No RPATH   No RUNPATH   No Symbols        Yes   5       17              /usr/bin/ls</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>当你在终端中对某个二进制文件运行 Checksec 时，你会看到安全属性有颜色上的区分，显示什么是好的安全属性（绿色），什么可能不是好的安全属性（红色）。我在这里说 <strong>“可能”</strong> 是因为即使有些安全属性是红色的，也不一定意味着这个二进制文件很糟糕，它可能只是表明发行版供应商在编译二进制文件时做了一些权衡，从而舍弃了部分安全属性。</p><p>Checksec 输出的第一行提供了二进制文件的各种安全属性，例如 <code>RELRO</code>、<code>STACK CANARY</code>、<code>NX</code> 等（我将在后文进行详细解释）。第二行打印出给定二进制文件（本例中为 <code>ls</code>）在这些安全属性的状态（例如，<code>NX enabled</code> 表示为堆栈中的数据没有执行权限）。</p><h3 id="示例二进制文件"><a href="#示例二进制文件" class="headerlink" title="示例二进制文件"></a>示例二进制文件</h3><p>在本文中，我将使用以下的 “hello world” 程序作为示例二进制文件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">        printf(&quot;Hello World\n&quot;);</span><br><span class="line">        return 0;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>请注意，在编译源文件 <code>hello.c</code> 的时候，我没有给 <code>gcc</code> 提供任何额外的标志：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ gcc hello.c -o hello</span><br><span class="line"> </span><br><span class="line">$ file hello</span><br><span class="line">hello: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=014b8966ba43e3ae47fab5acae051e208ec9074c, for GNU/Linux 3.2.0, not stripped</span><br><span class="line"></span><br><span class="line">$ ./hello</span><br><span class="line">Hello World</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>使用 Checksec 运行二进制文件 <code>hello</code>，打印的某些安全属性的状态，与上面的 <code>ls</code> 二进制文件的结果不同（在你的屏幕上，某些属性可能显示为红色）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ checksec --file=./hello</span><br><span class="line">RELRO           STACK CANARY      NX            PIE             RPATH      RUNPATH      Symbols         FORTIFY Fortified       Fortifiable     FILE</span><br><span class="line">Partial RELRO   No canary found   NX enabled    No PIE          No RPATH   No RUNPATH   85) Symbols       No    0       0./hello</span><br><span class="line">$</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>（LCTT 译注：在我的 Ubuntu 22.04 虚拟机，使用 11.3.0 版本的 <code>gcc</code>，结果与上述不太相同，利用默认参数进行编译，会得到 RELRO、PIE、NX 保护是全开的情况。）</p><h3 id="更改-Checksec-的输出格式"><a href="#更改-Checksec-的输出格式" class="headerlink" title="更改 Checksec 的输出格式"></a>更改 Checksec 的输出格式</h3><p>Checksec 允许自定义各种输出格式，你可以使用 <code>--output</code> 来自定义输出格式。我将选择的输出格式是 JSON 格式，并将输出结果通过管道传输到 <code>jq</code> 实用程序，来得到漂亮的打印。</p><p>接下来，确保你已安装好了 <a target="_blank" rel="noopener" href="https://stedolan.github.io/jq/download/">jq</a>，因为本教程会使用 <code>jq</code> 从 Checksec 的输出结果中，用 <code>grep</code> 来快速得到某一特定的安全属性状态，并报告该安全属性是否启动（启动为 <code>yes</code>，未启动为 <code>no</code>）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ checksec --file=./hello --output=json | jq</span><br><span class="line">&#123;</span><br><span class="line">  &quot;hello&quot;: &#123;</span><br><span class="line">    &quot;relro&quot;: &quot;partial&quot;,</span><br><span class="line">    &quot;canary&quot;: &quot;no&quot;,</span><br><span class="line">    &quot;nx&quot;: &quot;yes&quot;,</span><br><span class="line">    &quot;pie&quot;: &quot;no&quot;,</span><br><span class="line">    &quot;rpath&quot;: &quot;no&quot;,</span><br><span class="line">    &quot;runpath&quot;: &quot;no&quot;,</span><br><span class="line">    &quot;symbols&quot;: &quot;yes&quot;,</span><br><span class="line">    &quot;fortify_source&quot;: &quot;no&quot;,</span><br><span class="line">    &quot;fortified&quot;: &quot;0&quot;,</span><br><span class="line">    &quot;fortify-able&quot;: &quot;0&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="看一看所有的安全属性"><a href="#看一看所有的安全属性" class="headerlink" title="看一看所有的安全属性"></a>看一看所有的安全属性</h3><p>上面的二进制文件 <code>hello</code> 包括几个安全属性。我将该二进制文件与 <code>ls</code> 的二进制文件进行比较，以检查启用的安全属性有何不同，并解释 Checksec 是如何找到此信息。</p><h4 id="1、符号（Symbol）"><a href="#1、符号（Symbol）" class="headerlink" title="1、符号（Symbol）"></a>1、符号（Symbol）</h4><p>我先从简单的讲起。在编译期间，某些 <ruby>符号 <rt>symbols</rt></ruby>包含在二进制文件中，这些符号主要用作于调试。开发软件时，需要用到这些符号，来调试和修复错误。</p><p>这些符号通常会从供用户普遍使用的最终二进制文件中删除。删除这些符号不会影响到二进制文件的执行。删除符号通常是为了节省空间，因为一旦符号被删除了，二进制文件就会稍微小一些。在闭源或专有软件中，符号通常都会被删除，因为把这些符号放在二进制文件中，可以很容易地推断出软件的内部工作原理。</p><p>根据 Checksec 的结果，在二进制文件 <code>hello</code> 中有符号，但在 <code>ls</code> 的二进制文件中不会有符号。同样地，你还可以用 <code>file</code> 命令，来找到符号的信息，在二进制文件 <code>hello</code> 的输出结果的最后，看到 <code>not stripped</code>，表明二进制文件 <code>hello</code> 有符号：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ checksec --file=/bin/ls --output=json | jq | grep symbols</span><br><span class="line">    &quot;symbols&quot;: &quot;no&quot;,</span><br><span class="line"></span><br><span class="line">$ checksec --file=./hello --output=json | jq | grep symbols</span><br><span class="line">    &quot;symbols&quot;: &quot;yes&quot;,</span><br><span class="line"></span><br><span class="line">$ file hello</span><br><span class="line">hello: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=014b8966ba43e3ae47fab5acae051e208ec9074c, for GNU/Linux 3.2.0, not stripped</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Checksec 是如何找到符号的信息呢？Checksec 提供了一个方便的 <code>--debug</code> 选项，来显示运行了哪些函数。因此，运行以下的命令，会显示在 shell 脚本中运行了哪些函数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ checksec --debug --file=./hello</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在本教程中，我试图寻找 Checksec 查找安全属性信息时，使用了什么<strong>底层命令</strong>。由于 Checksec 是一个 shell 脚本，因此你始终可以使用 Bash 功能。以下的命令将输出从 shell 脚本中运行的每个命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ bash -x /usr/bin/checksec --file=./hello</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如果你滚动浏览上述的输出结果的话，你会看到 <code>echo_message</code> 后面有各个安全属性的类别。以下显示了 Checksec 检测二进制文件是否包含符号时，运行的底层命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">+ readelf -W --symbols ./hello</span><br><span class="line">+ grep -q &#x27;\\.symtab&#x27;</span><br><span class="line">+ echo_message &#x27;\033[31m96) Symbols\t\033[m  &#x27; Symbols, &#x27; symbols=&quot;yes&quot;&#x27; &#x27;&quot;symbols&quot;:&quot;yes&quot;,&#x27;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上面的输出显示，Checksec 利用 <code>readelf</code>，来读取二进制文件，并提供一个特殊 <code>--symbols</code> 标志，来列出二进制文件中的所有符号。然后它会查找一个特殊值：<code>.symtab</code>，它提供了所能找到的条目的计数（即符号的个数）。你可以在上面编译的测试二进制文件 <code>hello</code> 上，尝试以下命令，得到与 Checksec 查看二进制文件类似的符号信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ readelf -W --symbols ./hello</span><br><span class="line">$ readelf -W --symbols ./hello | grep -i symtab</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>（LCTT 译注：也可以通过直接查看 <code>/usr/bin/checksec</code> 下的 Checksec 源文件。）</p><h5 id="如何删除符号"><a href="#如何删除符号" class="headerlink" title="如何删除符号"></a>如何删除符号</h5><p>你可以在编译后或编译时删除符号。</p><ul><li><strong>编译后：</strong> 在编译后，你可以使用 <code>strip</code>，手动地来删除二进制文件的符号。删除后，使用 <code>file</code> 命令，来检验是否还有符号，现在显示 <code>stripped</code>，表明二进制文件 <code>hello</code> 无符号了：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ gcc hello.c -o hello</span><br><span class="line">$</span><br><span class="line">$ file hello</span><br><span class="line">hello: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=322037496cf6a2029dcdcf68649a4ebc63780138, for GNU/Linux 3.2.0, not stripped</span><br><span class="line">$</span><br><span class="line">$ strip hello</span><br><span class="line">$</span><br><span class="line">$ file hello</span><br><span class="line">hello: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=322037496cf6a2029dcdcf68649a4ebc63780138, for GNU/Linux 3.2.0, stripped</span><br><span class="line">$ </span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><strong>编译时：</strong> 你也可以在编译时，用 <code>-s</code> 参数让 gcc 编译器帮你自动地删除符号：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -s hello.c -o hello</span><br><span class="line">$</span><br><span class="line">$ file hello</span><br><span class="line">hello: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=247de82a8ad84e7d8f20751ce79ea9e0cf4bd263, for GNU/Linux 3.2.0, stripped</span><br><span class="line">$</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>重新运行 Checksec，你可以看到现在二进制文件 <code>hello</code> 的 <code>symbols</code> 这一属性的值是<code>no</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ checksec --file=./hello --output=json | jq | grep symbols</span><br><span class="line">    &quot;symbols&quot;: &quot;no&quot;,</span><br><span class="line">$</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="2、Canary（堆栈溢出哨兵）"><a href="#2、Canary（堆栈溢出哨兵）" class="headerlink" title="2、Canary（堆栈溢出哨兵）"></a>2、Canary（堆栈溢出哨兵）</h4><p>Canary 是放置在缓冲区和 <ruby>栈 <rt>stack</rt></ruby> 上的控制数据之间的已知值，它用于监视缓冲区是否溢出。当应用程序执行时，会为其分配两种内存，其中之一就是 <em>栈</em>。栈是一个具有两个操作的数据结构：第一个操作 <code>push</code>，将数据压入堆栈；第二个操作 <code>pop</code>，以后进先出的顺序从栈中弹出数据。恶意的输入可能会导致栈溢出，或使用特制的输入破坏栈，并导致程序崩溃：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ checksec --file=/bin/ls --output=json | jq | grep canary</span><br><span class="line">    &quot;canary&quot;: &quot;yes&quot;,</span><br><span class="line">$</span><br><span class="line">$ checksec --file=./hello --output=json | jq | grep canary</span><br><span class="line">    &quot;canary&quot;: &quot;no&quot;,</span><br><span class="line">$</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Checksec 是如何确定二进制文件是否启用了 Canary 的呢？使用上述同样的方法，得到 Checksec 在检测二进制文件是否启用 Canary 时，运行的底层命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ readelf -W -s ./hello | grep -E &#x27;__stack_chk_fail|__intel_security_cookie&#x27;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="启用-Canary"><a href="#启用-Canary" class="headerlink" title="启用 Canary"></a>启用 Canary</h5><p>为了防止栈溢出等情况，编译器提供了 <code>-stack-protector-all</code> 标志，它向二进制文件添加了额外的代码，来检查缓冲区是否溢出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -fstack-protector-all hello.c -o hello</span><br><span class="line"></span><br><span class="line">$ checksec --file=./hello --output=json | jq | grep canary</span><br><span class="line">    &quot;canary&quot;: &quot;yes&quot;,</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Checksec 显示 Canary 属性现已启用。你还可以通过以下方式，来验证这一点：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ readelf -W -s ./hello | grep -E &#x27;__stack_chk_fail|__intel_security_cookie&#x27;</span><br><span class="line">     2: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND __stack_chk_fail@GLIBC_2.4 (3)</span><br><span class="line">    83: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND __stack_chk_fail@@GLIBC_2.4</span><br><span class="line">$</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="3、位置无关可执行文件（PIE）"><a href="#3、位置无关可执行文件（PIE）" class="headerlink" title="3、位置无关可执行文件（PIE）"></a>3、位置无关可执行文件（PIE）</h4><p><ruby>位置无关可执行文件 <rt>Position-Independent Executable</rt></ruby>（PIE），顾名思义，它指的是放置在内存中某处执行的代码，不管其绝对地址的位置，即代码段、数据段地址随机化（ASLR）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ checksec --file=/bin/ls --output=json | jq | grep pie</span><br><span class="line">    &quot;pie&quot;: &quot;yes&quot;,</span><br><span class="line"></span><br><span class="line">$ checksec --file=./hello --output=json | jq | grep pie</span><br><span class="line">    &quot;pie&quot;: &quot;no&quot;,</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>通常，PIE 仅对 <ruby>库 <rt>libraries</rt></ruby>启用，并不对独立命令行程序启用 PIE。在下面的输出中，<code>hello</code> 显示为 <code>LSB executable</code>，而 <code>libc</code> 标准库（<code>.so</code>） 文件被标记为 <code>LSB shared object</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ file hello</span><br><span class="line">hello: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=014b8966ba43e3ae47fab5acae051e208ec9074c, for GNU/Linux 3.2.0, not stripped</span><br><span class="line"></span><br><span class="line">$ file /lib64/libc-2.32.so</span><br><span class="line">/lib64/libc-2.32.so: ELF 64-bit LSB shared object, x86-64, version 1 (GNU/Linux), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=4a7fb374097fb927fb93d35ef98ba89262d0c4a4, for GNU/Linux 3.2.0, not stripped</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Checksec 查找是否启用 PIE 的底层命令如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ readelf -W -h ./hello | grep EXEC</span><br><span class="line">  Type:                              EXEC (Executable file)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如果你在共享库上尝试相同的命令，你将看到 <code>DYN</code>，而不是 <code>EXEC</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ readelf -W -h /lib64/libc-2.32.so | grep DYN</span><br><span class="line">  Type:                              DYN (Shared object file)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="启用-PIE"><a href="#启用-PIE" class="headerlink" title="启用 PIE"></a>启用 PIE</h5><p>要在测试程序 <code>hello.c</code> 上启用 PIE，请在编译时，使用以下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -pie -fpie hello.c -o hello`</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>你可以使用 Checksec，来验证 PIE 是否已启用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ checksec --file=./hello --output=json | jq | grep pie</span><br><span class="line">    &quot;pie&quot;: &quot;yes&quot;,</span><br><span class="line">$</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>现在，应该会显示为 “<ruby>PIE 可执行 <rt>pie executable</rt></ruby>”，其类型从 <code>EXEC</code> 更改为 <code>DYN</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ file hello</span><br><span class="line">hello: ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=bb039adf2530d97e02f534a94f0f668cd540f940, for GNU/Linux 3.2.0, not stripped</span><br><span class="line"></span><br><span class="line">$ readelf -W -h ./hello | grep DYN</span><br><span class="line">  Type:                              DYN (Shared object file)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="4、NX（堆栈禁止执行）"><a href="#4、NX（堆栈禁止执行）" class="headerlink" title="4、NX（堆栈禁止执行）"></a>4、NX（堆栈禁止执行）</h4><p>NX 代表 <ruby>不可执行 <rt>non-executable</rt></ruby>。它通常在 CPU 层面上启用，因此启用 NX 的操作系统可以将某些内存区域标记为不可执行。通常，缓冲区溢出漏洞将恶意代码放在堆栈上，然后尝试执行它。但是，让堆栈这些可写区域变得不可执行，可以防止这种攻击。在使用 <code>gcc</code> 对源程序进行编译时，默认启用此安全属性：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ checksec --file=/bin/ls --output=json | jq | grep nx</span><br><span class="line">    &quot;nx&quot;: &quot;yes&quot;,</span><br><span class="line"></span><br><span class="line">$ checksec --file=./hello --output=json | jq | grep nx</span><br><span class="line">    &quot;nx&quot;: &quot;yes&quot;,</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Checksec 使用以下底层命令，来确定是否启用了 NX。在尾部的 <code>RW</code> 表示堆栈是可读可写的；因为没有 <code>E</code>，所以堆栈是不可执行的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ readelf -W -l ./hello | grep GNU_STACK</span><br><span class="line">  GNU_STACK      0x000000 0x0000000000000000 0x0000000000000000 0x000000 0x000000 RW  0x10</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="演示如何禁用-NX"><a href="#演示如何禁用-NX" class="headerlink" title="演示如何禁用 NX"></a>演示如何禁用 NX</h5><p>我们不建议禁用 NX，但你可以在编译程序时，使用 <code>-z execstack</code> 参数，来禁用 NX：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -z execstack hello.c -o hello</span><br><span class="line"></span><br><span class="line">$ checksec --file=./hello --output=json | jq | grep nx</span><br><span class="line">    &quot;nx&quot;: &quot;no&quot;,</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>编译后，堆栈会变为可读可写可执行（<code>RWE</code>），允许在堆栈上的恶意代码执行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ readelf -W -l ./hello | grep GNU_STACK</span><br><span class="line">  GNU_STACK      0x000000 0x0000000000000000 0x0000000000000000 0x000000 0x000000 RWE 0x10</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="5、RELRO（GOT-写保护）"><a href="#5、RELRO（GOT-写保护）" class="headerlink" title="5、RELRO（GOT 写保护）"></a>5、RELRO（GOT 写保护）</h4><p>RELRO 代表 “<ruby>重定位只读 <rt>Relocation Read-Only</rt></ruby>”。可执行链接格式（ELF）二进制文件使用全局偏移表（GOT）来动态地解析函数。启用 RELRO 后，会设置二进制文件中的 GOT 表为只读，从而防止重定位攻击：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ checksec --file=/bin/ls --output=json | jq | grep relro</span><br><span class="line">    &quot;relro&quot;: &quot;full&quot;,</span><br><span class="line"></span><br><span class="line">$ checksec --file=./hello --output=json | jq | grep relro</span><br><span class="line">    &quot;relro&quot;: &quot;partial&quot;,</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Checksec 使用以下底层命令，来查找是否启用 RELRO。在二进制文件 <code>hello</code> 仅启用了 RELRO 属性中的一个属性，因此，在 Checksec 验证时，显示 <code>partial</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ readelf -W -l ./hello | grep GNU_RELRO</span><br><span class="line">  GNU_RELRO      0x002e10 0x0000000000403e10 0x0000000000403e10 0x0001f0 0x0001f0 R   0x1</span><br><span class="line"></span><br><span class="line">$ readelf -W -d ./hello | grep BIND_NOW</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="启用全-RELRO"><a href="#启用全-RELRO" class="headerlink" title="启用全 RELRO"></a>启用全 RELRO</h5><p>要启用全 RELRO，请在 <code>gcc</code> 编译时，使用以下命令行参数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -Wl,-z,relro,-z,now hello.c -o hello</span><br><span class="line"></span><br><span class="line">$ checksec --file=./hello --output=json | jq | grep relro</span><br><span class="line">    &quot;relro&quot;: &quot;full&quot;,</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>现在， RELRO 中的第二个属性也被启用，使程序变成全 RELRO：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ readelf -W -l ./hello | grep GNU_RELRO</span><br><span class="line">  GNU_RELRO      0x002dd0 0x0000000000403dd0 0x0000000000403dd0 0x000230 0x000230 R   0x1</span><br><span class="line"></span><br><span class="line">$ readelf -W -d ./hello | grep BIND_NOW</span><br><span class="line"> 0x0000000000000018 (BIND_NOW)       </span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="6、Fortify"><a href="#6、Fortify" class="headerlink" title="6、Fortify"></a>6、Fortify</h4><p>Fortify 是另一个安全属性，但它超出了本文的范围。Checksec 是如何在二进制文件中验证 Fortify，以及如何在 <code>gcc</code> 编译时启用 Fortify，作为你需要解决的课后练习。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ checksec --file=/bin/ls --output=json | jq  | grep -i forti</span><br><span class="line">    &quot;fortify_source&quot;: &quot;yes&quot;,</span><br><span class="line">    &quot;fortified&quot;: &quot;5&quot;,</span><br><span class="line">    &quot;fortify-able&quot;: &quot;17&quot;</span><br><span class="line"></span><br><span class="line">$ checksec --file=./hello --output=json | jq  | grep -i forti</span><br><span class="line">    &quot;fortify_source&quot;: &quot;no&quot;,</span><br><span class="line">    &quot;fortified&quot;: &quot;0&quot;,</span><br><span class="line">    &quot;fortify-able&quot;: &quot;0&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="其他的-Checksec-功能"><a href="#其他的-Checksec-功能" class="headerlink" title="其他的 Checksec 功能"></a>其他的 Checksec 功能</h3><p>关于安全性的话题是永无止境的，不可能在本文涵盖所有关于安全性的内容，但我还想提一下 Checksec 命令的一些其他功能，这些功能也很好用。</p><h4 id="对多个二进制文件运行-Checksec"><a href="#对多个二进制文件运行-Checksec" class="headerlink" title="对多个二进制文件运行 Checksec"></a>对多个二进制文件运行 Checksec</h4><p>你不必对每个二进制文件都进行一次 Checksec。相反，你可以提供多个二进制文件所在的目录路径，Checksec 将一次性为你验证所有文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ checksec --dir=/usr</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="对进程运行-Checksec"><a href="#对进程运行-Checksec" class="headerlink" title="对进程运行 Checksec"></a>对进程运行 Checksec</h4><p>Checksec 除了能检查二进制文件的安全属性，Checksec 还能对程序起作用。以下的命令用于查找你系统上所有正在运行的程序的安全属性。如果你希望 Checksec 检查所有正在运行的进程，可以使用 <code>--proc-all</code>，或者你也可以使用进程名称，选择特定的进程进行检查：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ checksec --proc-all</span><br><span class="line"></span><br><span class="line">$ checksec --proc=bash</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="对内核运行-Checksec"><a href="#对内核运行-Checksec" class="headerlink" title="对内核运行 Checksec"></a>对内核运行 Checksec</h4><p>除了本文介绍的用 Checksec 检查用户态应用程序的安全属性之外，你还可以使用它来检查系统内置的 <ruby>内核属性 <rt>kernel properties</rt></ruby>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ checksec --kernel</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="快来试一试-Checksec-吧"><a href="#快来试一试-Checksec-吧" class="headerlink" title="快来试一试 Checksec 吧"></a>快来试一试 Checksec 吧</h3><p>Checksec 是一个能了解哪些用户空间和内核的安全属性被启用的好方法。现在，你就可以开始使用 Checksec，来了解每个安全属性是什么，并明白启用每个安全属性的原因，以及它能阻止的攻击类型。</p><hr><p>via: <a target="_blank" rel="noopener" href="https://opensource.com/article/21/6/linux-checksec">https://opensource.com/article/21/6/linux-checksec</a></p><p>作者：<a target="_blank" rel="noopener" href="https://opensource.com/users/gkamathe">Gaurav Kamathe</a> 选题：<a target="_blank" rel="noopener" href="https://github.com/lujun9972">lujun9972</a> 译者：<a target="_blank" rel="noopener" href="https://github.com/chai001125">chai001125</a> 校对：<a target="_blank" rel="noopener" href="https://github.com/wxy">wxy</a></p><p>本文由 <a target="_blank" rel="noopener" href="https://github.com/LCTT/TranslateProject">LCTT</a> 原创编译，<a target="_blank" rel="noopener" href="https://linux.cn/">Linux中国</a> 荣誉推出</p></div></div></div><div class="footer"><p class="footer-copyright"><span>Powered by <a target="_blank" href="https://hexo.io">Hexo</a></span> <span>Theme <a target="_blank" href="https://github.com/tinkink-co/hexo-theme-terminal">Terminal</a></span><script type="text/javascript" src="https://cdn.staticfile.net/jquery/3.4.1/jquery.min.js"></script><script>getCDNinfo=function(){$.ajax({url:"/cdn-cgi/trace",success:function(a,n){let i="Antananarivo, Madagascar - (TNR);Cape Town, South Africa - (CPT);Casablanca, Morocco - (CMN);Dar Es Salaam, Tanzania - (DAR);Djibouti City, Djibouti - (JIB);Durban, South Africa - (DUR);Johannesburg, South Africa - (JNB);Kigali, Rwanda - (KGL);Lagos, Nigeria - (LOS);Luanda, Angola - (LAD);Maputo, MZ - (MPM);Mombasa, Kenya - (MBA);Port Louis, Mauritius - (MRU);Réunion, France - (RUN);Bangalore, India - (BLR);Bangkok, Thailand - (BKK);Bandar Seri Begawan, Brunei - (BWN);Cebu, Philippines - (CEB);Chengdu, China - (CTU);Chennai, India - (MAA);Chittagong, Bangladesh - (CGP);Chongqing, China - (CKG);Colombo, Sri Lanka - (CMB);Dhaka, Bangladesh - (DAC);Dongguan, China - (SZX);Foshan, China - (FUO);Fuzhou, China - (FOC);Guangzhou, China - (CAN);Hangzhou, China - (HGH);Hanoi, Vietnam - (HAN);Hengyang, China - (HNY);Ho Chi Minh City, Vietnam - (SGN);Hong Kong - (HKG);Hyderabad, India - (HYD);Islamabad, Pakistan - (ISB);Jakarta, Indonesia - (CGK);Jinan, China - (TNA);Karachi, Pakistan - (KHI);Kathmandu, Nepal - (KTM);Kolkata, India - (CCU);Kuala Lumpur, Malaysia - (KUL);Lahore, Pakistan - (LHE);Langfang, China - (NAY);Luoyang, China - (LYA);Macau - (MFM);Malé, Maldives - (MLE);Manila, Philippines - (MNL);Mumbai, India - (BOM);Nagpur, India - (NAG);Nanning, China - (NNG);New Delhi, India - (DEL);Osaka, Japan - (KIX);Phnom Penh, Cambodia - (PNH);Qingdao, China - (TAO);Seoul, South Korea - (ICN);Shanghai, China - (SHA);Shenyang, China - (SHE);Shijiazhuang, China - (SJW);Singapore, Singapore - (SIN);Suzhou, China - (SZV);Taipei - (TPE);Thimphu, Bhutan - (PBH);Tianjin, China - (TSN);Tokyo, Japan - (NRT);Ulaanbaatar, Mongolia - (ULN);Vientiane, Laos - (VTE);Wuhan, China - (WUH);Wuxi, China - (WUX);Xi'an, China - (XIY);Yerevan, Armenia - (EVN);Zhengzhou, China - (CGO);Zuzhou, China - (CSX);Amsterdam, Netherlands - (AMS);Athens, Greece - (ATH);Barcelona, Spain - (BCN);Belgrade, Serbia - (BEG);Berlin, Germany - (TXL);Brussels, Belgium - (BRU);Bucharest, Romania - (OTP);Budapest, Hungary - (BUD);Chișinău, Moldova - (KIV);Copenhagen, Denmark - (CPH);Cork, Ireland -  (ORK);Dublin, Ireland - (DUB);Düsseldorf, Germany - (DUS);Edinburgh, United Kingdom - (EDI);Frankfurt, Germany - (FRA);Geneva, Switzerland - (GVA);Gothenburg, Sweden - (GOT);Hamburg, Germany - (HAM);Helsinki, Finland - (HEL);Istanbul, Turkey - (IST);Kyiv, Ukraine - (KBP);Lisbon, Portugal - (LIS);London, United Kingdom - (LHR);Luxembourg City, Luxembourg - (LUX);Madrid, Spain - (MAD);Manchester, United Kingdom - (MAN);Marseille, France - (MRS);Milan, Italy - (MXP);Moscow, Russia - (DME);Munich, Germany - (MUC);Nicosia, Cyprus - (LCA);Oslo, Norway - (OSL);Paris, France - (CDG);Prague, Czech Republic - (PRG);Reykjavík, Iceland - (KEF);Riga, Latvia - (RIX);Rome, Italy - (FCO);Saint Petersburg, Russia - (LED);Sofia, Bulgaria - (SOF);Stockholm, Sweden - (ARN);Tallinn, Estonia - (TLL);Thessaloniki, Greece - (SKG);Vienna, Austria - (VIE);Vilnius, Lithuania - (VNO);Warsaw, Poland - (WAW);Zagreb, Croatia - (ZAG);Zürich, Switzerland - (ZRH);Arica, Chile - (ARI);Asunción, Paraguay - (ASU);Bogotá, Colombia - (BOG);Buenos Aires, Argentina - (EZE);Curitiba, Brazil - (CWB);Fortaleza, Brazil - (FOR);Guatemala City, Guatemala - (GUA);Lima, Peru - (LIM);Medellín, Colombia - (MDE);Panama City, Panama - (PTY);Porto Alegre, Brazil - (POA);Quito, Ecuador - (UIO);Rio de Janeiro, Brazil - (GIG);São Paulo, Brazil - (GRU);Santiago, Chile - (SCL);Willemstad, Curaçao - (CUR);St. George's, Grenada - (GND);Amman, Jordan - (AMM);Baghdad, Iraq - (BGW);Baku, Azerbaijan - (GYD);Beirut, Lebanon - (BEY);Doha, Qatar - (DOH);Dubai, United Arab Emirates - (DXB);Kuwait City, Kuwait - (KWI);Manama, Bahrain - (BAH);Muscat, Oman - (MCT);Ramallah - (ZDM);Riyadh, Saudi Arabia - (RUH);Tel Aviv, Israel - (TLV);Ashburn, VA, United States - (IAD);Atlanta, GA, United States - (ATL);Boston, MA, United States - (BOS);Buffalo, NY, United States - (BUF);Calgary, AB, Canada - (YYC);Charlotte, NC, United States - (CLT);Chicago, IL, United States - (ORD);Columbus, OH, United States - (CMH);Dallas, TX, United States - (DFW);Denver, CO, United States - (DEN);Detroit, MI, United States - (DTW);Honolulu, HI, United States - (HNL);Houston, TX, United States - (IAH);Indianapolis, IN, United States - (IND);Jacksonville, FL, United States - (JAX);Kansas City, MO, United States - (MCI);Las Vegas, NV, United States - (LAS);Los Angeles, CA, United States - (LAX);McAllen, TX, United States - (MFE);Memphis, TN, United States - (MEM);Mexico City, Mexico - (MEX);Miami, FL, United States - (MIA);Minneapolis, MN, United States - (MSP);Montgomery, AL, United States - (MGM);Montréal, QC, Canada - (YUL);Nashville, TN, United States - (BNA);Newark, NJ, United States - (EWR);Norfolk, VA, United States - (ORF);Omaha, NE, United States - (OMA);Philadelphia, United States - (PHL);Phoenix, AZ, United States - (PHX);Pittsburgh, PA, United States - (PIT);Port-Au-Prince, Haiti - (PAP);Portland, OR, United States - (PDX);Queretaro, MX, Mexico - (QRO);Richmond, Virginia - (RIC);Sacramento, CA, United States - (SMF);Salt Lake City, UT, United States - (SLC);San Diego, CA, United States - (SAN);San Jose, CA, United States - (SJC);Saskatoon, SK, Canada - (YXE);Seattle, WA, United States - (SEA);St. Louis, MO, United States - (STL);Tampa, FL, United States - (TPA);Toronto, ON, Canada - (YYZ);Vancouver, BC, Canada - (YVR);Tallahassee, FL, United States - (TLH);Winnipeg, MB, Canada - (YWG);Adelaide, SA, Australia - (ADL);Auckland, New Zealand - (AKL);Brisbane, QLD, Australia - (BNE);Melbourne, VIC, Australia - (MEL);Noumea, New caledonia - (NOU);Perth, WA, Australia - (PER);Sydney, NSW, Australia - (SYD)".split(";"),e=a.split("colo=")[1].split("\n")[0],t=(a.split("colo=")[1].split("\n")[0],a.split("tls=")[1].split("\n")[0]),o=a.split("http=")[1].split("\n")[0],s=a.split("sni=")[1].split("\n")[0],r=a.split("ip=")[1].split("\n")[0],l=a.split("uag=")[1].split("\n")[0];for(var d=0;d<i.length;d++)if(-1!=i[d].indexOf(e)){document.getElementById("cdn").innerHTML=i[d];break}document.getElementById("tls").innerHTML=t,document.getElementById("http").innerHTML=o,document.getElementById("sni").innerHTML=s,document.getElementById("ip").innerHTML=r,document.getElementById("useragent").innerHTML=l}})},$(document).ready((function(){getCDNinfo()}))</script></p><p style="text-align:center">感谢陪伴与布道，开源之火不灭。​</p><p style="text-align:center"><script>document.write("本次加载耗时: "+(performance.getEntriesByType("navigation").reduce((e,r)=>e+r.responseEnd-r.startTime,0)+performance.getEntriesByType("resource").reduce((e,r)=>e+r.responseEnd-r.startTime,0)).toFixed(0)+"ms")</script></p><p style="text-align:center">当前 SNI 状态： <span id="sni">正在统计！或可能被浏览器防追踪拦截！</span></p><p style="text-align:center">当前 TLS 版本： <span id="tls">正在统计！或可能被浏览器防追踪拦截！</span></p><p style="text-align:center">当前 HTTP 版本： <span id="http">正在统计！或可能被浏览器防追踪拦截！</span></p><p style="text-align:center">当前您的客户端 IP 是： <span id="ip">正在统计！或可能被浏览器防追踪拦截！</span></p><p style="text-align:center">当前分配的 CDN 节点是: <span id="cdn">正在统计！或可能被浏览器防追踪拦截！</span></p><p style="text-align:center">您的 UserAgent 信息是: <span id="useragent">正在统计！或可能被浏览器防追踪拦截！</span></p><p></p></div></div></body></html>