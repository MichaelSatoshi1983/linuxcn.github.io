<!doctype html><html lang="en"><head><meta name="msvalidate.01" content="D404690CEFCB54C7762AC84935B99171"><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?6618da70c90c8744eead2e9371fb5077";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><script type="text/javascript">!function(t,e,n,c,s,a,r){t[n]=t[n]||function(){(t[n].q=t[n].q||[]).push(arguments)},(a=e.createElement(c)).async=1,a.src="https://www.clarity.ms/tag/s5f3f0tojf",(r=e.getElementsByTagName(c)[0]).parentNode.insertBefore(a,r)}(window,document,"clarity","script")</script><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta http-equiv="X-UA-Compatible" content="ie=edge"><link rel="stylesheet" href="/styles/base.css"><link rel="stylesheet" href="/styles/theme.css"><link rel="shortcut icon" href="/favicon.png"><title>怎么使用 SVG 作为一个图像占位符 - 归墟星火集</title><meta name="generator" content="Hexo 7.3.0"></head><body><div class="header-title"><span class="header-light"></span> <span class="header-light"></span> <span class="header-light"></span> <span>归墟星火集 linuxcn.undefined.today<span></span></span></div><div class="container"><ul class="nav"><li><a href="/">首页</a></li><li><a href="/about/">关于</a></li><li><a target="_blank" rel="noopener" href="https://undefined.today/">Blog</a></li></ul><div class="content"><div class="post-container"><div class="post-header"><span class="ui-tips">标题：</span><h1 class="ui-keyword post-title">怎么使用 SVG 作为一个图像占位符</h1><span class="post-date">2017-12-13</span></div><div class="post-header"><span class="ui-tips">分类：</span> <a href="/categories/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/">软件开发</a></div><div class="post-header"><span class="ui-tips">标签：</span> <a href="/tags/%E5%9B%BE%E5%83%8F/">图像</a> <a href="/tags/SVG/">SVG</a> <a href="/tags/%E5%8D%A0%E4%BD%8D%E7%AC%A6/">占位符</a></div><div class="post-content"><p><img src="https://linuxcn.img.undefined.today/data/attachment/album/201712/13/232720zg4qcuccgx7xcncm.jpg"></p><p><em>从图像中生成的 SVG 可以用作占位符。请继续阅读！</em></p><p>我对怎么去让 web 性能更优化和图像加载的更快充满了热情。在这些感兴趣的领域中的其中一项研究就是占位符：当图像还没有被加载的时候应该去展示些什么？</p><p>在前些天，我偶然发现了使用 SVG 的一些加载技术，我将在这篇文章中谈论它。</p><p>在这篇文章中我们将涉及如下的主题：</p><ul><li>不同的占位符类型的概述</li><li>基于 SVG 的占位符（边缘、形状和轮廓）</li><li>自动化处理</li></ul><h3 id="不同的占位符类型的概述"><a href="#不同的占位符类型的概述" class="headerlink" title="不同的占位符类型的概述"></a>不同的占位符类型的概述</h3><p>之前 <a target="_blank" rel="noopener" href="https://medium.com/@jmperezperez/lazy-loading-images-on-the-web-to-improve-loading-time-and-saving-bandwidth-ec988b710290">我写过一篇关于图像占位符和<ruby>延迟加载 <rt>lazy-loading</rt></ruby></a> 的文章以及 <a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=szmVNOnkwoU">关于它的讨论</a>。当进行一个图像的延迟加载时，一个很好的办法是提供一个东西作为占位符，因为它可能会很大程度上影响用户的感知体验。之前我提供了几个选择：</p><p><img src="https://linuxcn.img.undefined.today/data/attachment/album/201712/13/232721vsyanhvsybjnujon.png"></p><p>在图像被加载之前，有几种办法去填充图像区域：</p><ul><li>在图像区域保持空白：在一个响应式设计的环境中，这种方式防止了内容的跳跃。从用户体验的角度来看，那些布局的改变是非常差的作法。但是，它是为了性能的考虑，否则，每次为了获取图像尺寸，浏览器就要被迫进行布局重新计算，以便为它留下空间。</li><li>占位符：在图像那里显示一个用户配置的图像。我们可以在背景上显示一个轮廓。它一直显示直到实际的图像被加载完成，它也被用于当请求失败或者当用户根本没有设置头像图像的情况下。这些图像一般都是矢量图，并且由于尺寸非常小，可以作为内联图片。</li><li>单一颜色：从图像中获取颜色，并将其作为占位符的背景颜色。这可能是图像的主要颜色、最具活力的颜色 … 这个想法是基于你正在加载的图像，并且它将有助于在没有图像和图像加载完成之间进行平滑过渡。</li><li>模糊的图像：也被称为模糊技术。你提供一个极小版本的图像，然后再去过渡到完整的图像。最初显示的图像的像素和尺寸是极小的。为去除<ruby>细节 <rt>artifacts</rt></ruby>，该图像会被放大并模糊化。我在前面写的 <a target="_blank" rel="noopener" href="https://medium.com/@jmperezperez/how-medium-does-progressive-image-loading-fd1e4dc1ee3d">Medium 是怎么做的渐进加载图像</a>、<a target="_blank" rel="noopener" href="https://medium.com/@jmperezperez/using-webp-to-create-tiny-preview-images-3e9b924f28d6">使用 WebP 去创建极小的预览图像</a>、和<a target="_blank" rel="noopener" href="https://medium.com/@jmperezperez/more-examples-of-progressive-image-loading-f258be9f440b">渐进加载图像的更多示例</a> 中讨论过这方面的内容。</li></ul><p>此外还有其它的更多的变种，许多聪明的人也开发了其它的创建占位符的技术。</p><p>其中一个就是用梯度图代替单一的颜色。梯度图可以创建一个更精确的最终图像的预览，它整体上非常小（提升了有效载荷）。</p><p><img src="https://linuxcn.img.undefined.today/data/attachment/album/201712/13/232722yncfox1n1c9zr191.jpg"></p><p><em>使用梯度图作为背景。这是来自 Gradify 的截屏，它现在已经不在线了，代码 <a target="_blank" rel="noopener" href="https://github.com/fraser-hemp/gradify">在 GitHub</a>。</em></p><p>另外一种技术是使用基于 SVG 的技术，它在最近的实验和研究中取得到了一些进展。</p><h3 id="基于-SVG-的占位符"><a href="#基于-SVG-的占位符" class="headerlink" title="基于 SVG 的占位符"></a>基于 SVG 的占位符</h3><p>我们知道 SVG 是完美的矢量图像。而在大多数情况下我们是希望加载一个位图，所以，问题是怎么去矢量化一个图像。其中一些方法是使用边缘、形状和轮廓。</p><h4 id="边缘"><a href="#边缘" class="headerlink" title="边缘"></a>边缘</h4><p>在 <a target="_blank" rel="noopener" href="https://medium.com/@jmperezperez/drawing-images-using-edge-detection-and-svg-animation-16a1a3676d3">前面的文章中</a>，我解释了怎么去找出一个图像的边缘并创建一个动画。我最初的目标是去尝试绘制区域，矢量化该图像，但是我并不知道该怎么去做到。我意识到使用边缘也可能是一种创新，我决定去让它们动起来，创建一个 “绘制” 的效果。</p><ul><li><a target="_blank" rel="noopener" href="https://codepen.io/jmperez/embed/oogqdp?default-tabs=html,result&embed-version=2&height=600&host=https://codepen.io&referrer=https://medium.freecodecamp.org/media/8c5c44a4adf82b09692a34eb4daa3e2e?postId=bed1b810ab2c&slug-hash=oogqdp#result-box">范例</a></li></ul><blockquote><p><a target="_blank" rel="noopener" href="https://medium.com/@jmperezperez/drawing-images-using-edge-detection-and-svg-animation-16a1a3676d3">使用边缘检测绘制图像和 SVG 动画</a></p><p>在以前，很少使用和支持 SVG。一段时间以后，我们开始用它去作为一个某些图标的传统位图的替代品……</p></blockquote><h4 id="形状"><a href="#形状" class="headerlink" title="形状"></a>形状</h4><p>SVG 也可以用于根据图像绘制区域而不是边缘&#x2F;边界。用这种方法，我们可以矢量化一个位图来创建一个占位符。</p><p>在以前，我尝试去用三角形做类似的事情。你可以在 <a target="_blank" rel="noopener" href="https://jmperezperez.com/cssconfau16/#/45">CSSConf</a> 和 <a target="_blank" rel="noopener" href="https://jmperezperez.com/renderconf17/#/46">Render Conf</a> 上我的演讲中看到它。</p><ul><li><a target="_blank" rel="noopener" href="https://codepen.io/jmperez/embed/BmaWmQ?default-tabs=html,result&embed-version=2&height=600&host=https://codepen.io&referrer=https://medium.freecodecamp.org/media/05d1ee44f0537f8257258124d7b94613?postId=bed1b810ab2c&slug-hash=BmaWmQ#result-box">范例</a></li></ul><p>上面的 codepen 是一个由 245 个三角形组成的基于 SVG 占位符的概念验证。生成的三角形是基于 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Delaunay_triangulation">Delaunay triangulation</a> 的，使用了 <a target="_blank" rel="noopener" href="https://github.com/possan/polyserver">Possan’s polyserver</a>。正如预期的那样，使用更多的三角形，文件尺寸就更大。</p><h4 id="Primitive-和-SQIP，一个基于-SVG-的-LQIP-技术"><a href="#Primitive-和-SQIP，一个基于-SVG-的-LQIP-技术" class="headerlink" title="Primitive 和 SQIP，一个基于 SVG 的 LQIP 技术"></a>Primitive 和 SQIP，一个基于 SVG 的 LQIP 技术</h4><p>Tobias Baldauf 正在致力于另一个使用 SVG 的低质量图像占位符技术，它被称为 <a target="_blank" rel="noopener" href="https://github.com/technopagan/sqip">SQIP</a>。在深入研究 SQIP 之前，我先简单介绍一下 <a target="_blank" rel="noopener" href="https://github.com/fogleman/primitive">Primitive</a>，它是基于 SQIP 的一个库。</p><p>Primitive 是非常吸引人的，我强烈建议你去了解一下。它讲解了一个位图怎么变成由重叠形状组成的 SVG。它尺寸比较小，适合于直接内联放置到页面中。当步骤较少时，在初始的 HTML 载荷中作为占位符是非常有意义的。</p><p>Primitive 基于三角形、长方形、和圆形等形状生成一个图像。在每一步中它增加一个新形状。很多步之后，图像的结果看起来非常接近原始图像。如果你输出的是 SVG，它意味着输出代码的尺寸将很大。</p><p>为了理解 Primitive 是怎么工作的，我通过几个图像来跑一下它。我用 10 个形状和 100 个形状来为这个插画生成 SVG：</p><table><thead><tr><th></th><th></th><th></th></tr></thead><tbody><tr><td></td><td></td><td></td></tr><tr><td>使用 Primitive 处理 ，使用 <a target="_blank" rel="noopener" href="https://jmperezperez.com/assets/images/posts/svg-placeholders/pexels-photo-281184-square-10.svg">10 个形状</a> 、 <a target="_blank" rel="noopener" href="https://jmperezperez.com/assets/images/posts/svg-placeholders/pexels-photo-281184-square-100.svg">100 形状</a>、 <a target="_blank" rel="noopener" href="https://jmperezperez.com/assets/images/posts/svg-placeholders/pexels-photo-281184-square.jpg">原图</a>。</td><td></td><td></td></tr></tbody></table><table><thead><tr><th></th><th></th><th></th></tr></thead><tbody><tr><td></td><td></td><td></td></tr><tr><td>使用 Primitive 处理，使用 <a target="_blank" rel="noopener" href="https://jmperezperez.com/assets/images/posts/svg-placeholders/pexels-photo-618463-square-10.svg">10 形状</a> 、 <a target="_blank" rel="noopener" href="https://jmperezperez.com/assets/images/posts/svg-placeholders/pexels-photo-618463-square-100.svg">100 形状</a>、 <a target="_blank" rel="noopener" href="https://jmperezperez.com/assets/images/posts/svg-placeholders/pexels-photo-618463-square.jpg">原图</a> 。</td><td></td><td></td></tr></tbody></table><p>当在图像中使用 10 个形状时，我们基本构画出了原始图像。在图像占位符这种使用场景里，我们可以使用这种 SVG 作为潜在的占位符。实际上，使用 10 个形状的 SVG 代码已经很小了，大约是 1030 字节，当通过 SVGO 传输时，它将下降到约 640 字节。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;svg xmlns=”http://www.w3.org/2000/svg&quot; width=”1024&quot; height=”1024&quot;&gt;&lt;path fill=”#817c70&quot; d=”M0 0h1024v1024H0z”/&gt;&lt;g fill-opacity=”.502&quot;&gt;&lt;path fill=”#03020f” d=”M178 994l580 92L402–62&quot;/&gt;&lt;path fill=”#f2e2ba” d=”M638 894L614 6l472 440&quot;/&gt;&lt;path fill=”#fff8be” d=”M-62 854h300L138–62&quot;/&gt;&lt;path fill=”#76c2d9&quot; d=”M410–62L154 530–62 38&quot;/&gt;&lt;path fill=”#62b4cf” d=”M1086–2L498–30l484 508&quot;/&gt;&lt;path fill=”#010412&quot; d=”M430–2l196 52–76 356&quot;/&gt;&lt;path fill=”#eb7d3f” d=”M598 594l488–32–308 520&quot;/&gt;&lt;path fill=”#080a18&quot; d=”M198 418l32 304 116–448&quot;/&gt;&lt;path fill=”#3f201d” d=”M1086 1062l-344–52 248–148&quot;/&gt;&lt;path fill=”#ebd29f” d=”M630 658l-60–372 516 320&quot;/&gt;&lt;/g&gt;&lt;/svg&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>正如我们预计的那样，使用 100 个形状生成的图像更大，在 SVGO（之前是 8kB）之后，大小约为 5kB。它们在细节上已经很好了，但是仍然是个很小的载荷。使用多少三角形主要取决于图像类型和细腻程度（如，对比度、颜色数量、复杂度）。</p><p>还可以创建一个类似于 <a target="_blank" rel="noopener" href="https://github.com/technopagan/cjpeg-dssim">cpeg-dssim</a> 的脚本，去调整所使用的形状的数量，以满足 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Structural_similarity">结构相似</a> 的阈值（或者最差情况中的最大数量）。</p><p>这些生成的 SVG 也可以用作背景图像。因为尺寸约束和矢量化，它们在展示<ruby>超大题图 <rt>hero image</rt></ruby>和大型背景图像时是很好的选择。</p><h4 id="SQIP"><a href="#SQIP" class="headerlink" title="SQIP"></a>SQIP</h4><p>用 <a target="_blank" rel="noopener" href="https://github.com/technopagan/sqip">Tobias 自己的话说</a>：</p><blockquote><p>SQIP 尝试在这两个极端之间找到一种平衡：它使用 <a target="_blank" rel="noopener" href="https://github.com/fogleman/primitive">Primitive</a> 去生成一个 SVG，由几种简单的形状构成，近似于图像中可见的主要特征，使用 <a target="_blank" rel="noopener" href="https://github.com/svg/svgo">SVGO</a> 优化 SVG，并且为它增加高斯模糊滤镜。产生的最终的 SVG 占位符后大小仅为约 800~1000 字节，在屏幕上看起来更为平滑，并提供一个图像内容的视觉提示。</p></blockquote><p>这个结果和使用一个用了模糊技术的极小占位符图像类似。（看看 <a target="_blank" rel="noopener" href="https://medium.com/@jmperezperez/how-medium-does-progressive-image-loading-fd1e4dc1ee3d">Medium</a> 和 <a target="_blank" rel="noopener" href="https://medium.com/@jmperezperez/more-examples-of-progressive-image-loading-f258be9f440b">其它站点</a> 是怎么做的）。区别在于它们使用了一个位图图像，如 JPG 或者 WebP，而这里是使用的占位符是 SVG。</p><p>如果我们使用 SQIP 而不是原始图像，我们将得到这样的效果：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td></td></tr><tr><td><a target="_blank" rel="noopener" href="https://jmperezperez.com/assets/images/posts/svg-placeholders/pexels-photo-281184-square-sqip.svg">第一张图像</a> 和 <a target="_blank" rel="noopener" href="https://jmperezperez.com/svg-placeholders/%28/assets/images/posts/svg-placeholders/pexels-photo-618463-square-sqip.svg">第二张图像</a> 使用了 SQIP 后的输出图像。</td><td></td></tr></tbody></table><p>输出的 SVG 约 900 字节，并且通过检查代码，我们可以发现 <code>feGaussianBlur</code> 过滤被应用到该组形状上：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; viewBox=&quot;0 0 2000 2000&quot;&gt;&lt;filter id=&quot;b&quot;&gt;&lt;feGaussianBlur stdDeviation=&quot;12&quot; /&gt;&lt;/filter&gt;&lt;path fill=&quot;#817c70&quot; d=&quot;M0 0h2000v2000H0z&quot;/&gt;&lt;g filter=&quot;url(#b)&quot; transform=&quot;translate(4 4) scale(7.8125)&quot; fill-opacity=&quot;.5&quot;&gt;&lt;ellipse fill=&quot;#000210&quot; rx=&quot;1&quot; ry=&quot;1&quot; transform=&quot;matrix(50.41098 -3.7951 11.14787 148.07886 107 194.6)&quot;/&gt;&lt;ellipse fill=&quot;#eee3bb&quot; rx=&quot;1&quot; ry=&quot;1&quot; transform=&quot;matrix(-56.38179 17.684 -24.48514 -78.06584 205 110.1)&quot;/&gt;&lt;ellipse fill=&quot;#fff4bd&quot; rx=&quot;1&quot; ry=&quot;1&quot; transform=&quot;matrix(35.40604 -5.49219 14.85017 95.73337 16.4 123.6)&quot;/&gt;&lt;ellipse fill=&quot;#79c7db&quot; cx=&quot;21&quot; cy=&quot;39&quot; rx=&quot;65&quot; ry=&quot;65&quot;/&gt;&lt;ellipse fill=&quot;#0c1320&quot; cx=&quot;117&quot; cy=&quot;38&quot; rx=&quot;34&quot; ry=&quot;47&quot;/&gt;&lt;ellipse fill=&quot;#5cb0cd&quot; rx=&quot;1&quot; ry=&quot;1&quot; transform=&quot;matrix(-39.46201 77.24476 -54.56092 -27.87353 219.2 7.9)&quot;/&gt;&lt;path fill=&quot;#e57339&quot; d=&quot;M271 159l-123–16 43 128z&quot;/&gt;&lt;ellipse fill=&quot;#47332f&quot; cx=&quot;214&quot; cy=&quot;237&quot; rx=&quot;242&quot; ry=&quot;19&quot;/&gt;&lt;/g&gt;&lt;/svg&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>SQIP 也可以输出一个带有 Base64 编码的 SVG 内容的图像标签：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;img width=&quot;640&quot; height=&quot;640&quot; src=&quot;example.jpg” alt=&quot;Add descriptive alt text&quot; style=&quot;background-size: cover; background-image: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAw…&lt;stripped base 64&gt;…PjwvZz48L3N2Zz4=);&quot;&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="轮廓"><a href="#轮廓" class="headerlink" title="轮廓"></a>轮廓</h4><p>我们刚才看了使用了边缘和原始形状的 SVG。另外一种矢量化图像的方式是 “描绘” 它们。在几天前 <a target="_blank" rel="noopener" href="https://twitter.com/mikaelainalem">Mikael Ainalem</a> 分享了一个 <a target="_blank" rel="noopener" href="https://codepen.io/ainalem/full/aLKxjm/">codepen</a> 代码，展示了怎么去使用两色轮廓作为一个占位符。结果非常漂亮：</p><p><img src="https://linuxcn.img.undefined.today/data/attachment/album/201712/13/232733frqepv77stztq253.gif"></p><p>SVG 在这种情况下是手工绘制的，但是，这种技术可以用工具快速生成并自动化处理。</p><ul><li><a target="_blank" rel="noopener" href="https://www.gatsbyjs.org/">Gatsby</a>，一个用 React 支持的描绘 SVG 的静态网站生成器。它使用 <a target="_blank" rel="noopener" href="https://www.npmjs.com/package/potrace">一个 potrace 算法的 JS 移植</a> 去矢量化图像。</li><li><a target="_blank" rel="noopener" href="https://craftcms.com/">Craft 3 CMS</a>，它也增加了对轮廓的支持。它使用了 <a target="_blank" rel="noopener" href="https://github.com/nystudio107/craft3-imageoptimize/blob/master/src/lib/Potracio.php">一个 potrace 算法的 PHP 移植</a>。</li><li><a target="_blank" rel="noopener" href="https://github.com/EmilTholin/image-trace-loader">image-trace-loader</a>，一个使用了 potrace 算法去处理图像的 Webpack 加载器。</li></ul><p>如果感兴趣，可以去看一下 Emil 的 webpack 加载器 (基于 potrace) 和 Mikael 的手工绘制 SVG 之间的比较。</p><p>这里我假设该输出是使用默认选项的 potrace 生成的。但是可以对它们进行优化。查看 <a target="_blank" rel="noopener" href="https://github.com/EmilTholin/image-trace-loader#options">图像描绘加载器的选项</a>，<a target="_blank" rel="noopener" href="https://www.npmjs.com/package/potrace#parameters">传递给 potrace 的选项</a>非常丰富。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>我们看到了从图像中生成 SVG 并使用它们作为占位符的各种不同的工具和技术。与 <a target="_blank" rel="noopener" href="https://medium.com/@jmperezperez/using-webp-to-create-tiny-preview-images-3e9b924f28d6">WebP 是一个用于缩略图的奇妙格式</a> 一样，SVG 也是一个用于占位符的有趣格式。我们可以控制细节的级别（和它们的大小），它是高可压缩的，并且很容易用 CSS 和 JS 进行处理。</p><h4 id="额外的资源"><a href="#额外的资源" class="headerlink" title="额外的资源"></a>额外的资源</h4><p>这篇文章上到了 <a target="_blank" rel="noopener" href="https://news.ycombinator.com/item?id=15696596">Hacker News 热文</a>。对此以及在该页面的评论中分享的其它资源的链接，我表示非常感谢。下面是其中一部分。</p><ul><li><a target="_blank" rel="noopener" href="https://github.com/Tw1ddle/geometrize-haxe">Geometrize</a> 是用 Haxe 写的 Primitive 的一个移植。也有<a target="_blank" rel="noopener" href="https://github.com/Tw1ddle/geometrize-haxe-web">一个 JS 实现</a>，你可以直接 <a target="_blank" rel="noopener" href="http://www.samcodes.co.uk/project/geometrize-haxe-web/">在你的浏览器上</a>尝试它。</li><li><a target="_blank" rel="noopener" href="https://github.com/ondras/primitive.js">Primitive.js</a>，它也是 Primitive 在 JS 中的一个移植，<a target="_blank" rel="noopener" href="https://github.com/cielito-lindo-productions/primitive.nextgen">primitive.nextgen</a>，它是使用 Primitive.js 和 Electron 的 Primitive 的桌面版应用的一个移植。</li><li>这里有两个 Twitter 帐户，里面你可以看到一些用 Primitive 和 Geometrize 生成的图像示例。访问 <a target="_blank" rel="noopener" href="https://twitter.com/PrimitivePic">@PrimitivePic</a> 和 <a target="_blank" rel="noopener" href="https://twitter.com/Geometrizer">@Geometrizer</a>。</li><li><a target="_blank" rel="noopener" href="https://github.com/jankovicsandras/imagetracerjs">imagetracerjs</a>，它是在 JavaScript 中的光栅图像描绘器和矢量化程序。这里也有为 <a target="_blank" rel="noopener" href="https://github.com/jankovicsandras/imagetracerjava">Java</a> 和 <a target="_blank" rel="noopener" href="https://github.com/jankovicsandras/imagetracerandroid">Android</a> 提供的移植。</li></ul><hr><p>via: <a target="_blank" rel="noopener" href="https://medium.freecodecamp.org/using-svg-as-placeholders-more-image-loading-techniques-bed1b810ab2c">https://medium.freecodecamp.org/using-svg-as-placeholders-more-image-loading-techniques-bed1b810ab2c</a></p><p>作者：<a target="_blank" rel="noopener" href="https://medium.freecodecamp.org/@jmperezperez?source=post_header_lockup">José M. Pérez</a> 译者：<a target="_blank" rel="noopener" href="https://github.com/qhwdw">qhwdw</a> 校对：<a target="_blank" rel="noopener" href="https://github.com/wxy">wxy</a></p><p>本文由 <a target="_blank" rel="noopener" href="https://github.com/LCTT/TranslateProject">LCTT</a> 原创编译，<a target="_blank" rel="noopener" href="https://linux.cn/">Linux中国</a> 荣誉推出</p></div></div></div><div class="footer"><p class="footer-copyright"><span>Powered by <a target="_blank" href="https://hexo.io">Hexo</a></span> <span>Theme <a target="_blank" href="https://github.com/tinkink-co/hexo-theme-terminal">Terminal</a></span><script type="text/javascript" src="https://cdn.staticfile.net/jquery/3.4.1/jquery.min.js"></script><script>getCDNinfo=function(){$.ajax({url:"/cdn-cgi/trace",success:function(a,n){let i="Antananarivo, Madagascar - (TNR);Cape Town, South Africa - (CPT);Casablanca, Morocco - (CMN);Dar Es Salaam, Tanzania - (DAR);Djibouti City, Djibouti - (JIB);Durban, South Africa - (DUR);Johannesburg, South Africa - (JNB);Kigali, Rwanda - (KGL);Lagos, Nigeria - (LOS);Luanda, Angola - (LAD);Maputo, MZ - (MPM);Mombasa, Kenya - (MBA);Port Louis, Mauritius - (MRU);Réunion, France - (RUN);Bangalore, India - (BLR);Bangkok, Thailand - (BKK);Bandar Seri Begawan, Brunei - (BWN);Cebu, Philippines - (CEB);Chengdu, China - (CTU);Chennai, India - (MAA);Chittagong, Bangladesh - (CGP);Chongqing, China - (CKG);Colombo, Sri Lanka - (CMB);Dhaka, Bangladesh - (DAC);Dongguan, China - (SZX);Foshan, China - (FUO);Fuzhou, China - (FOC);Guangzhou, China - (CAN);Hangzhou, China - (HGH);Hanoi, Vietnam - (HAN);Hengyang, China - (HNY);Ho Chi Minh City, Vietnam - (SGN);Hong Kong - (HKG);Hyderabad, India - (HYD);Islamabad, Pakistan - (ISB);Jakarta, Indonesia - (CGK);Jinan, China - (TNA);Karachi, Pakistan - (KHI);Kathmandu, Nepal - (KTM);Kolkata, India - (CCU);Kuala Lumpur, Malaysia - (KUL);Lahore, Pakistan - (LHE);Langfang, China - (NAY);Luoyang, China - (LYA);Macau - (MFM);Malé, Maldives - (MLE);Manila, Philippines - (MNL);Mumbai, India - (BOM);Nagpur, India - (NAG);Nanning, China - (NNG);New Delhi, India - (DEL);Osaka, Japan - (KIX);Phnom Penh, Cambodia - (PNH);Qingdao, China - (TAO);Seoul, South Korea - (ICN);Shanghai, China - (SHA);Shenyang, China - (SHE);Shijiazhuang, China - (SJW);Singapore, Singapore - (SIN);Suzhou, China - (SZV);Taipei - (TPE);Thimphu, Bhutan - (PBH);Tianjin, China - (TSN);Tokyo, Japan - (NRT);Ulaanbaatar, Mongolia - (ULN);Vientiane, Laos - (VTE);Wuhan, China - (WUH);Wuxi, China - (WUX);Xi'an, China - (XIY);Yerevan, Armenia - (EVN);Zhengzhou, China - (CGO);Zuzhou, China - (CSX);Amsterdam, Netherlands - (AMS);Athens, Greece - (ATH);Barcelona, Spain - (BCN);Belgrade, Serbia - (BEG);Berlin, Germany - (TXL);Brussels, Belgium - (BRU);Bucharest, Romania - (OTP);Budapest, Hungary - (BUD);Chișinău, Moldova - (KIV);Copenhagen, Denmark - (CPH);Cork, Ireland -  (ORK);Dublin, Ireland - (DUB);Düsseldorf, Germany - (DUS);Edinburgh, United Kingdom - (EDI);Frankfurt, Germany - (FRA);Geneva, Switzerland - (GVA);Gothenburg, Sweden - (GOT);Hamburg, Germany - (HAM);Helsinki, Finland - (HEL);Istanbul, Turkey - (IST);Kyiv, Ukraine - (KBP);Lisbon, Portugal - (LIS);London, United Kingdom - (LHR);Luxembourg City, Luxembourg - (LUX);Madrid, Spain - (MAD);Manchester, United Kingdom - (MAN);Marseille, France - (MRS);Milan, Italy - (MXP);Moscow, Russia - (DME);Munich, Germany - (MUC);Nicosia, Cyprus - (LCA);Oslo, Norway - (OSL);Paris, France - (CDG);Prague, Czech Republic - (PRG);Reykjavík, Iceland - (KEF);Riga, Latvia - (RIX);Rome, Italy - (FCO);Saint Petersburg, Russia - (LED);Sofia, Bulgaria - (SOF);Stockholm, Sweden - (ARN);Tallinn, Estonia - (TLL);Thessaloniki, Greece - (SKG);Vienna, Austria - (VIE);Vilnius, Lithuania - (VNO);Warsaw, Poland - (WAW);Zagreb, Croatia - (ZAG);Zürich, Switzerland - (ZRH);Arica, Chile - (ARI);Asunción, Paraguay - (ASU);Bogotá, Colombia - (BOG);Buenos Aires, Argentina - (EZE);Curitiba, Brazil - (CWB);Fortaleza, Brazil - (FOR);Guatemala City, Guatemala - (GUA);Lima, Peru - (LIM);Medellín, Colombia - (MDE);Panama City, Panama - (PTY);Porto Alegre, Brazil - (POA);Quito, Ecuador - (UIO);Rio de Janeiro, Brazil - (GIG);São Paulo, Brazil - (GRU);Santiago, Chile - (SCL);Willemstad, Curaçao - (CUR);St. George's, Grenada - (GND);Amman, Jordan - (AMM);Baghdad, Iraq - (BGW);Baku, Azerbaijan - (GYD);Beirut, Lebanon - (BEY);Doha, Qatar - (DOH);Dubai, United Arab Emirates - (DXB);Kuwait City, Kuwait - (KWI);Manama, Bahrain - (BAH);Muscat, Oman - (MCT);Ramallah - (ZDM);Riyadh, Saudi Arabia - (RUH);Tel Aviv, Israel - (TLV);Ashburn, VA, United States - (IAD);Atlanta, GA, United States - (ATL);Boston, MA, United States - (BOS);Buffalo, NY, United States - (BUF);Calgary, AB, Canada - (YYC);Charlotte, NC, United States - (CLT);Chicago, IL, United States - (ORD);Columbus, OH, United States - (CMH);Dallas, TX, United States - (DFW);Denver, CO, United States - (DEN);Detroit, MI, United States - (DTW);Honolulu, HI, United States - (HNL);Houston, TX, United States - (IAH);Indianapolis, IN, United States - (IND);Jacksonville, FL, United States - (JAX);Kansas City, MO, United States - (MCI);Las Vegas, NV, United States - (LAS);Los Angeles, CA, United States - (LAX);McAllen, TX, United States - (MFE);Memphis, TN, United States - (MEM);Mexico City, Mexico - (MEX);Miami, FL, United States - (MIA);Minneapolis, MN, United States - (MSP);Montgomery, AL, United States - (MGM);Montréal, QC, Canada - (YUL);Nashville, TN, United States - (BNA);Newark, NJ, United States - (EWR);Norfolk, VA, United States - (ORF);Omaha, NE, United States - (OMA);Philadelphia, United States - (PHL);Phoenix, AZ, United States - (PHX);Pittsburgh, PA, United States - (PIT);Port-Au-Prince, Haiti - (PAP);Portland, OR, United States - (PDX);Queretaro, MX, Mexico - (QRO);Richmond, Virginia - (RIC);Sacramento, CA, United States - (SMF);Salt Lake City, UT, United States - (SLC);San Diego, CA, United States - (SAN);San Jose, CA, United States - (SJC);Saskatoon, SK, Canada - (YXE);Seattle, WA, United States - (SEA);St. Louis, MO, United States - (STL);Tampa, FL, United States - (TPA);Toronto, ON, Canada - (YYZ);Vancouver, BC, Canada - (YVR);Tallahassee, FL, United States - (TLH);Winnipeg, MB, Canada - (YWG);Adelaide, SA, Australia - (ADL);Auckland, New Zealand - (AKL);Brisbane, QLD, Australia - (BNE);Melbourne, VIC, Australia - (MEL);Noumea, New caledonia - (NOU);Perth, WA, Australia - (PER);Sydney, NSW, Australia - (SYD)".split(";"),e=a.split("colo=")[1].split("\n")[0],t=(a.split("colo=")[1].split("\n")[0],a.split("tls=")[1].split("\n")[0]),o=a.split("http=")[1].split("\n")[0],s=a.split("sni=")[1].split("\n")[0],r=a.split("ip=")[1].split("\n")[0],l=a.split("uag=")[1].split("\n")[0];for(var d=0;d<i.length;d++)if(-1!=i[d].indexOf(e)){document.getElementById("cdn").innerHTML=i[d];break}document.getElementById("tls").innerHTML=t,document.getElementById("http").innerHTML=o,document.getElementById("sni").innerHTML=s,document.getElementById("ip").innerHTML=r,document.getElementById("useragent").innerHTML=l}})},$(document).ready((function(){getCDNinfo()}))</script></p><p style="text-align:center">感谢陪伴与布道，开源之火不灭。​</p><p style="text-align:center"><script>document.write("本次加载耗时: "+(performance.getEntriesByType("navigation").reduce((e,r)=>e+r.responseEnd-r.startTime,0)+performance.getEntriesByType("resource").reduce((e,r)=>e+r.responseEnd-r.startTime,0)).toFixed(0)+"ms")</script></p><p style="text-align:center">当前 SNI 状态： <span id="sni">正在统计！或可能被浏览器防追踪拦截！</span></p><p style="text-align:center">当前 TLS 版本： <span id="tls">正在统计！或可能被浏览器防追踪拦截！</span></p><p style="text-align:center">当前 HTTP 版本： <span id="http">正在统计！或可能被浏览器防追踪拦截！</span></p><p style="text-align:center">当前您的客户端 IP 是： <span id="ip">正在统计！或可能被浏览器防追踪拦截！</span></p><p style="text-align:center">当前分配的 CDN 节点是: <span id="cdn">正在统计！或可能被浏览器防追踪拦截！</span></p><p style="text-align:center">您的 UserAgent 信息是: <span id="useragent">正在统计！或可能被浏览器防追踪拦截！</span></p><p></p></div></div></body></html>