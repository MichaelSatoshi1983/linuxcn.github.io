<!doctype html><html lang="en"><head><meta name="msvalidate.01" content="D404690CEFCB54C7762AC84935B99171"><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?6618da70c90c8744eead2e9371fb5077";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><script type="text/javascript">!function(t,e,n,c,s,a,r){t[n]=t[n]||function(){(t[n].q=t[n].q||[]).push(arguments)},(a=e.createElement(c)).async=1,a.src="https://www.clarity.ms/tag/s5f3f0tojf",(r=e.getElementsByTagName(c)[0]).parentNode.insertBefore(a,r)}(window,document,"clarity","script")</script><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta http-equiv="X-UA-Compatible" content="ie=edge"><link rel="stylesheet" href="/styles/base.css"><link rel="stylesheet" href="/styles/theme.css"><link rel="shortcut icon" href="/favicon.png"><title>在 Kubernetes 上使用 Flask 搭建 Python 微服务 - 归墟星火集</title><meta name="generator" content="Hexo 7.3.0"></head><body><div class="header-title"><span class="header-light"></span> <span class="header-light"></span> <span class="header-light"></span> <span>归墟星火集 linuxcn.undefined.today<span></span></span></div><div class="container"><ul class="nav"><li><a href="/">首页</a></li><li><a href="/about/">关于</a></li><li><a target="_blank" rel="noopener" href="https://undefined.today/">Blog</a></li></ul><div class="content"><div class="post-container"><div class="post-header"><span class="ui-tips">标题：</span><h1 class="ui-keyword post-title">在 Kubernetes 上使用 Flask 搭建 Python 微服务</h1><span class="post-date">2022-10-19</span></div><div class="post-header"><span class="ui-tips">分类：</span> <a href="/categories/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/">软件开发</a></div><div class="post-header"><span class="ui-tips">标签：</span> <a href="/tags/Python/">Python</a> <a href="/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/">微服务</a> <a href="/tags/Flask/">Flask</a></div><div class="post-content"><p><img src="https://linuxcn.img.undefined.today/data/attachment/album/202210/19/124429nmw0xmfz3x3mrrf2.jpg"></p><p><em>微服务遵循领域驱动设计（DDD），与开发平台无关。Python 微服务也不例外。Python3 的面向对象特性使得按照 DDD 对服务进行建模变得更加容易。本系列的第 10 部分演示了如何将用户管理系统的查找服务作为 Python 微服务部署在 Kubernetes 上。</em></p><p>微服务架构的强大之处在于它的多语言性。企业将其功能分解为一组微服务，每个团队自由选择一个平台。</p><p>我们的用户管理系统已经分解为四个微服务，分别是添加、查找、搜索和日志服务。添加服务在 Java 平台上开发并部署在 Kubernetes 集群上，以实现弹性和可扩展性。这并不意味着其余的服务也要使用 Java 开发，我们可以自由选择适合个人服务的平台。</p><p>让我们选择 Python 作为开发查找服务的平台。查找服务的模型已经设计好了（参考 2022 年 3 月份的文章），我们只需要将这个模型转换为代码和配置。</p><h3 id="Pythonic-方法"><a href="#Pythonic-方法" class="headerlink" title="Pythonic 方法"></a>Pythonic 方法</h3><p>Python 是一种通用编程语言，已经存在了大约 30 年。早期，它是自动化脚本的首选。然而，随着 Django 和 Flask 等框架的出现，它的受欢迎程度越来越高，现在各种领域中都在应用它，如企业应用程序开发。数据科学和机器学习进一步推动了它的发展，Python 现在是三大编程语言之一。</p><p>许多人将 Python 的成功归功于它容易编码。这只是一部分原因。只要你的目标是开发小型脚本，Python 就像一个玩具，你会非常喜欢它。然而，当你进入严肃的大规模应用程序开发领域时，你将不得不处理大量的 <code>if</code> 和 <code>else</code>，Python 变得与任何其他平台一样好或一样坏。例如，采用一种面向对象的方法！许多 Python 开发人员甚至可能没意识到 Python 支持类、继承等功能。Python 确实支持成熟的面向对象开发，但是有它自己的方式 – Pythonic！让我们探索一下！</p><h3 id="领域模型"><a href="#领域模型" class="headerlink" title="领域模型"></a>领域模型</h3><p><code>AddService</code> 通过将数据保存到一个 MySQL 数据库中来将用户添加到系统中。<code>FindService</code> 的目标是提供一个 REST API 按用户名查找用户。域模型如图 1 所示。它主要由一些值对象组成，如 <code>User</code> 实体的<code>Name</code>、<code>PhoneNumber</code> 以及 <code>UserRepository</code>。</p><p><img src="https://linuxcn.img.undefined.today/data/attachment/album/202210/19/124459ozaec7k784oqk6c5.png" alt="图 1: 查找服务的域模型"></p><p>让我们从 <code>Name</code> 开始。由于它是一个值对象，因此必须在创建时进行验证，并且必须保持不可变。基本结构如所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class Name:</span><br><span class="line">    value: str</span><br><span class="line">    def __post_init__(self):</span><br><span class="line">        if self.value is None or len(self.value.strip()) &lt; 8 or len(self.value.strip()) &gt; 32:</span><br><span class="line">            raise ValueError(&quot;Invalid Name&quot;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如你所见，<code>Name</code> 包含一个字符串类型的值。作为后期初始化的一部分，我们会验证它。</p><p>Python 3.7 提供了 <code>@dataclass</code> 装饰器，它提供了许多开箱即用的数据承载类的功能，如构造函数、比较运算符等。如下是装饰后的 <code>Name</code> 类：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">from dataclasses import dataclass</span><br><span class="line"></span><br><span class="line">@dataclass</span><br><span class="line">class Name:</span><br><span class="line">    value: str</span><br><span class="line">    def __post_init__(self):</span><br><span class="line">        if self.value is None or len(self.value.strip()) &lt; 8 or len(self.value.strip()) &gt; 32:</span><br><span class="line">            raise ValueError(&quot;Invalid Name&quot;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>以下代码可以创建一个 <code>Name</code> 对象：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">name = Name(&quot;Krishna&quot;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>value</code> 属性可以按照如下方式读取或写入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">name.value = &quot;Mohan&quot;</span><br><span class="line">print(name.value)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以很容易地与另一个 <code>Name</code> 对象比较，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">other = Name(&quot;Mohan&quot;)</span><br><span class="line">if name == other:</span><br><span class="line">    print(&quot;same&quot;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如你所见，对象比较的是值而不是引用。这一切都是开箱即用的。我们还可以通过冻结对象使对象不可变。这是 <code>Name</code> 值对象的最终版本：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">from dataclasses import dataclass</span><br><span class="line"></span><br><span class="line">@dataclass(frozen=True)</span><br><span class="line">class Name:</span><br><span class="line">    value: str</span><br><span class="line">    def __post_init__(self):</span><br><span class="line">        if self.value is None or len(self.value.strip()) &lt; 8 or len(self.value.strip()) &gt; 32:</span><br><span class="line">            raise ValueError(&quot;Invalid Name&quot;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>PhoneNumber</code> 也遵循类似的方法，因为它也是一个值对象：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@dataclass(frozen=True)</span><br><span class="line">class PhoneNumber:</span><br><span class="line">    value: int</span><br><span class="line">    def __post_init__(self):</span><br><span class="line">        if self.value &lt; 9000000000:</span><br><span class="line">            raise ValueError(&quot;Invalid Phone Number&quot;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>User</code> 类是一个实体，不是一个值对象。换句话说，<code>User</code> 是可变的。以下是结构：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">from dataclasses import dataclass</span><br><span class="line">import datetime</span><br><span class="line"></span><br><span class="line">@dataclass</span><br><span class="line">class User:</span><br><span class="line">    _name: Name</span><br><span class="line">    _phone: PhoneNumber</span><br><span class="line">    _since: datetime.datetime</span><br><span class="line"></span><br><span class="line">    def __post_init__(self):</span><br><span class="line">        if self._name is None or self._phone is None:</span><br><span class="line">            raise ValueError(&quot;Invalid user&quot;)</span><br><span class="line">        if self._since is None:</span><br><span class="line">            self.since = datetime.datetime.now()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>你能观察到 <code>User</code> 并没有冻结，因为我们希望它是可变的。但是，我们不希望所有属性都是可变的。标识字段如 <code>_name</code> 和 <code>_since</code> 是希望不会修改的。那么，这如何做到呢？</p><p>Python3 提供了所谓的描述符协议，它会帮助我们正确定义 getter 和 setter。让我们使用 <code>@property</code> 装饰器将 getter 添加到 <code>User</code> 的所有三个字段中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@property</span><br><span class="line">def name(self) -&gt; Name:</span><br><span class="line">    return self._name</span><br><span class="line"></span><br><span class="line">@property</span><br><span class="line">def phone(self) -&gt; PhoneNumber:</span><br><span class="line">    return self._phone</span><br><span class="line"></span><br><span class="line">@property</span><br><span class="line">def since(self) -&gt; datetime.datetime:</span><br><span class="line">    return self._since</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>phone</code> 字段的 setter 可以使用 <code>@&lt;字段&gt;.setter</code> 来装饰：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@phone.setter</span><br><span class="line">def phone(self, phone: PhoneNumber) -&gt; None:</span><br><span class="line">    if phone is None:</span><br><span class="line">        raise ValueError(&quot;Invalid phone&quot;)</span><br><span class="line">    self._phone = phone</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>通过重写 <code>__str__()</code> 函数，也可以为 <code>User</code> 提供一个简单的打印方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def __str__(self):</span><br><span class="line">    return self.name.value + &quot; [&quot; + str(self.phone.value) + &quot;] since &quot; + str(self.since)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这样，域模型的实体和值对象就准备好了。创建异常类如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class UserNotFoundException(Exception):</span><br><span class="line">    pass</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>域模型现在只剩下 <code>UserRepository</code> 了。Python 提供了一个名为 <code>abc</code> 的有用模块来创建抽象方法和抽象类。因为 <code>UserRepository</code> 只是一个接口，所以我们可以使用 <code>abc</code> 模块。</p><p>任何继承自 <code>abc.ABC</code> 的类都将变为抽象类，任何带有 <code>@abc.abstractmethod</code> 装饰器的函数都会变为一个抽象函数。下面是 <code>UserRepository</code> 的结构：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">from abc import ABC, abstractmethod</span><br><span class="line"></span><br><span class="line">class UserRepository(ABC):</span><br><span class="line">    @abstractmethod</span><br><span class="line">    def fetch(self, name:Name) -&gt; User:</span><br><span class="line">        pass</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>UserRepository</code> 遵循仓储模式。换句话说，它在 <code>User</code> 实体上提供适当的 CRUD 操作，而不会暴露底层数据存储语义。在本例中，我们只需要 <code>fetch()</code> 操作，因为 <code>FindService</code> 只查找用户。</p><p>因为 <code>UserRepository</code> 是一个抽象类，我们不能从抽象类创建实例对象。创建对象必须依赖于一个具体类实现这个抽象类。数据层 <code>UserRepositoryImpl</code> 提供了 <code>UserRepository</code> 的具体实现：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class UserRepositoryImpl(UserRepository):</span><br><span class="line">    def fetch(self, name:Name) -&gt; User:</span><br><span class="line">        pass</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>由于 <code>AddService</code> 将用户数据存储在一个 MySQL 数据库中，因此 <code>UserRepositoryImpl</code> 也必须连接到相同的数据库去检索数据。下面是连接到数据库的代码。注意，我们正在使用 MySQL 的连接库。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">from mysql.connector import connect, Error</span><br><span class="line"></span><br><span class="line">class UserRepositoryImpl(UserRepository):</span><br><span class="line">    def fetch(self, name:Name) -&gt; User:</span><br><span class="line">        try:</span><br><span class="line">            with connect(</span><br><span class="line">                    host=&quot;mysqldb&quot;,</span><br><span class="line">                    user=&quot;root&quot;,</span><br><span class="line">                    password=&quot;admin&quot;,</span><br><span class="line">                    database=&quot;glarimy&quot;,</span><br><span class="line">                ) as connection:</span><br><span class="line">                with connection.cursor() as cursor:</span><br><span class="line">                    cursor.execute(&quot;SELECT * FROM ums_users where name=%s&quot;, (name.value,))</span><br><span class="line">                    row = cursor.fetchone()</span><br><span class="line">                    if cursor.rowcount == -1:</span><br><span class="line">                        raise UserNotFoundException()</span><br><span class="line">                    else:</span><br><span class="line">                        return User(Name(row[0]), PhoneNumber(row[1]), row[2])</span><br><span class="line">        except Error as e:</span><br><span class="line">            raise e</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在上面的片段中，我们使用用户 <code>root</code> &#x2F; 密码 <code>admin</code> 连接到一个名为 <code>mysqldb</code> 的数据库服务器，使用名为 <code>glarimy</code> 的数据库（模式）。在演示代码中是可以包含这些信息的，但在生产中不建议这么做，因为这会暴露敏感信息。</p><p><code>fetch()</code> 操作的逻辑非常直观，它对 <code>ums_users</code> 表执行 SELECT 查询。回想一下，<code>AddService</code> 正在将用户数据写入同一个表中。如果 SELECT 查询没有返回记录，<code>fetch()</code> 函数将抛出 <code>UserNotFoundException</code> 异常。否则，它会从记录中构造 <code>User</code> 实体并将其返回给调用者。这没有什么特殊的。</p><h3 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h3><p>最终，我们需要创建应用层。此模型如图 2 所示。它只包含两个类：控制器和一个 DTO。</p><p><img src="https://linuxcn.img.undefined.today/data/attachment/album/202210/19/124500ns7pem96lottcc0p.png" alt="图 2: 添加服务的应用层"></p><p>众所周知，一个 DTO 只是一个没有任何业务逻辑的数据容器。它主要用于在 <code>FindService</code> 和外部之间传输数据。我们只是提供了在 REST 层中将 <code>UserRecord</code> 转换为字典以便用于 JSON 传输：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class UserRecord:</span><br><span class="line">    def toJSON(self):</span><br><span class="line">        return &#123;</span><br><span class="line">            &quot;name&quot;: self.name,</span><br><span class="line">            &quot;phone&quot;: self.phone,</span><br><span class="line">            &quot;since&quot;: self.since</span><br><span class="line">        &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>控制器的工作是将 DTO 转换为用于域服务的域对象，反之亦然。可以从 <code>find()</code> 操作中观察到这一点。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class UserController:</span><br><span class="line"></span><br><span class="line">    def __init__(self):</span><br><span class="line">        self._repo = UserRepositoryImpl()</span><br><span class="line"></span><br><span class="line">    def find(self, name: str):</span><br><span class="line">        try:</span><br><span class="line">            user: User = self._repo.fetch(Name(name))</span><br><span class="line">            record: UserRecord = UserRecord()</span><br><span class="line">            record.name = user.name.value</span><br><span class="line">            record.phone = user.phone.value</span><br><span class="line">            record.since = user.since</span><br><span class="line">            return record</span><br><span class="line">        except UserNotFoundException as e:</span><br><span class="line">            return None</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>find()</code> 操作接收一个字符串作为用户名，然后将其转换为 <code>Name</code> 对象，并调用 <code>UserRepository</code> 获取相应的 <code>User</code> 对象。如果找到了，则使用检索到的 <code>User`` 对象创建</code>UserRecord&#96;。回想一下，将域对象转换为 DTO 是很有必要的，这样可以对外部服务隐藏域模型。</p><p><code>UserController</code> 不需要有多个实例，它也可以是单例的。通过重写 <code>__new__</code>，可以将其建模为一个单例。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class UserController:</span><br><span class="line">    def __new__(self):</span><br><span class="line">        if not hasattr(self, ‘instance’):</span><br><span class="line">            self.instance = super().__new__(self)</span><br><span class="line">        return self.instance</span><br><span class="line"></span><br><span class="line">    def __init__(self):</span><br><span class="line">        self._repo = UserRepositoryImpl()</span><br><span class="line"></span><br><span class="line">    def find(self, name: str):</span><br><span class="line">        try:</span><br><span class="line">            user: User = self._repo.fetch(Name(name))</span><br><span class="line">            record: UserRecord = UserRecord()</span><br><span class="line">            record.name = user.name.getValue()</span><br><span class="line">            record.phone = user.phone.getValue()</span><br><span class="line">            record.since = user.since</span><br><span class="line">            return record</span><br><span class="line">        except UserNotFoundException as e:</span><br><span class="line">            return None</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我们已经完全实现了 <code>FindService</code> 的模型，剩下的唯一任务是将其作为 REST 服务公开。</p><h3 id="REST-API"><a href="#REST-API" class="headerlink" title="REST API"></a>REST API</h3><p><code>FindService</code> 只提供一个 API，那就是通过用户名查找用户。显然 URI 如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GET /user/&#123;name&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>此 API 希望根据提供的用户名查找用户，并以 JSON 格式返回用户的电话号码等详细信息。如果没有找到用户，API 将返回一个 404 状态码。</p><p>我们可以使用 Flask 框架来构建 REST API，它最初的目的是使用 Python 开发 Web 应用程序。除了 HTML 视图，它还进一步扩展到支持 REST 视图。我们选择这个框架是因为它足够简单。 创建一个 Flask 应用程序：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">from flask import Flask</span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后为 Flask 应用程序定义路由，就像函数一样简单：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@app.route(&#x27;/user/&lt;name&gt;&#x27;)</span><br><span class="line">def get(name):</span><br><span class="line">    pass</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>注意 <code>@app.route</code> 映射到 API <code>/user/&lt;name&gt;</code>，与之对应的函数的 <code>get()</code>。</p><p>如你所见，每次用户访问 API 如 <code>http://server:port/user/Krishna</code> 时，都将调用这个 <code>get()</code> 函数。Flask 足够智能，可以从 URL 中提取 <code>Krishna</code> 作为用户名，并将其传递给 <code>get()</code> 函数。</p><p><code>get()</code> 函数很简单。它要求控制器找到该用户，并将其与通常的 HTTP 头一起打包为 JSON 格式后返回。如果控制器返回 <code>None</code>，则 <code>get()</code> 函数返回合适的 HTTP 状态码。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">from flask import jsonify, abort</span><br><span class="line"></span><br><span class="line">controller = UserController()</span><br><span class="line">record = controller.find(name)</span><br><span class="line">if record is None:</span><br><span class="line">    abort(404)</span><br><span class="line">else:</span><br><span class="line">    resp = jsonify(record.toJSON())</span><br><span class="line">    resp.status_code = 200</span><br><span class="line">    return resp</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>最后，我们需要 Flask 应用程序提供服务，可以使用 <code>waitress</code> 服务：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">from waitress import serve</span><br><span class="line">serve(app, host=&quot;0.0.0.0&quot;, port=8080)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在上面的片段中，应用程序在本地主机的 8080 端口上提供服务。最终代码如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">from flask import Flask, jsonify, abort</span><br><span class="line">from waitress import serve</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line">@app.route(&#x27;/user/&lt;name&gt;&#x27;)</span><br><span class="line">def get(name):</span><br><span class="line">    controller = UserController()</span><br><span class="line">    record = controller.find(name)</span><br><span class="line">    if record is None:</span><br><span class="line">        abort(404)</span><br><span class="line">    else:</span><br><span class="line">        resp = jsonify(record.toJSON())</span><br><span class="line">        resp.status_code = 200</span><br><span class="line">        return resp</span><br><span class="line"></span><br><span class="line">serve(app, host=&quot;0.0.0.0&quot;, port=8080)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h3><p><code>FindService</code> 的代码已经准备完毕。除了 REST API 之外，它还有域模型、数据层和应用程序层。下一步是构建此服务，将其容器化，然后部署到 Kubernetes 上。此过程与部署其他服务妹有任何区别，但有一些 Python 特有的步骤。</p><p>在继续前进之前，让我们来看下文件夹和文件结构：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+ ums-find-service</span><br><span class="line">+ ums</span><br><span class="line">- domain.py</span><br><span class="line">- data.py</span><br><span class="line">- app.py</span><br><span class="line">- Dockerfile</span><br><span class="line">- requirements.txt</span><br><span class="line">- kube-find-deployment.yml</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如你所见，整个工作文件夹都位于 <code>ums-find-service</code> 下，它包含了 <code>ums</code> 文件夹中的代码和一些配置文件，例如 <code>Dockerfile</code>、<code>requirements.txt</code> 和 <code>kube-find-deployment.yml</code>。</p><p><code>domain.py</code> 包含域模型，<code>data.py</code> 包含 <code>UserRepositoryImpl</code>，<code>app.py</code> 包含剩余代码。我们已经阅读过代码了，现在我们来看看配置文件。</p><p>第一个是 <code>requirements.txt</code>，它声明了 Python 系统需要下载和安装的外部依赖项。我们需要用查找服务中用到的每个外部 Python 模块来填充它。如你所见，我们使用了 MySQL 连接器、Flask 和 Waitress 模块。因此，下面是 <code>requirements.txt</code> 的内容。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Flask==2.1.1</span><br><span class="line">Flask_RESTful</span><br><span class="line">mysql-connector-python</span><br><span class="line">waitress</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>第二步是在 <code>Dockerfile</code> 中声明 Docker 相关的清单，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">FROM python:3.8-slim-buster</span><br><span class="line"></span><br><span class="line">WORKDIR /ums</span><br><span class="line">ADD ums /ums</span><br><span class="line">ADD requirements.txt requirements.txt</span><br><span class="line">RUN pip3 install -r requirements.txt</span><br><span class="line"></span><br><span class="line">EXPOSE 8080</span><br><span class="line">ENTRYPOINT [&quot;python&quot;]</span><br><span class="line">CMD [&quot;/ums/app.py&quot;]</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>总的来说，我们使用 Python 3.8 作为基线，除了移动 <code>requirements.txt</code> 之外，我们还将代码从 <code>ums</code> 文件夹移动到 Docker 容器中对应的文件夹中。然后，我们指示容器运行 <code>pip3 install</code> 命令安装对应模块。最后，我们向外暴露 8080 端口（因为 waitress 运行在此端口上）。</p><p>为了运行此服务，我们指示容器使用使用以下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">python /ums/app.py</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>一旦 <code>Dockerfile</code> 准备完成，在 <code>ums-find-service</code> 文件夹中运行以下命令，创建 Docker 镜像：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker build -t glarimy/ums-find-service</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>它会创建 Docker 镜像，可以使用以下命令查找镜像：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker images</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>尝试将镜像推送到 Docker Hub，你也可以登录到 Docker。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker login</span><br><span class="line">docker push glarimy/ums-find-service</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>最后一步是为 Kubernetes 部署构建清单。</p><p>在之前的文章中，我们已经介绍了如何建立 Kubernetes 集群、部署和使用服务的方法。我假设仍然使用之前文章中的清单文件来部署添加服务、MySQL、Kafka 和 Zookeeper。我们只需要将以下内容添加到 <code>kube-find-deployment.yml</code> 文件中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">name: ums-find-service</span><br><span class="line">labels:</span><br><span class="line">app: ums-find-service</span><br><span class="line">spec:</span><br><span class="line">replicas: 3</span><br><span class="line">selector:</span><br><span class="line">matchLabels:</span><br><span class="line">app: ums-find-service</span><br><span class="line">template:</span><br><span class="line">metadata:</span><br><span class="line">labels:</span><br><span class="line">app: ums-find-service</span><br><span class="line">spec:</span><br><span class="line">containers:</span><br><span class="line">- name: ums-find-service</span><br><span class="line">image: glarimy/ums-find-service</span><br><span class="line">ports:</span><br><span class="line">- containerPort: 8080</span><br><span class="line">---</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">name: ums-find-service</span><br><span class="line">labels:</span><br><span class="line">name: ums-find-service</span><br><span class="line">spec:</span><br><span class="line">type: LoadBalancer</span><br><span class="line">ports:</span><br><span class="line">- port: 8080</span><br><span class="line">selector:</span><br><span class="line">app: ums-find-service</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上面清单文件的第一部分声明了 <code>glarimy/ums-find-service</code> 镜像的 <code>FindService</code>，它包含三个副本。它还暴露 8080 端口。清单的后半部分声明了一个 Kubernetes 服务作为 <code>FindService</code> 部署的前端。请记住，在之前文章中，mysqldb 服务已经是上述清单的一部分了。</p><p>运行以下命令在 Kubernetes 集群上部署清单文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kubectl create -f kube-find-deployment.yml</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>部署完成后，可以使用以下命令验证容器组和服务：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kubectl get services</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>输出如图 3 所示：</p><p><img src="https://linuxcn.img.undefined.today/data/attachment/album/202210/19/124500tffukqizzoqqtpf2.png" alt="图 3: Kubernetes 服务"></p><p>它会列出集群上运行的所有服务。注意查找服务的外部 IP，使用 <code>curl</code> 调用此服务：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl http://10.98.45.187:8080/user/KrishnaMohan</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>注意：10.98.45.187 对应查找服务，如图 3 所示。</p><p>如果我们使用 <code>AddService</code> 创建一个名为 <code>KrishnaMohan</code> 的用户，那么上面的 <code>curl</code> 命令看起来如图 4 所示：</p><p><img src="https://linuxcn.img.undefined.today/data/attachment/album/202210/19/124500fv3z4uithciei4in.png" alt="图 4: 查找服务"></p><p>用户管理系统（UMS）的体系结构包含 <code>AddService</code> 和 <code>FindService</code>，以及存储和消息传递所需的后端服务，如图 5 所示。可以看到终端用户使用 <code>ums-add-service</code> 的 IP 地址添加新用户，使用 <code>ums-find-service</code> 的 IP 地址查找已有用户。每个 Kubernetes 服务都由三个对应容器的节点支持。还要注意：同样的 mysqldb 服务用于存储和检索用户数据。</p><p><img src="https://linuxcn.img.undefined.today/data/attachment/album/202210/19/124500eu85ibyzdy7tutuj.png" alt="图 5: UMS 的添加服务和查找服务"></p><h3 id="其他服务"><a href="#其他服务" class="headerlink" title="其他服务"></a>其他服务</h3><p>UMS 系统还包含两个服务：<code>SearchService</code> 和 <code>JournalService</code>。在本系列的下一部分中，我们将在 Node 平台上设计这些服务，并将它们部署到同一个 Kubernetes 集群，以演示多语言微服务架构的真正魅力。最后，我们将观察一些与微服务相关的设计模式。</p><hr><p>via: <a target="_blank" rel="noopener" href="https://www.opensourceforu.com/2022/09/python-microservices-using-flask-on-kubernetes/">https://www.opensourceforu.com/2022/09/python-microservices-using-flask-on-kubernetes/</a></p><p>作者：<a target="_blank" rel="noopener" href="https://www.opensourceforu.com/author/krishna-mohan-koyya/">Krishna Mohan Koyya</a> 选题：<a target="_blank" rel="noopener" href="https://github.com/lkxed">lkxed</a> 译者：<a target="_blank" rel="noopener" href="https://github.com/MjSeven">MjSeven</a> 校对：<a target="_blank" rel="noopener" href="https://github.com/wxy">wxy</a></p><p>本文由 <a target="_blank" rel="noopener" href="https://github.com/LCTT/TranslateProject">LCTT</a> 原创编译，<a target="_blank" rel="noopener" href="https://linux.cn/">Linux中国</a> 荣誉推出</p></div></div></div><div class="footer"><p class="footer-copyright"><span>Powered by <a target="_blank" href="https://hexo.io">Hexo</a></span> <span>Theme <a target="_blank" href="https://github.com/tinkink-co/hexo-theme-terminal">Terminal</a></span><script type="text/javascript" src="https://cdn.staticfile.net/jquery/3.4.1/jquery.min.js"></script><script>getCDNinfo=function(){$.ajax({url:"/cdn-cgi/trace",success:function(a,n){let i="Antananarivo, Madagascar - (TNR);Cape Town, South Africa - (CPT);Casablanca, Morocco - (CMN);Dar Es Salaam, Tanzania - (DAR);Djibouti City, Djibouti - (JIB);Durban, South Africa - (DUR);Johannesburg, South Africa - (JNB);Kigali, Rwanda - (KGL);Lagos, Nigeria - (LOS);Luanda, Angola - (LAD);Maputo, MZ - (MPM);Mombasa, Kenya - (MBA);Port Louis, Mauritius - (MRU);Réunion, France - (RUN);Bangalore, India - (BLR);Bangkok, Thailand - (BKK);Bandar Seri Begawan, Brunei - (BWN);Cebu, Philippines - (CEB);Chengdu, China - (CTU);Chennai, India - (MAA);Chittagong, Bangladesh - (CGP);Chongqing, China - (CKG);Colombo, Sri Lanka - (CMB);Dhaka, Bangladesh - (DAC);Dongguan, China - (SZX);Foshan, China - (FUO);Fuzhou, China - (FOC);Guangzhou, China - (CAN);Hangzhou, China - (HGH);Hanoi, Vietnam - (HAN);Hengyang, China - (HNY);Ho Chi Minh City, Vietnam - (SGN);Hong Kong - (HKG);Hyderabad, India - (HYD);Islamabad, Pakistan - (ISB);Jakarta, Indonesia - (CGK);Jinan, China - (TNA);Karachi, Pakistan - (KHI);Kathmandu, Nepal - (KTM);Kolkata, India - (CCU);Kuala Lumpur, Malaysia - (KUL);Lahore, Pakistan - (LHE);Langfang, China - (NAY);Luoyang, China - (LYA);Macau - (MFM);Malé, Maldives - (MLE);Manila, Philippines - (MNL);Mumbai, India - (BOM);Nagpur, India - (NAG);Nanning, China - (NNG);New Delhi, India - (DEL);Osaka, Japan - (KIX);Phnom Penh, Cambodia - (PNH);Qingdao, China - (TAO);Seoul, South Korea - (ICN);Shanghai, China - (SHA);Shenyang, China - (SHE);Shijiazhuang, China - (SJW);Singapore, Singapore - (SIN);Suzhou, China - (SZV);Taipei - (TPE);Thimphu, Bhutan - (PBH);Tianjin, China - (TSN);Tokyo, Japan - (NRT);Ulaanbaatar, Mongolia - (ULN);Vientiane, Laos - (VTE);Wuhan, China - (WUH);Wuxi, China - (WUX);Xi'an, China - (XIY);Yerevan, Armenia - (EVN);Zhengzhou, China - (CGO);Zuzhou, China - (CSX);Amsterdam, Netherlands - (AMS);Athens, Greece - (ATH);Barcelona, Spain - (BCN);Belgrade, Serbia - (BEG);Berlin, Germany - (TXL);Brussels, Belgium - (BRU);Bucharest, Romania - (OTP);Budapest, Hungary - (BUD);Chișinău, Moldova - (KIV);Copenhagen, Denmark - (CPH);Cork, Ireland -  (ORK);Dublin, Ireland - (DUB);Düsseldorf, Germany - (DUS);Edinburgh, United Kingdom - (EDI);Frankfurt, Germany - (FRA);Geneva, Switzerland - (GVA);Gothenburg, Sweden - (GOT);Hamburg, Germany - (HAM);Helsinki, Finland - (HEL);Istanbul, Turkey - (IST);Kyiv, Ukraine - (KBP);Lisbon, Portugal - (LIS);London, United Kingdom - (LHR);Luxembourg City, Luxembourg - (LUX);Madrid, Spain - (MAD);Manchester, United Kingdom - (MAN);Marseille, France - (MRS);Milan, Italy - (MXP);Moscow, Russia - (DME);Munich, Germany - (MUC);Nicosia, Cyprus - (LCA);Oslo, Norway - (OSL);Paris, France - (CDG);Prague, Czech Republic - (PRG);Reykjavík, Iceland - (KEF);Riga, Latvia - (RIX);Rome, Italy - (FCO);Saint Petersburg, Russia - (LED);Sofia, Bulgaria - (SOF);Stockholm, Sweden - (ARN);Tallinn, Estonia - (TLL);Thessaloniki, Greece - (SKG);Vienna, Austria - (VIE);Vilnius, Lithuania - (VNO);Warsaw, Poland - (WAW);Zagreb, Croatia - (ZAG);Zürich, Switzerland - (ZRH);Arica, Chile - (ARI);Asunción, Paraguay - (ASU);Bogotá, Colombia - (BOG);Buenos Aires, Argentina - (EZE);Curitiba, Brazil - (CWB);Fortaleza, Brazil - (FOR);Guatemala City, Guatemala - (GUA);Lima, Peru - (LIM);Medellín, Colombia - (MDE);Panama City, Panama - (PTY);Porto Alegre, Brazil - (POA);Quito, Ecuador - (UIO);Rio de Janeiro, Brazil - (GIG);São Paulo, Brazil - (GRU);Santiago, Chile - (SCL);Willemstad, Curaçao - (CUR);St. George's, Grenada - (GND);Amman, Jordan - (AMM);Baghdad, Iraq - (BGW);Baku, Azerbaijan - (GYD);Beirut, Lebanon - (BEY);Doha, Qatar - (DOH);Dubai, United Arab Emirates - (DXB);Kuwait City, Kuwait - (KWI);Manama, Bahrain - (BAH);Muscat, Oman - (MCT);Ramallah - (ZDM);Riyadh, Saudi Arabia - (RUH);Tel Aviv, Israel - (TLV);Ashburn, VA, United States - (IAD);Atlanta, GA, United States - (ATL);Boston, MA, United States - (BOS);Buffalo, NY, United States - (BUF);Calgary, AB, Canada - (YYC);Charlotte, NC, United States - (CLT);Chicago, IL, United States - (ORD);Columbus, OH, United States - (CMH);Dallas, TX, United States - (DFW);Denver, CO, United States - (DEN);Detroit, MI, United States - (DTW);Honolulu, HI, United States - (HNL);Houston, TX, United States - (IAH);Indianapolis, IN, United States - (IND);Jacksonville, FL, United States - (JAX);Kansas City, MO, United States - (MCI);Las Vegas, NV, United States - (LAS);Los Angeles, CA, United States - (LAX);McAllen, TX, United States - (MFE);Memphis, TN, United States - (MEM);Mexico City, Mexico - (MEX);Miami, FL, United States - (MIA);Minneapolis, MN, United States - (MSP);Montgomery, AL, United States - (MGM);Montréal, QC, Canada - (YUL);Nashville, TN, United States - (BNA);Newark, NJ, United States - (EWR);Norfolk, VA, United States - (ORF);Omaha, NE, United States - (OMA);Philadelphia, United States - (PHL);Phoenix, AZ, United States - (PHX);Pittsburgh, PA, United States - (PIT);Port-Au-Prince, Haiti - (PAP);Portland, OR, United States - (PDX);Queretaro, MX, Mexico - (QRO);Richmond, Virginia - (RIC);Sacramento, CA, United States - (SMF);Salt Lake City, UT, United States - (SLC);San Diego, CA, United States - (SAN);San Jose, CA, United States - (SJC);Saskatoon, SK, Canada - (YXE);Seattle, WA, United States - (SEA);St. Louis, MO, United States - (STL);Tampa, FL, United States - (TPA);Toronto, ON, Canada - (YYZ);Vancouver, BC, Canada - (YVR);Tallahassee, FL, United States - (TLH);Winnipeg, MB, Canada - (YWG);Adelaide, SA, Australia - (ADL);Auckland, New Zealand - (AKL);Brisbane, QLD, Australia - (BNE);Melbourne, VIC, Australia - (MEL);Noumea, New caledonia - (NOU);Perth, WA, Australia - (PER);Sydney, NSW, Australia - (SYD)".split(";"),e=a.split("colo=")[1].split("\n")[0],t=(a.split("colo=")[1].split("\n")[0],a.split("tls=")[1].split("\n")[0]),o=a.split("http=")[1].split("\n")[0],s=a.split("sni=")[1].split("\n")[0],r=a.split("ip=")[1].split("\n")[0],l=a.split("uag=")[1].split("\n")[0];for(var d=0;d<i.length;d++)if(-1!=i[d].indexOf(e)){document.getElementById("cdn").innerHTML=i[d];break}document.getElementById("tls").innerHTML=t,document.getElementById("http").innerHTML=o,document.getElementById("sni").innerHTML=s,document.getElementById("ip").innerHTML=r,document.getElementById("useragent").innerHTML=l}})},$(document).ready((function(){getCDNinfo()}))</script></p><p style="text-align:center">感谢陪伴与布道，开源之火不灭。​</p><p style="text-align:center"><script>document.write("本次加载耗时: "+(performance.getEntriesByType("navigation").reduce((e,r)=>e+r.responseEnd-r.startTime,0)+performance.getEntriesByType("resource").reduce((e,r)=>e+r.responseEnd-r.startTime,0)).toFixed(0)+"ms")</script></p><p style="text-align:center">当前 SNI 状态： <span id="sni">正在统计！或可能被浏览器防追踪拦截！</span></p><p style="text-align:center">当前 TLS 版本： <span id="tls">正在统计！或可能被浏览器防追踪拦截！</span></p><p style="text-align:center">当前 HTTP 版本： <span id="http">正在统计！或可能被浏览器防追踪拦截！</span></p><p style="text-align:center">当前您的客户端 IP 是： <span id="ip">正在统计！或可能被浏览器防追踪拦截！</span></p><p style="text-align:center">当前分配的 CDN 节点是: <span id="cdn">正在统计！或可能被浏览器防追踪拦截！</span></p><p style="text-align:center">您的 UserAgent 信息是: <span id="useragent">正在统计！或可能被浏览器防追踪拦截！</span></p><p></p></div></div></body></html>