<!doctype html><html lang="en"><head><meta name="description" content="一个LinuxCN的镜像站"><meta name="msvalidate.01" content="D404690CEFCB54C7762AC84935B99171"><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?6618da70c90c8744eead2e9371fb5077";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><script type="text/javascript">!function(t,e,n,c,s,a,r){t[n]=t[n]||function(){(t[n].q=t[n].q||[]).push(arguments)},(a=e.createElement(c)).async=1,a.src="https://www.clarity.ms/tag/s5f3f0tojf",(r=e.getElementsByTagName(c)[0]).parentNode.insertBefore(a,r)}(window,document,"clarity","script")</script><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta http-equiv="X-UA-Compatible" content="ie=edge"><link rel="stylesheet" href="/styles/base.css"><link rel="stylesheet" href="/styles/theme.css"><link rel="shortcut icon" href="/favicon.png"><title>一个用 Java 实现的超轻量级 RESTful Web 服务示例 - 归墟星火集 又一个 LinuxCN 站点</title><meta name="generator" content="Hexo 7.3.0"></head><body><div class="header-title"><span class="header-light"></span> <span class="header-light"></span> <span class="header-light"></span> <span>归墟星火集 又一个 LinuxCN 站点 linuxcn.undefined.today<span></span></span></div><div class="container"><ul class="nav"><li><a href="/">首页</a></li><li><a target="_blank" rel="noopener" href="https://undefined.today/">Blog</a></li></ul><div class="content"><div class="post-container"><div class="post-header"><span class="ui-tips">标题：</span><h1 class="ui-keyword post-title">一个用 Java 实现的超轻量级 RESTful Web 服务示例</h1><span class="post-date">2020-08-27</span></div><div class="post-header"><span class="ui-tips">分类：</span> <a href="/categories/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/">软件开发</a></div><div class="post-header"><span class="ui-tips">标签：</span> <a href="/tags/RESTful/">RESTful</a></div><div class="post-content"><blockquote><p>通过管理一套图书的完整代码示例，来探索轻量级的 RESTful 服务。</p></blockquote><p><img src="https://linuxcn.img.undefined.today/data/attachment/album/202008/27/071808tt9zlno3b6lmbgl8.jpg"></p><p>Web 服务，以这样或那样的形式，已经存在了近二十年。比如，<a target="_blank" rel="noopener" href="http://xmlrpc.com/">XML-RPC 服务</a>出现在 90 年代后期，紧接着是用 SOAP 分支编写的服务。在 XML-RPC 和 SOAP 这两个开拓者之后出现后不久，REST 架构风格的服务在大约 20 年前也出现了。<a target="_blank" rel="noopener" href="https://www.redhat.com/en/topics/integration/whats-the-difference-between-soap-rest">REST</a> 风格（以下简称 Restful）服务现在主导了流行的网站，比如 eBay、Facebook 和 Twitter。尽管分布式计算的 Web 服务有很多替代品（如 Web 套接字、微服务和远程过程调用的新框架），但基于 Restful 的 Web 服务依然具有吸引力，原因如下：</p><ul><li>Restful 服务建立在现有的基础设施和协议上，特别是 Web 服务器和 HTTP&#x2F;HTTPS 协议。一个拥有基于 HTML 的网站的组织可以很容易地为客户添加 Web 服务，这些客户对数据和底层功能更感兴趣，而不是对 HTML 的表现形式感兴趣。比如，亚马逊就率先通过网站和 Web 服务（基于 SOAP 或 Restful）提供相同的信息和功能。</li><li>Restful 服务将 HTTP 当作 API，因此避免了复杂的软件分层，这种分层是基于 SOAP 的 Web 服务的明显特征。比如，Restful API 支持通过 HTTP 命令（POST-GET-PUT-DELETE）进行标准的 CRUD（增加-读取-更新-删除）操作；通过 HTTP 状态码可以知道请求是否成功或者为什么失败。</li><li>Restful Web 服务可以根据需要变得简单或复杂。Restful 是一种风格，实际上是一种非常灵活的风格，而不是一套关于如何设计和构造服务的规定。（伴随而来的缺点是，可能很难确定哪些服务不能算作 Restful 服务。）</li><li>作为使用者或者客户端，Restful Web 服务与语言和平台无关。客户端发送 HTTP(S) 请求，并以适合现代数据交换的格式（如 JSON）接收文本响应。</li><li>几乎每一种通用编程语言都至少对 HTTP&#x2F;HTTPS 有足够的（通常是强大的）支持，这意味着 Web 服务的客户端可以用这些语言来编写。</li></ul><p>这篇文章将通过一段完整的 Java 代码示例来探讨轻量级的 Restful 服务。</p><h3 id="基于-Restful-的“小说”-Web-服务"><a href="#基于-Restful-的“小说”-Web-服务" class="headerlink" title="基于 Restful 的“小说” Web 服务"></a>基于 Restful 的“小说” Web 服务</h3><p>基于 Restful 的“小说” web 服务包含三个程序员定义的类：</p><ul><li><code>Novel</code> 类代表一个小说，只有三个属性：机器生成的 ID、作者和标题。属性可以根据实际情况进行扩展，但我还是想让这个例子看上去更简单一些。</li><li><code>Novels</code> 类包含了用于各种任务的工具类：将一个 <code>Novel</code> 或者它们的列表的纯文本编码转换成 XML 或者 JSON；支持在小说集合上进行 CRUD 操作；以及从存储在文件中的数据初始化集合。<code>Novels</code> 类在 <code>Novel</code> 实例和 servlet 之间起中介作用。</li><li><code>NovelsServlet</code> 类是从 <code>HttpServlet</code> 中继承的，<code>HttpServlet</code> 是一段健壮且灵活的代码，自 90 年代末的早期企业级 Java 就已经存在了。对于客户端的 CRUD 请求，servlet 可以当作 HTTP 的端点。 servlet 代码主要用于处理客户端的请求和生成相应的响应，而将复杂的细节留给 <code>Novels</code> 类中的工具类进行处理。</li></ul><p>一些 Java 框架，比如 Jersey（JAX-RS）和 Restlet，就是为 Restful 服务设计的。尽管如此，<code>HttpServlet</code> 本身为完成这些服务提供了轻量、灵活、强大且充分测试过的 API。我会通过下面的“小说”例子来说明。</p><h3 id="部署“小说”-Web-服务"><a href="#部署“小说”-Web-服务" class="headerlink" title="部署“小说” Web 服务"></a>部署“小说” Web 服务</h3><p>当然，部署“小说” Web 服务需要一个 Web 服务器。我的选择是 <a target="_blank" rel="noopener" href="http://tomcat.apache.org/">Tomcat</a>，但是如果该服务托管在 Jetty 或者甚至是 Java 应用服务器上，那么这个服务应该至少可以工作（著名的最后一句话！）。<a target="_blank" rel="noopener" href="https://condor.depaul.edu/mkalin">在我的网站上</a>有总结了如何安装 Tomcat 的 README 文件和代码。还有一个附带文档的 Apache Ant 脚本，可以用来构建“小说”服务（或者任何其他服务或网站），并且将它部署在 Tomcat 或相同的服务。</p><p>Tomcat 可以从它的<a target="_blank" rel="noopener" href="https://tomcat.apache.org/download-90.cgi">官网</a>上下载。当你在本地安装后，将 <code>TOMCAT_HOME</code> 设置为安装目录。有两个子目录值得关注：</p><ul><li><code>TOMCAT_HOME/bin</code> 目录包含了类 Unix 系统（<code>startup.sh</code> 和 <code>shutdown.sh</code>）和 Windows（<code>startup.bat</code> 和 <code>shutdown.bat</code>） 的启动和停止脚本。Tomcat 作为 Java 应用程序运行。Web 服务器的 servlet 容器叫做 Catalina。（在 Jetty 中，Web 服务器和容器的名字一样。）当 Tomcat 启动后，在浏览器中输入 <code>http://localhost:8080/</code>可以查看详细文档，包括示例。</li><li><code>TOMCAT_HOME/webapps</code> 目录是已部署的 Web 网站和服务的默认目录。部署网站或 Web 服务的直接方法是复制以 <code>.war</code> 结尾的 JAR 文件（也就是 WAR 文件）到 <code>TOMCAT_HOME/webapps</code> 或它的子目录下。然后 Tomcat 会将 WAR 文件解压到它自己的目录下。比如，Tomcat 会将 <code>novels.war</code> 文件解压到一个叫做 <code>novels</code> 的子目录下，并且保留 <code>novels.war</code> 文件。一个网站或 Web 服务可以通过删除 WAR 文件进行移除，也可以用一个新版 WAR 文件来覆盖已有文件进行更新。顺便说一下，调试网站或服务的第一步就是检查 Tomcat 已经正确解压 WAR 文件；如果没有的话，网站或服务就无法发布，因为代码或配置中有致命错误。</li><li>因为 Tomcat 默认会监听 8080 端口上的 HTTP 请求，所以本机上的 URL 请求以 <code>http://localhost:8080/</code> 开始。</li></ul><p>通过添加不带 <code>.war</code> 后缀的 WAR 文件名来访问由程序员部署的 WAR 文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http://locahost:8080/novels/</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如果服务部署在 <code>TOMCAT_HOME</code> 下的一个子目录中（比如，<code>myapps</code>），这会在 URL 中反映出来：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http://locahost:8080/myapps/novels/</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我会在靠近文章结尾处的测试部分提供这部分的更多细节。</p><p>如前所述，我的主页上有一个包含 Ant 脚本的 ZIP 文件，这个文件可以编译并且部署网站或者服务。（这个 ZIP 文件中也包含一个 <code>novels.war</code> 的副本。）对于“小说”这个例子，命令的示例（<code>%</code> 是命令行提示符）如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">% ant -Dwar.name=novels deploy</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这个命令首先会编译 Java 源代码，并且创建一个可部署的 <code>novels.war</code> 文件，然后将这个文件保存在当前目录中，再复制到 <code>TOMCAT_HOME/webapps</code> 目录中。如果一切顺利，<code>GET</code> 请求（使用浏览器或者命令行工具，比如 <code>curl</code>）可以用来做一个测试：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">% curl http://localhost:8080/novels/</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>默认情况下，Tomcat 设置为 <ruby>热部署 <rt>hot deploys</rt></ruby>：Web 服务器不需要关闭就可以进行部署、更新或者移除一个 web 应用。</p><h3 id="“小说”服务的代码"><a href="#“小说”服务的代码" class="headerlink" title="“小说”服务的代码"></a>“小说”服务的代码</h3><p>让我们回到“小说”这个例子，不过是在代码层面。考虑下面的 <code>Novel</code> 类：</p><h4 id="例-1：Novel-类"><a href="#例-1：Novel-类" class="headerlink" title="例 1：Novel 类"></a>例 1：Novel 类</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">package novels;</span><br><span class="line"></span><br><span class="line">import java.io.Serializable;</span><br><span class="line"></span><br><span class="line">public class Novel implements Serializable, Comparable&lt;Novel&gt; &#123;</span><br><span class="line">    static final long serialVersionUID = 1L;</span><br><span class="line">    private String author;</span><br><span class="line">    private String title;</span><br><span class="line">    private int id;</span><br><span class="line"></span><br><span class="line">    public Novel() &#123; &#125;</span><br><span class="line"></span><br><span class="line">    public void setAuthor(final String author) &#123; this.author = author; &#125;</span><br><span class="line">    public String getAuthor() &#123; return this.author; &#125;</span><br><span class="line">    public void setTitle(final String title) &#123; this.title = title; &#125;</span><br><span class="line">    public String getTitle() &#123; return this.title; &#125;</span><br><span class="line">    public void setId(final int id) &#123; this.id = id; &#125;</span><br><span class="line">    public int getId() &#123; return this.id; &#125;</span><br><span class="line"></span><br><span class="line">    public int compareTo(final Novel other) &#123; return this.id - other.id; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这个类实现了 <code>Comparable</code> 接口中的 <code>compareTo</code> 方法，因为 <code>Novel</code> 实例是存储在一个线程安全的无序 <code>ConcurrentHashMap</code> 中。在响应查看集合的请求时，“小说”服务会对从映射中提取的集合（一个 <code>ArrayList</code>）进行排序；<code>compareTo</code> 的实现通过 <code>Novel</code> 的 ID 将它按升序排序。</p><p><code>Novels</code> 类中包含多个实用工具函数：</p><h4 id="例-2：Novels-实用工具类"><a href="#例-2：Novels-实用工具类" class="headerlink" title="例 2：Novels 实用工具类"></a>例 2：Novels 实用工具类</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line">package novels;</span><br><span class="line"></span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.File;</span><br><span class="line">import java.io.ByteArrayOutputStream;</span><br><span class="line">import java.io.InputStream;</span><br><span class="line">import java.io.InputStreamReader;</span><br><span class="line">import java.io.BufferedReader;</span><br><span class="line">import java.nio.file.Files;</span><br><span class="line">import java.util.stream.Stream;</span><br><span class="line">import java.util.concurrent.ConcurrentMap;</span><br><span class="line">import java.util.concurrent.ConcurrentHashMap;</span><br><span class="line">import java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line">import java.util.Collections;</span><br><span class="line">import java.beans.XMLEncoder;</span><br><span class="line">import javax.servlet.ServletContext; // not in JavaSE</span><br><span class="line">import org.json.JSONObject;</span><br><span class="line">import org.json.XML;</span><br><span class="line"></span><br><span class="line">public class Novels &#123;</span><br><span class="line">    private final String fileName = &quot;/WEB-INF/data/novels.db&quot;;</span><br><span class="line">    private ConcurrentMap&lt;Integer, Novel&gt; novels;</span><br><span class="line">    private ServletContext sctx;</span><br><span class="line">    private AtomicInteger mapKey;</span><br><span class="line"></span><br><span class="line">    public Novels() &#123;</span><br><span class="line">        novels = new ConcurrentHashMap&lt;Integer, Novel&gt;();</span><br><span class="line">        mapKey = new AtomicInteger();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setServletContext(ServletContext sctx) &#123; this.sctx = sctx; &#125;</span><br><span class="line">    public ServletContext getServletContext() &#123; return this.sctx; &#125;</span><br><span class="line"></span><br><span class="line">    public ConcurrentMap&lt;Integer, Novel&gt; getConcurrentMap() &#123;</span><br><span class="line">        if (getServletContext() == null) return null; // not initialized</span><br><span class="line">        if (novels.size() &lt; 1) populate();</span><br><span class="line">        return this.novels;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String toXml(Object obj) &#123; // default encoding</span><br><span class="line">        String xml = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            ByteArrayOutputStream out = new ByteArrayOutputStream();</span><br><span class="line">            XMLEncoder encoder = new XMLEncoder(out);</span><br><span class="line">            encoder.writeObject(obj);</span><br><span class="line">            encoder.close();</span><br><span class="line">            xml = out.toString();</span><br><span class="line">        &#125;</span><br><span class="line">        catch(Exception e) &#123; &#125;</span><br><span class="line">        return xml;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String toJson(String xml) &#123; // option for requester</span><br><span class="line">        try &#123;</span><br><span class="line">            JSONObject jobt = XML.toJSONObject(xml);</span><br><span class="line">            return jobt.toString(3); // 3 is indentation level</span><br><span class="line">        &#125;</span><br><span class="line">        catch(Exception e) &#123; &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int addNovel(Novel novel) &#123;</span><br><span class="line">        int id = mapKey.incrementAndGet();</span><br><span class="line">        novel.setId(id);</span><br><span class="line">        novels.put(id, novel);</span><br><span class="line">        return id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void populate() &#123;</span><br><span class="line">        InputStream in = sctx.getResourceAsStream(this.fileName);</span><br><span class="line">        // Convert novel.db string data into novels.</span><br><span class="line">        if (in != null) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                InputStreamReader isr = new InputStreamReader(in);</span><br><span class="line">                BufferedReader reader = new BufferedReader(isr);</span><br><span class="line"></span><br><span class="line">                String record = null;</span><br><span class="line">                while ((record = reader.readLine()) != null) &#123;</span><br><span class="line">                    String[] parts = record.split(&quot;!&quot;);</span><br><span class="line">                    if (parts.length == 2) &#123;</span><br><span class="line">                        Novel novel = new Novel();</span><br><span class="line">                        novel.setAuthor(parts[0]);</span><br><span class="line">                        novel.setTitle(parts[1]);</span><br><span class="line">                        addNovel(novel); // sets the Id, adds to map</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                in.close();</span><br><span class="line">            &#125;</span><br><span class="line">            catch (IOException e) &#123; &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>最复杂的方法是 <code>populate</code>，这个方法从一个包含在 WAR 文件中的文本文件读取。这个文本文件包括了“小说”的初始集合。要打开此文件，<code>populate</code> 方法需要 <code>ServletContext</code>，这是一个 Java 映射类型，包含了关于嵌入在 servlet 容器中的 servlet 的所有关键信息。这个文本文件有包含了像下面这样的记录：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Jane Austen!Persuasion</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这一行被解析为两部分（作者和标题），由感叹号（<code>!</code>）分隔。然后这个方法创建一个 <code>Novel</code> 实例，设置作者和标题属性，并且将“小说”加到容器中，保存在内存中。</p><p><code>Novels</code> 类也有一些实用工具函数，可以将“小说”容器编码为 XML 或 JSON，取决于发出请求的人所要求的格式。默认是 XML 格式，但是也可以请求 JSON 格式。一个轻量级的 XML 转 JSON 包提供了 JSON。下面是关于编码的更多细节。</p><h4 id="例-3：NovelsServlet-类"><a href="#例-3：NovelsServlet-类" class="headerlink" title="例 3：NovelsServlet 类"></a>例 3：NovelsServlet 类</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br></pre></td><td class="code"><pre><span class="line">package novels;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.ConcurrentMap;</span><br><span class="line">import javax.servlet.ServletException;</span><br><span class="line">import javax.servlet.http.HttpServlet;</span><br><span class="line">import javax.servlet.http.HttpServletRequest;</span><br><span class="line">import javax.servlet.http.HttpServletResponse;</span><br><span class="line">import java.util.Arrays;</span><br><span class="line">import java.io.ByteArrayInputStream;</span><br><span class="line">import java.io.ByteArrayOutputStream;</span><br><span class="line">import java.io.OutputStream;</span><br><span class="line">import java.io.BufferedReader;</span><br><span class="line">import java.io.InputStreamReader;</span><br><span class="line">import java.beans.XMLEncoder;</span><br><span class="line">import org.json.JSONObject;</span><br><span class="line">import org.json.XML;</span><br><span class="line"></span><br><span class="line">public class NovelsServlet extends HttpServlet &#123;</span><br><span class="line">    static final long serialVersionUID = 1L;</span><br><span class="line">    private Novels novels; // back-end bean</span><br><span class="line"></span><br><span class="line">    // Executed when servlet is first loaded into container.</span><br><span class="line">    @Override</span><br><span class="line">    public void init() &#123;</span><br><span class="line">        this.novels = new Novels();</span><br><span class="line">        novels.setServletContext(this.getServletContext());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // GET /novels</span><br><span class="line">    // GET /novels?id=1</span><br><span class="line">    @Override</span><br><span class="line">    public void doGet(HttpServletRequest request, HttpServletResponse response) &#123;</span><br><span class="line">        String param = request.getParameter(&quot;id&quot;);</span><br><span class="line">        Integer key = (param == null) ? null : Integer.valueOf((param.trim()));</span><br><span class="line"></span><br><span class="line">        // Check user preference for XML or JSON by inspecting</span><br><span class="line">        // the HTTP headers for the Accept key.</span><br><span class="line">        boolean json = false;</span><br><span class="line">        String accept = request.getHeader(&quot;accept&quot;);</span><br><span class="line">        if (accept != null &amp;&amp; accept.contains(&quot;json&quot;)) json = true;</span><br><span class="line"></span><br><span class="line">        // If no query string, assume client wants the full list.</span><br><span class="line">        if (key == null) &#123;</span><br><span class="line">            ConcurrentMap&lt;Integer, Novel&gt; map = novels.getConcurrentMap();</span><br><span class="line">            Object list = map.values().toArray();</span><br><span class="line">            Arrays.sort(list);</span><br><span class="line"></span><br><span class="line">            String payload = novels.toXml(list);        // defaults to Xml</span><br><span class="line">            if (json) payload = novels.toJson(payload); // Json preferred?</span><br><span class="line">            sendResponse(response, payload);</span><br><span class="line">        &#125;</span><br><span class="line">        // Otherwise, return the specified Novel.</span><br><span class="line">        else &#123;</span><br><span class="line">            Novel novel = novels.getConcurrentMap().get(key);</span><br><span class="line">            if (novel == null) &#123; // no such Novel</span><br><span class="line">                String msg = key + &quot; does not map to a novel.\n&quot;;</span><br><span class="line">                sendResponse(response, novels.toXml(msg));</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123; // requested Novel found</span><br><span class="line">                if (json) sendResponse(response, novels.toJson(novels.toXml(novel)));</span><br><span class="line">                else sendResponse(response, novels.toXml(novel));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // POST /novels</span><br><span class="line">    @Override</span><br><span class="line">    public void doPost(HttpServletRequest request, HttpServletResponse response) &#123;</span><br><span class="line">        String author = request.getParameter(&quot;author&quot;);</span><br><span class="line">        String title = request.getParameter(&quot;title&quot;);</span><br><span class="line"></span><br><span class="line">        // Are the data to create a new novel present?</span><br><span class="line">        if (author == null || title == null)</span><br><span class="line">            throw new RuntimeException(Integer.toString(HttpServletResponse.SC_BAD_REQUEST));</span><br><span class="line"></span><br><span class="line">        // Create a novel.</span><br><span class="line">        Novel n = new Novel();</span><br><span class="line">        n.setAuthor(author);</span><br><span class="line">        n.setTitle(title);</span><br><span class="line"></span><br><span class="line">        // Save the ID of the newly created Novel.</span><br><span class="line">        int id = novels.addNovel(n);</span><br><span class="line"></span><br><span class="line">        // Generate the confirmation message.</span><br><span class="line">        String msg = &quot;Novel &quot; + id + &quot; created.\n&quot;;</span><br><span class="line">        sendResponse(response, novels.toXml(msg));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // PUT /novels</span><br><span class="line">    @Override</span><br><span class="line">    public void doPut(HttpServletRequest request, HttpServletResponse response) &#123;</span><br><span class="line">        /\* A workaround is necessary for a PUT request because Tomcat does not</span><br><span class="line"> generate a workable parameter map for the PUT verb. \*/</span><br><span class="line">        String key = null;</span><br><span class="line">        String rest = null;</span><br><span class="line">        boolean author = false;</span><br><span class="line"></span><br><span class="line">        /\* Let the hack begin. \*/</span><br><span class="line">        try &#123;</span><br><span class="line">            BufferedReader br =</span><br><span class="line">                new BufferedReader(new InputStreamReader(request.getInputStream()));</span><br><span class="line">            String data = br.readLine();</span><br><span class="line">            /\* To simplify the hack, assume that the PUT request has exactly</span><br><span class="line"> two parameters: the id and either author or title. Assume, further,</span><br><span class="line"> that the id comes first. From the client side, a hash character</span><br><span class="line"> # separates the id and the author/title, e.g.,</span><br><span class="line"></span><br><span class="line"> id=33#title=War and Peace</span><br><span class="line"> \*/</span><br><span class="line">            String[] args = data.split(&quot;#&quot;);      // id in args[0], rest in args[1]</span><br><span class="line">            String[] parts1 = args[0].split(&quot;=&quot;); // id = parts1[1]</span><br><span class="line">            key = parts1[1];</span><br><span class="line"></span><br><span class="line">            String[] parts2 = args[1].split(&quot;=&quot;); // parts2[0] is key</span><br><span class="line">            if (parts2[0].contains(&quot;author&quot;)) author = true;</span><br><span class="line">            rest = parts2[1];</span><br><span class="line">        &#125;</span><br><span class="line">        catch(Exception e) &#123;</span><br><span class="line">            throw new RuntimeException(Integer.toString(HttpServletResponse.SC_INTERNAL_SERVER_ERROR));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // If no key, then the request is ill formed.</span><br><span class="line">        if (key == null)</span><br><span class="line">            throw new RuntimeException(Integer.toString(HttpServletResponse.SC_BAD_REQUEST));</span><br><span class="line"></span><br><span class="line">        // Look up the specified novel.</span><br><span class="line">        Novel p = novels.getConcurrentMap().get(Integer.valueOf((key.trim())));</span><br><span class="line">        if (p == null) &#123; // not found</span><br><span class="line">            String msg = key + &quot; does not map to a novel.\n&quot;;</span><br><span class="line">            sendResponse(response, novels.toXml(msg));</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123; // found</span><br><span class="line">            if (rest == null) &#123;</span><br><span class="line">                throw new RuntimeException(Integer.toString(HttpServletResponse.SC_BAD_REQUEST));</span><br><span class="line">            &#125;</span><br><span class="line">            // Do the editing.</span><br><span class="line">            else &#123;</span><br><span class="line">                if (author) p.setAuthor(rest);</span><br><span class="line">                else p.setTitle(rest);</span><br><span class="line"></span><br><span class="line">                String msg = &quot;Novel &quot; + key + &quot; has been edited.\n&quot;;</span><br><span class="line">                sendResponse(response, novels.toXml(msg));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // DELETE /novels?id=1</span><br><span class="line">    @Override</span><br><span class="line">    public void doDelete(HttpServletRequest request, HttpServletResponse response) &#123;</span><br><span class="line">        String param = request.getParameter(&quot;id&quot;);</span><br><span class="line">        Integer key = (param == null) ? null : Integer.valueOf((param.trim()));</span><br><span class="line">        // Only one Novel can be deleted at a time.</span><br><span class="line">        if (key == null)</span><br><span class="line">            throw new RuntimeException(Integer.toString(HttpServletResponse.SC_BAD_REQUEST));</span><br><span class="line">        try &#123;</span><br><span class="line">            novels.getConcurrentMap().remove(key);</span><br><span class="line">            String msg = &quot;Novel &quot; + key + &quot; removed.\n&quot;;</span><br><span class="line">            sendResponse(response, novels.toXml(msg));</span><br><span class="line">        &#125;</span><br><span class="line">        catch(Exception e) &#123;</span><br><span class="line">            throw new RuntimeException(Integer.toString(HttpServletResponse.SC_INTERNAL_SERVER_ERROR));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Methods Not Allowed</span><br><span class="line">    @Override</span><br><span class="line">    public void doTrace(HttpServletRequest request, HttpServletResponse response) &#123;</span><br><span class="line">        throw new RuntimeException(Integer.toString(HttpServletResponse.SC_METHOD_NOT_ALLOWED));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void doHead(HttpServletRequest request, HttpServletResponse response) &#123;</span><br><span class="line">        throw new RuntimeException(Integer.toString(HttpServletResponse.SC_METHOD_NOT_ALLOWED));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void doOptions(HttpServletRequest request, HttpServletResponse response) &#123;</span><br><span class="line">        throw new RuntimeException(Integer.toString(HttpServletResponse.SC_METHOD_NOT_ALLOWED));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Send the response payload (Xml or Json) to the client.</span><br><span class="line">    private void sendResponse(HttpServletResponse response, String payload) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            OutputStream out = response.getOutputStream();</span><br><span class="line">            out.write(payload.getBytes());</span><br><span class="line">            out.flush();</span><br><span class="line">        &#125;</span><br><span class="line">        catch(Exception e) &#123;</span><br><span class="line">            throw new RuntimeException(Integer.toString(HttpServletResponse.SC_INTERNAL_SERVER_ERROR));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上面的 <code>NovelsServlet</code> 类继承了 <code>HttpServlet</code> 类，<code>HttpServlet</code> 类继承了 <code>GenericServlet</code> 类，后者实现了 <code>Servlet</code> 接口：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NovelsServlet extends HttpServlet extends GenericServlet implements Servlet</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>从名字可以很清楚的看出来，<code>HttpServlet</code> 是为实现 HTTP(S) 上的 servlet 设计的。这个类提供了以标准 HTTP 请求动词（官方说法，<ruby>方法 <rt>methods</rt></ruby>）命名的空方法：</p><ul><li><code>doPost</code> （Post &#x3D; 创建）</li><li><code>doGet</code> （Get &#x3D; 读取）</li><li><code>doPut</code> （Put &#x3D; 更新）</li><li><code>doDelete</code> （Delete &#x3D; 删除）</li></ul><p>其他一些 HTTP 动词也会涉及到。<code>HttpServlet</code> 的子类，比如 <code>NovelsServlet</code>，会重载相关的 <code>do</code> 方法，并且保留其他方法为<ruby>空 <rt>no-ops</rt></ruby>。<code>NovelsServlet</code> 重载了七个 <code>do</code> 方法。</p><p>每个 <code>HttpServlet</code> 的 CRUD 方法都有两个相同的参数。下面以 <code>doPost</code> 为例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public void doPost(HttpServletRequest request, HttpServletResponse response) &#123;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>request</code> 参数是一个 HTTP 请求信息的映射，而 <code>response</code> 提供了一个返回给请求者的输出流。像 <code>doPost</code> 的方法，结构如下：</p><ul><li>读取 <code>request</code> 信息，采取任何适当的措施生成一个响应。如果该信息丢失或者损坏了，就会生成一个错误。</li><li>使用提取的请求信息来执行适当的 CRUD 操作（在本例中，创建一个 <code>Novel</code>），然后使用 <code>response</code> 输出流为请求者编码一个适当的响应。在 <code>doPost</code> 例子中，响应就是已经成功生成一个新“小说”并且添加到容器中的一个确认。当响应被发送后，输出流就关闭了，同时也将连接关闭了。</li></ul><h3 id="关于方法重载的更多内容"><a href="#关于方法重载的更多内容" class="headerlink" title="关于方法重载的更多内容"></a>关于方法重载的更多内容</h3><p>HTTP 请求的格式相对比较简单。下面是一个非常熟悉的 HTTP 1.1 的格式，注释由双井号分隔：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">GET /novels              ## start line</span><br><span class="line">Host: localhost:8080     ## header element</span><br><span class="line">Accept-type: text/plain  ## ditto</span><br><span class="line">...</span><br><span class="line">[body]                   ## POST and PUT only</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>第一行由 HTTP 动词（在本例中是 <code>GET</code>）和以名词（在本例中是 <code>novels</code>）命名目标资源的 URI 开始。报头中包含键-值对，用冒号分隔左面的键和右面的值。报头中的键 <code>Host</code>（大小写敏感）是必须的；主机名 <code>localhost</code> 是当前机器上的本地符号地址，<code>8080</code> 端口是 Tomcat web 服务器上等待 HTTP 请求的默认端口。（默认情况下，Tomcat 在 8443 端口上监听 HTTP 请求。）报头元素可以以任意顺序出现。在这个例子中，<code>Accept-type</code> 报头的值是 MIME 类型 <code>text/plain</code>。</p><p>一些请求（特别是 <code>POST</code> 和 <code>PUT</code>）会有报文，而其他请求（特别是 <code>GET</code> 和 <code>DELETE</code>）没有。如果有报文（可能为空），以两个换行符将报头和报文分隔开；HTTP 报文包含一系列键-值对。对于无报文的请求，比如说查询字符串，报头元素就可以用来发送信息。下面是一个用 ID 2 对 <code>/novels</code> 资源的 <code>GET</code> 请求：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GET /novels?id=2</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>通常来说，查询字符串以问号开始，并且包含一个键-值对，尽管这个键-值可能值为空。</p><p>带有 <code>getParameter</code> 和 <code>getParameterMap</code> 等方法的 <code>HttpServlet</code> 很好地回避了有报文和没有报文的 HTTP 请求之前的差异。在“小说”例子中，<code>getParameter</code> 方法用来从 <code>GET</code>、<code>POST</code> 和 <code>DELETE</code> 方法中提取所需的信息。（处理 <code>PUT</code>请求需要更底层的代码，因为 Tomcat 没有提供可以解析 <code>PUT</code> 请求的参数映射。）下面展示了一段在 <code>NovelsServlet</code>中被重载的 <code>doPost</code> 方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void doPost(HttpServletRequest request, HttpServletResponse response) &#123;</span><br><span class="line">   String author = request.getParameter(&quot;author&quot;);</span><br><span class="line">   String title = request.getParameter(&quot;title&quot;);</span><br><span class="line">   ...</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>对于没有报文的 <code>DELETE</code> 请求，过程基本是一样的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void doDelete(HttpServletRequest request, HttpServletResponse response) &#123;</span><br><span class="line">   String param = request.getParameter(&quot;id&quot;); // id of novel to be removed</span><br><span class="line">   ...</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>doGet</code> 方法需要区分 <code>GET</code> 请求的两种方式：一种是“获得所有”，而另一种是“获得某一个”。如果 <code>GET</code> 请求 URL 中包含一个键是一个 ID 的查询字符串，那么这个请求就被解析为“获得某一个”：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http://localhost:8080/novels?id=2  ## GET specified</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如果没有查询字符串，<code>GET</code> 请求就会被解析为“获得所有”：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http://localhost:8080/novels       ## GET all</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="一些值得注意的细节"><a href="#一些值得注意的细节" class="headerlink" title="一些值得注意的细节"></a>一些值得注意的细节</h3><p>“小说”服务的设计反映了像 Tomcat 这样基于 Java 的 web 服务器是如何工作的。在启动时，Tomcat 构建一个线程池，从中提取请求处理程序，这种方法称为 “<ruby>每个请求一个线程 <rt>one thread per request</rt></ruby>” 模型。现在版本的 Tomcat 使用非阻塞 I&#x2F;O 来提高个性能。</p><p>“小说”服务是作为 <code>NovelsServlet</code> 类的单个实例来执行的，该实例也就维护了一个“小说”集合。相应的，也就会出现竞态条件，比如出现两个请求同时被处理：</p><ul><li>一个请求向集合中添加一个新“小说”。</li><li>另一个请求获得集合中的所有“小说”。</li></ul><p>这样的结果是不确定的，取决与 <em>读</em> 和 <em>写</em> 的操作是以怎样的顺序进行操作的。为了避免这个问题，“小说”服务使用了线程安全的 <code>ConcurrentMap</code>。这个映射的关键是生成了一个线程安全的 <code>AtomicInteger</code>。下面是相关的代码片段：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class Novels &#123;</span><br><span class="line">    private ConcurrentMap&lt;Integer, Novel&gt; novels;</span><br><span class="line">    private AtomicInteger mapKey;</span><br><span class="line">    ...</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>默认情况下，对客户端请求的响应被编码为 XML。为了简单，“小说”程序使用了以前的 <code>XMLEncoder</code> 类；另一个包含更丰富功能的方式是使用 JAX-B 库。代码很简单：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public String toXml(Object obj) &#123; // default encoding</span><br><span class="line">   String xml = null;</span><br><span class="line">   try &#123;</span><br><span class="line">      ByteArrayOutputStream out = new ByteArrayOutputStream();</span><br><span class="line">      XMLEncoder encoder = new XMLEncoder(out);</span><br><span class="line">      encoder.writeObject(obj);</span><br><span class="line">      encoder.close();</span><br><span class="line">      xml = out.toString();</span><br><span class="line">   &#125;</span><br><span class="line">   catch(Exception e) &#123; &#125;</span><br><span class="line">   return xml;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>Object</code> 参数要么是一个有序的“小说” <code>ArraList</code>（用以响应“<ruby>获得所有 <rt>get all</rt></ruby>”请求），要么是一个 <code>Novel</code> 实例（用以响应“<ruby>获得一个 <rt>get one</rt></ruby>”请求），又或者是一个 <code>String</code>（确认消息）。</p><p>如果 HTTP 请求报头指定 JSON 作为所需要的类型，那么 XML 就被转化成 JSON。下面是 <code>NovelsServlet</code> 中的 <code>doGet</code> 方法中的检查：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String accept = request.getHeader(&quot;accept&quot;); // &quot;accept&quot; is case insensitive</span><br><span class="line">if (accept != null &amp;&amp; accept.contains(&quot;json&quot;)) json = true;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>Novels</code>类中包含了 <code>toJson</code> 方法，可以将 XML 转换成 JSON：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public String toJson(String xml) &#123; // option for requester</span><br><span class="line">   try &#123;</span><br><span class="line">      JSONObject jobt = XML.toJSONObject(xml);</span><br><span class="line">      return jobt.toString(3); // 3 is indentation level</span><br><span class="line">   &#125;</span><br><span class="line">   catch(Exception e) &#123; &#125;</span><br><span class="line">   return null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>NovelsServlet</code>会对各种类型进行错误检查。比如，<code>POST</code> 请求应该包含新“小说”的作者和标题。如果有一个丢了，<code>doPost</code> 方法会抛出一个异常：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (author == null || title == null)</span><br><span class="line">   throw new RuntimeException(Integer.toString(HttpServletResponse.SC_BAD_REQUEST));</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>SC_BAD_REQUEST</code> 中的 <code>SC</code> 代表的是 <ruby>状态码 <rt>status code</rt></ruby>，<code>BAD_REQUEST</code> 的标准 HTTP 数值是 400。如果请求中的 HTTP 动词是 <code>TRACE</code>，会返回一个不同的状态码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public void doTrace(HttpServletRequest request, HttpServletResponse response) &#123;</span><br><span class="line">   throw new RuntimeException(Integer.toString(HttpServletResponse.SC_METHOD_NOT_ALLOWED));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="测试“小说”服务"><a href="#测试“小说”服务" class="headerlink" title="测试“小说”服务"></a>测试“小说”服务</h3><p>用浏览器测试 web 服务会很不顺手。在 CRUD 动词中，现代浏览器只能生成 <code>POST</code>（创建）和 <code>GET</code>（读取）请求。甚至从浏览器发送一个 <code>POST</code> 请求都有点不好办，因为报文需要包含键-值对；这样的测试通常通过 HTML 表单完成。命令行工具，比如说 <a target="_blank" rel="noopener" href="https://curl.haxx.se/">curl</a>，是一个更好的选择，这个部分展示的一些 <code>curl</code> 命令，已经包含在我网站的 ZIP 文件中了。</p><p>下面是一些测试样例，没有展示相应的输出结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">% curl localhost:8080/novels/</span><br><span class="line">% curl localhost:8080/novels?id=1</span><br><span class="line">% curl --header &quot;Accept: application/json&quot; localhost:8080/novels/</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>第一条命令请求所有“小说”，默认是 XML 编码。第二条命令请求 ID 为 1 的“小说”，XML 编码。最后一条命令通过 <code>application/json</code> 添加了 <code>Accept</code> 报头元素，作为所需要的 MIME 类型。“<ruby>获得一个 <rt>get one</rt></ruby>”命令也可以用这个报头。这些请求用了 JSON 而不是 XML 编码作为响应。</p><p>下面两条命令在集合中创建了一个新“小说”，并且确认添加了进去：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">% curl --request POST --data &quot;author=Tolstoy&amp;amp;title=War and Peace&quot; localhost:8080/novels/</span><br><span class="line">% curl localhost:8080/novels?id=4</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>curl</code> 中的 <code>PUT</code> 命令与 <code>POST</code> 命令相似，不同的地方是 <code>PUT</code> 的报文没有使用标准的语法。在 <code>NovelsServlet</code> 中关于 <code>doPut</code> 方法的文档中有详细的介绍，但是简单来说，Tomcat 不会对 <code>PUT</code> 请求生成合适的映射。下面是一个 <code>PUT</code> 命令和确认命令的的例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">% curl --request PUT --data &quot;id=3#title=This is an UPDATE&quot; localhost:8080/novels/</span><br><span class="line">% curl localhost:8080/novels?id=3</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>第二个命令确认了集合已经更新。</p><p>最后，<code>DELETE</code> 命令会正常运行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">% curl --request DELETE localhost:8080/novels?id=2</span><br><span class="line">% curl localhost:8080/novels/</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这个请求是删除 ID 为 2 的“小说”。第二个命令会显示剩余的“小说”。</p><h3 id="web-xml-配置文件"><a href="#web-xml-配置文件" class="headerlink" title="web.xml 配置文件"></a>web.xml 配置文件</h3><p>尽管官方规定它是可选的，<code>web.xml</code> 配置文件是一个生产级别网站或服务的重要组成部分。这个配置文件可以配置独立于代码的路由、安全性，或者网站或服务的其他功能。“小说”服务的配置通过为该服务的请求分配一个 URL 模式来配置路由：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;xml version = &quot;1.0&quot; encoding = &quot;UTF-8&quot;&gt;</span><br><span class="line">&lt;web-app&gt;</span><br><span class="line">   &lt;servlet&gt;</span><br><span class="line">     &lt;servlet-name&gt;novels&lt;/servlet-name&gt;</span><br><span class="line">     &lt;servlet-class&gt;novels.NovelsServlet&lt;/servlet-class&gt;</span><br><span class="line">   &lt;/servlet&gt;</span><br><span class="line">   &lt;servlet-mapping&gt;</span><br><span class="line">     &lt;servlet-name&gt;novels&lt;/servlet-name&gt;</span><br><span class="line">     &lt;url-pattern&gt;/*&lt;/url-pattern&gt;</span><br><span class="line">   &lt;/servlet-mapping&gt;</span><br><span class="line">&lt;/web-app&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>servlet-name</code> 元素为 servlet 全名（<code>novels.NovelsServlet</code>）提供了一个缩写（<code>novels</code>），然后这个名字在下面的 <code>servlet-mapping</code> 元素中使用。</p><p>回想一下，一个已部署服务的 URL 会在端口号后面有 WAR 文件的文件名：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http://localhost:8080/novels/</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>端口号后斜杠后的 URI，是所请求资源的“路径”，在这个例子中，就是“小说”服务。因此，<code>novels</code> 出现在了第一个单斜杠后。</p><p>在 <code>web.xml</code> 文件中，<code>url-patter</code> 被指定为 <code>/*</code>，代表 “以 <code>/novels</code> 为起始的任意路径”。假设 Tomcat 遇到了一个不存在的 URL，像这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http://localhost:8080/novels/foobar/</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>web.xml</code> 配置也会指定这个请求被分配到“小说” servlet 中，因为 <code>/*</code> 模式也包含 <code>/foobar</code>。因此，这个不存在的 URL 也会得到像上面合法路径的相同结果。</p><p>生产级别的配置文件可能会包含安全相关的信息，包括<ruby>连接级别 <rt>wire-level</rt></ruby>和<ruby>用户角色 <rt>users-roles</rt></ruby>。即使在这种情况下，配置文件的大小也只会是这个例子中的两到三倍大。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><code>HttpServlet</code> 是 Java web 技术的核心。像“小说”这样的网站或 web 服务继承了这个类，并且根据需求重载了相应的 <code>do</code> 动词方法。像 Jersay（JAX-RS）或 Restlet 这样的 Restful 框架通过提供定制的 servlet 完成了基本相同的功能，针对框架中的 web 应用程序的请求，这个 servlet 扮演着 HTTP(S) <ruby>终端 <rt>endpoint</rt></ruby>的角色。</p><p>当然，基于 servlet 的应用程序可以访问 web 应用程序中所需要的任何 Java 库。如果应用程序遵循<ruby>关注点分离 <rt>separation-of-concerns</rt></ruby>原则，那么 servlet 代码仍然相当简单：代码会检查请求，如果存在缺陷，就会发出适当的错误；否则，代码会调用所需要的功能（比如，查询数据库，以特定格式为响应编码），然后向请求这发送响应。<code>HttpServletRequest</code> 和 <code>HttpServletReponse</code> 类型使得读取请求和编写响应变得简单。</p><p>Java 的 API 可以从非常简单变得相当复杂。如果你需要用 Java 交付一些 Restful 服务的话，我的建议是在做其他事情之前先尝试一下简单的 <code>HttpServlet</code>。</p><hr><p>via: <a target="_blank" rel="noopener" href="https://opensource.com/article/20/7/restful-services-java">https://opensource.com/article/20/7/restful-services-java</a></p><p>作者：<a target="_blank" rel="noopener" href="https://opensource.com/users/mkalindepauledu">Marty Kalin</a> 选题：<a target="_blank" rel="noopener" href="https://github.com/lujun9972">lujun9972</a> 译者：<a target="_blank" rel="noopener" href="https://github.com/Yufei-Yan">Yufei-Yan</a> 校对：<a target="_blank" rel="noopener" href="https://github.com/wxy">wxy</a></p><p>本文由 <a target="_blank" rel="noopener" href="https://github.com/LCTT/TranslateProject">LCTT</a> 原创编译，<a target="_blank" rel="noopener" href="https://linux.cn/">Linux中国</a> 荣誉推出</p></div></div></div><div class="footer"><p class="footer-copyright"><span>Powered by <a target="_blank" href="https://hexo.io">Hexo</a></span> <span>Theme <a target="_blank" href="https://github.com/tinkink-co/hexo-theme-terminal">Terminal</a></span><script type="text/javascript" src="https://cdn.staticfile.net/jquery/3.4.1/jquery.min.js"></script><script>getCDNinfo=function(){$.ajax({url:"/cdn-cgi/trace",success:function(a,n){let i="Antananarivo, Madagascar - (TNR);Cape Town, South Africa - (CPT);Casablanca, Morocco - (CMN);Dar Es Salaam, Tanzania - (DAR);Djibouti City, Djibouti - (JIB);Durban, South Africa - (DUR);Johannesburg, South Africa - (JNB);Kigali, Rwanda - (KGL);Lagos, Nigeria - (LOS);Luanda, Angola - (LAD);Maputo, MZ - (MPM);Mombasa, Kenya - (MBA);Port Louis, Mauritius - (MRU);Réunion, France - (RUN);Bangalore, India - (BLR);Bangkok, Thailand - (BKK);Bandar Seri Begawan, Brunei - (BWN);Cebu, Philippines - (CEB);Chengdu, China - (CTU);Chennai, India - (MAA);Chittagong, Bangladesh - (CGP);Chongqing, China - (CKG);Colombo, Sri Lanka - (CMB);Dhaka, Bangladesh - (DAC);Dongguan, China - (SZX);Foshan, China - (FUO);Fuzhou, China - (FOC);Guangzhou, China - (CAN);Hangzhou, China - (HGH);Hanoi, Vietnam - (HAN);Hengyang, China - (HNY);Ho Chi Minh City, Vietnam - (SGN);Hong Kong - (HKG);Hyderabad, India - (HYD);Islamabad, Pakistan - (ISB);Jakarta, Indonesia - (CGK);Jinan, China - (TNA);Karachi, Pakistan - (KHI);Kathmandu, Nepal - (KTM);Kolkata, India - (CCU);Kuala Lumpur, Malaysia - (KUL);Lahore, Pakistan - (LHE);Langfang, China - (NAY);Luoyang, China - (LYA);Macau - (MFM);Malé, Maldives - (MLE);Manila, Philippines - (MNL);Mumbai, India - (BOM);Nagpur, India - (NAG);Nanning, China - (NNG);New Delhi, India - (DEL);Osaka, Japan - (KIX);Phnom Penh, Cambodia - (PNH);Qingdao, China - (TAO);Seoul, South Korea - (ICN);Shanghai, China - (SHA);Shenyang, China - (SHE);Shijiazhuang, China - (SJW);Singapore, Singapore - (SIN);Suzhou, China - (SZV);Taipei - (TPE);Thimphu, Bhutan - (PBH);Tianjin, China - (TSN);Tokyo, Japan - (NRT);Ulaanbaatar, Mongolia - (ULN);Vientiane, Laos - (VTE);Wuhan, China - (WUH);Wuxi, China - (WUX);Xi'an, China - (XIY);Yerevan, Armenia - (EVN);Zhengzhou, China - (CGO);Zuzhou, China - (CSX);Amsterdam, Netherlands - (AMS);Athens, Greece - (ATH);Barcelona, Spain - (BCN);Belgrade, Serbia - (BEG);Berlin, Germany - (TXL);Brussels, Belgium - (BRU);Bucharest, Romania - (OTP);Budapest, Hungary - (BUD);Chișinău, Moldova - (KIV);Copenhagen, Denmark - (CPH);Cork, Ireland -  (ORK);Dublin, Ireland - (DUB);Düsseldorf, Germany - (DUS);Edinburgh, United Kingdom - (EDI);Frankfurt, Germany - (FRA);Geneva, Switzerland - (GVA);Gothenburg, Sweden - (GOT);Hamburg, Germany - (HAM);Helsinki, Finland - (HEL);Istanbul, Turkey - (IST);Kyiv, Ukraine - (KBP);Lisbon, Portugal - (LIS);London, United Kingdom - (LHR);Luxembourg City, Luxembourg - (LUX);Madrid, Spain - (MAD);Manchester, United Kingdom - (MAN);Marseille, France - (MRS);Milan, Italy - (MXP);Moscow, Russia - (DME);Munich, Germany - (MUC);Nicosia, Cyprus - (LCA);Oslo, Norway - (OSL);Paris, France - (CDG);Prague, Czech Republic - (PRG);Reykjavík, Iceland - (KEF);Riga, Latvia - (RIX);Rome, Italy - (FCO);Saint Petersburg, Russia - (LED);Sofia, Bulgaria - (SOF);Stockholm, Sweden - (ARN);Tallinn, Estonia - (TLL);Thessaloniki, Greece - (SKG);Vienna, Austria - (VIE);Vilnius, Lithuania - (VNO);Warsaw, Poland - (WAW);Zagreb, Croatia - (ZAG);Zürich, Switzerland - (ZRH);Arica, Chile - (ARI);Asunción, Paraguay - (ASU);Bogotá, Colombia - (BOG);Buenos Aires, Argentina - (EZE);Curitiba, Brazil - (CWB);Fortaleza, Brazil - (FOR);Guatemala City, Guatemala - (GUA);Lima, Peru - (LIM);Medellín, Colombia - (MDE);Panama City, Panama - (PTY);Porto Alegre, Brazil - (POA);Quito, Ecuador - (UIO);Rio de Janeiro, Brazil - (GIG);São Paulo, Brazil - (GRU);Santiago, Chile - (SCL);Willemstad, Curaçao - (CUR);St. George's, Grenada - (GND);Amman, Jordan - (AMM);Baghdad, Iraq - (BGW);Baku, Azerbaijan - (GYD);Beirut, Lebanon - (BEY);Doha, Qatar - (DOH);Dubai, United Arab Emirates - (DXB);Kuwait City, Kuwait - (KWI);Manama, Bahrain - (BAH);Muscat, Oman - (MCT);Ramallah - (ZDM);Riyadh, Saudi Arabia - (RUH);Tel Aviv, Israel - (TLV);Ashburn, VA, United States - (IAD);Atlanta, GA, United States - (ATL);Boston, MA, United States - (BOS);Buffalo, NY, United States - (BUF);Calgary, AB, Canada - (YYC);Charlotte, NC, United States - (CLT);Chicago, IL, United States - (ORD);Columbus, OH, United States - (CMH);Dallas, TX, United States - (DFW);Denver, CO, United States - (DEN);Detroit, MI, United States - (DTW);Honolulu, HI, United States - (HNL);Houston, TX, United States - (IAH);Indianapolis, IN, United States - (IND);Jacksonville, FL, United States - (JAX);Kansas City, MO, United States - (MCI);Las Vegas, NV, United States - (LAS);Los Angeles, CA, United States - (LAX);McAllen, TX, United States - (MFE);Memphis, TN, United States - (MEM);Mexico City, Mexico - (MEX);Miami, FL, United States - (MIA);Minneapolis, MN, United States - (MSP);Montgomery, AL, United States - (MGM);Montréal, QC, Canada - (YUL);Nashville, TN, United States - (BNA);Newark, NJ, United States - (EWR);Norfolk, VA, United States - (ORF);Omaha, NE, United States - (OMA);Philadelphia, United States - (PHL);Phoenix, AZ, United States - (PHX);Pittsburgh, PA, United States - (PIT);Port-Au-Prince, Haiti - (PAP);Portland, OR, United States - (PDX);Queretaro, MX, Mexico - (QRO);Richmond, Virginia - (RIC);Sacramento, CA, United States - (SMF);Salt Lake City, UT, United States - (SLC);San Diego, CA, United States - (SAN);San Jose, CA, United States - (SJC);Saskatoon, SK, Canada - (YXE);Seattle, WA, United States - (SEA);St. Louis, MO, United States - (STL);Tampa, FL, United States - (TPA);Toronto, ON, Canada - (YYZ);Vancouver, BC, Canada - (YVR);Tallahassee, FL, United States - (TLH);Winnipeg, MB, Canada - (YWG);Adelaide, SA, Australia - (ADL);Auckland, New Zealand - (AKL);Brisbane, QLD, Australia - (BNE);Melbourne, VIC, Australia - (MEL);Noumea, New caledonia - (NOU);Perth, WA, Australia - (PER);Sydney, NSW, Australia - (SYD)".split(";"),e=a.split("colo=")[1].split("\n")[0],t=(a.split("colo=")[1].split("\n")[0],a.split("tls=")[1].split("\n")[0]),o=a.split("http=")[1].split("\n")[0],s=a.split("sni=")[1].split("\n")[0],r=a.split("ip=")[1].split("\n")[0],l=a.split("uag=")[1].split("\n")[0];for(var d=0;d<i.length;d++)if(-1!=i[d].indexOf(e)){document.getElementById("cdn").innerHTML=i[d];break}document.getElementById("tls").innerHTML=t,document.getElementById("http").innerHTML=o,document.getElementById("sni").innerHTML=s,document.getElementById("ip").innerHTML=r,document.getElementById("useragent").innerHTML=l}})},$(document).ready((function(){getCDNinfo()}))</script></p><p style="text-align:center">感谢陪伴与布道，开源之火不灭。​</p><p style="text-align:center"><script>document.write("本次加载耗时: "+(performance.getEntriesByType("navigation").reduce((e,r)=>e+r.responseEnd-r.startTime,0)+performance.getEntriesByType("resource").reduce((e,r)=>e+r.responseEnd-r.startTime,0)).toFixed(0)+"ms")</script></p><p style="text-align:center">当前 SNI 状态： <span id="sni">正在统计！或可能被浏览器防追踪拦截！</span></p><p style="text-align:center">当前 TLS 版本： <span id="tls">正在统计！或可能被浏览器防追踪拦截！</span></p><p style="text-align:center">当前 HTTP 版本： <span id="http">正在统计！或可能被浏览器防追踪拦截！</span></p><p style="text-align:center">当前您的客户端 IP 是： <span id="ip">正在统计！或可能被浏览器防追踪拦截！</span></p><p style="text-align:center">当前分配的 CDN 节点是: <span id="cdn">正在统计！或可能被浏览器防追踪拦截！</span></p><p style="text-align:center">您的 UserAgent 信息是: <span id="useragent">正在统计！或可能被浏览器防追踪拦截！</span></p><p></p><script defer src="https://pv.undefined.today/tracker.min.js" data-website-id="LinuxCNMirror-tracker"></script></div></div></body></html>