<!doctype html><html lang="en"><head><meta name="description" content="一个LinuxCN的镜像站"><meta name="msvalidate.01" content="D404690CEFCB54C7762AC84935B99171"><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?6618da70c90c8744eead2e9371fb5077";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><script type="text/javascript">!function(t,e,n,c,s,a,r){t[n]=t[n]||function(){(t[n].q=t[n].q||[]).push(arguments)},(a=e.createElement(c)).async=1,a.src="https://www.clarity.ms/tag/s5f3f0tojf",(r=e.getElementsByTagName(c)[0]).parentNode.insertBefore(a,r)}(window,document,"clarity","script")</script><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta http-equiv="X-UA-Compatible" content="ie=edge"><link rel="stylesheet" href="/styles/base.css"><link rel="stylesheet" href="/styles/theme.css"><link rel="shortcut icon" href="/favicon.png"><title>通过 ftrace 来分析 Linux 内核 - 归墟星火集 又一个 LinuxCN 站点</title><meta name="generator" content="Hexo 7.3.0"></head><body><div class="header-title"><span class="header-light"></span> <span class="header-light"></span> <span class="header-light"></span> <span>归墟星火集 又一个 LinuxCN 站点 linuxcn.undefined.today<span></span></span></div><div class="container"><ul class="nav"><li><a href="/">首页</a></li><li><a target="_blank" rel="noopener" href="https://undefined.today/">Blog</a></li></ul><div class="content"><div class="post-container"><div class="post-header"><span class="ui-tips">标题：</span><h1 class="ui-keyword post-title">通过 ftrace 来分析 Linux 内核</h1><span class="post-date">2021-09-05</span></div><div class="post-header"><span class="ui-tips">分类：</span> <a href="/categories/%E6%8A%80%E6%9C%AF/">技术</a></div><div class="post-header"><span class="ui-tips">标签：</span> <a href="/tags/strace/">strace</a> <a href="/tags/%E8%BF%BD%E8%B8%AA/">追踪</a> <a href="/tags/ftrace/">ftrace</a></div><div class="post-content"><blockquote><p>通过 <code>ftrace</code> 来了解 Linux 内核内部工作方式是一个好方法。</p></blockquote><p><img src="https://linuxcn.img.undefined.today/data/attachment/album/202109/05/151954cb5z5rg7zqa9lbzu.jpg" title="Linux keys on the keyboard for a desktop computer"></p><p>操作系统的内核是最难以理解的软件之一。自从你的系统启动后，它会一直在后台运行。尽管每个用户都不与内核直接交互，但他们在内核的帮助下完成自己的计算任务。与内核的交互发生在调用系统调用或者用户日常使用的各种库或应用间接调用了系统调用。</p><p>在之前的文章里我介绍了如何使用 <a href="/article-11545-1.html">strace</a> 来追踪系统调用。然而，使用 <code>strace</code> 时你的视野是有限的。它允许你查看特定参数的系统调用。并在工作完成后，看到其返回值或状态，以表明是成功还是失败。但是你无法知道内核在这段时间内发生了什么。除了系统调用外，还有很多其他活动内核中发生，而你却视而不见。</p><h3 id="ftrace-介绍"><a href="#ftrace-介绍" class="headerlink" title="ftrace 介绍"></a>ftrace 介绍</h3><p>本文的旨在通过使用一个名为 <code>ftrace</code> 的机制来阐明追踪内核函数的一些情况。它使得任何 Linux 用户可以轻松地追踪内核，并且了解更多关于 Linux 内核内部如何工作。</p><p><code>ftrace</code> 默认产生的输出往往是巨大的，因为内核总是忙碌的。为了节省空间，很多情况下我会通过截断来给出尽量小的输出。</p><p>我使用 Fedora 来演示下面的例子，但是它们应该在其他最新的 Linux 发行版上同样可以运行。</p><h3 id="启用-ftrace"><a href="#启用-ftrace" class="headerlink" title="启用 ftrace"></a>启用 ftrace</h3><p><code>ftrace</code> 现在已经是内核中的一部分了，你不再需要事先安装它了。也就是说，如果你在使用最近的 Linux 系统，那么 <code>ftrace</code> 是已经启用了的。为了验证 <code>ftrace</code> 是否可用，运行 <code>mount</code> 命令并查找 <code>tracefs</code>。如果你看到类似下面的输出，表示 <code>ftrace</code> 已经启用，你可以轻松地尝试本文中下面的例子。下面有些命令需要在 root 用户下使用（用 <code>sudo</code> 执行是不够的）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># mount | grep tracefs</span><br><span class="line">none on /sys/kernel/tracing type tracefs (rw,relatime,seclabel)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>要想使用 <code>ftrace</code>，你首先需要进入上面 <code>mount</code> 命令中找到的特定目录中，在那个目录下运行文章中的其他命令。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># cd /sys/kernel/tracing</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="一般的工作流程"><a href="#一般的工作流程" class="headerlink" title="一般的工作流程"></a>一般的工作流程</h3><p>首先，你需要理解捕捉踪迹和获取输出的一般流程。如果你直接运行 <code>ftrace</code>，不会运行任何特定的 <code>ftrace</code> 命令。相反的，基本操作是通过标准 Linux 命令来写入或读取一些文件。</p><p>一般的步骤如下：</p><ol><li>通过写入一些特定文件来启用&#x2F;结束追踪</li><li>通过写入一些特定文件来设置&#x2F;取消追踪时的过滤规则</li><li>从文件中读取基于第 1 和 2 步的追踪输出</li><li>从文件中清除早期输出或缓冲区</li><li>缩小到你的特定用例（你要追踪的内核函数），重复 1、2、3、4 步</li></ol><h3 id="可用的追踪器类型"><a href="#可用的追踪器类型" class="headerlink" title="可用的追踪器类型"></a>可用的追踪器类型</h3><p>有多种不同的追踪器可供使用。之前提到，在运行任何命令前，你需要进入一个特定的目录下，因为需要的文件在这些目录下。我在我的例子中使用了相对路径（而不是绝对路径）。</p><p>你可以查看 <code>available_tracers</code> 文件内容来查看所有可用的追踪器类型。你可以看下面列出了几个。不需要担心这些：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ pwd</span><br><span class="line">/sys/kernel/tracing</span><br><span class="line"></span><br><span class="line">$ sudo cat available_tracers</span><br><span class="line">hwlat blk mmiotrace function_graph wakeup_dl wakeup_rt wakeup function nop</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在所有输出的追踪器中，我会聚焦于下面三个特殊的：启用追踪的 <code>function</code> 和 <code>function_graph</code>，以及停止追踪的 <code>nop</code>。</p><h3 id="确认当前的追踪器"><a href="#确认当前的追踪器" class="headerlink" title="确认当前的追踪器"></a>确认当前的追踪器</h3><p>通常情况默认的追踪器设定为 <code>nop</code>。即在特殊文件中 <code>current_tracer</code> 中的 “无操作”，这意味着追踪目前是关闭的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ pwd</span><br><span class="line">/sys/kernel/tracing</span><br><span class="line"></span><br><span class="line">$ sudo cat current_tracer</span><br><span class="line">nop</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="查看追踪输出"><a href="#查看追踪输出" class="headerlink" title="查看追踪输出"></a>查看追踪输出</h3><p>在启用任何追踪功能之前，请你看一下保存追踪输出的文件。你可以用 <a target="_blank" rel="noopener" href="https://opensource.com/article/19/2/getting-started-cat-command">cat</a> 命令查看名为 <code>trace</code> 的文件的内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># cat trace</span><br><span class="line"></span><br><span class="line"># tracer: nop</span><br><span class="line">#</span><br><span class="line"># entries-in-buffer/entries-written: 0/0   #P:8</span><br><span class="line">#</span><br><span class="line">#                                _-----=&gt; irqs-off</span><br><span class="line">#                               / _----=&gt; need-resched</span><br><span class="line">#                              | / _---=&gt; hardirq/softirq</span><br><span class="line">#                              || / _--=&gt; preempt-depth</span><br><span class="line">#                              ||| /     delay</span><br><span class="line">#           TASK-PID     CPU#  ||||   TIMESTAMP  FUNCTION</span><br><span class="line">#              | |         |   ||||      |         |</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="启用-function-追踪器"><a href="#启用-function-追踪器" class="headerlink" title="启用 function 追踪器"></a>启用 function 追踪器</h3><p>你可以通过向 <code>current_tracer</code> 文件写入 <code>function</code> 来启用第一个追踪器 <code>function</code>（文件原本内容为 <code>nop</code>，意味着追踪是关闭的）。把这个操作看成是启用追踪的一种方式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ pwd</span><br><span class="line">/sys/kernel/tracing</span><br><span class="line"></span><br><span class="line">$ sudo cat current_tracer</span><br><span class="line">nop</span><br><span class="line">$ echo function &gt; current_tracer</span><br><span class="line">$</span><br><span class="line">$ cat current_tracer</span><br><span class="line">function</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="查看-function-追踪器的更新追踪输出"><a href="#查看-function-追踪器的更新追踪输出" class="headerlink" title="查看 function 追踪器的更新追踪输出"></a>查看 function 追踪器的更新追踪输出</h3><p>现在你已启用追踪，是时候查看输出了。如果你查看 <code>trace</code> 文件内容，你将会看到许多被连续写入的内容。我通过管道只展示了文件内容的前 20 行。根据左边输出的标题，你可以看到在某个 CPU 上运行的任务和进程 ID。根据右边输出的内容，你可以看到具体的内核函数和其父函数。中间显示了时间戳信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"># sudo cat trace | head -20</span><br><span class="line"></span><br><span class="line"># tracer: function</span><br><span class="line">#</span><br><span class="line"># entries-in-buffer/entries-written: 409936/4276216   #P:8</span><br><span class="line">#</span><br><span class="line">#                                _-----=&gt; irqs-off</span><br><span class="line">#                               / _----=&gt; need-resched</span><br><span class="line">#                              | / _---=&gt; hardirq/softirq</span><br><span class="line">#                              || / _--=&gt; preempt-depth</span><br><span class="line">#                              ||| /     delay</span><br><span class="line">#           TASK-PID     CPU#  ||||   TIMESTAMP  FUNCTION</span><br><span class="line">#              | |         |   ||||      |         |</span><br><span class="line">          &lt;idle&gt;-0       [000] d...  2088.841739: tsc_verify_tsc_adjust &lt;-arch_cpu_idle_enter</span><br><span class="line">          &lt;idle&gt;-0       [000] d...  2088.841739: local_touch_nmi &lt;-do_idle</span><br><span class="line">          &lt;idle&gt;-0       [000] d...  2088.841740: rcu_nocb_flush_deferred_wakeup &lt;-do_idle</span><br><span class="line">          &lt;idle&gt;-0       [000] d...  2088.841740: tick_check_broadcast_expired &lt;-do_idle</span><br><span class="line">          &lt;idle&gt;-0       [000] d...  2088.841740: cpuidle_get_cpu_driver &lt;-do_idle</span><br><span class="line">          &lt;idle&gt;-0       [000] d...  2088.841740: cpuidle_not_available &lt;-do_idle</span><br><span class="line">          &lt;idle&gt;-0       [000] d...  2088.841741: cpuidle_select &lt;-do_idle</span><br><span class="line">          &lt;idle&gt;-0       [000] d...  2088.841741: menu_select &lt;-do_idle</span><br><span class="line">          &lt;idle&gt;-0       [000] d...  2088.841741: cpuidle_governor_latency_req &lt;-menu_select</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>请记住当追踪打开后，这意味着追踪结果会被一直连续写入直至你关闭追踪。</p><h3 id="关闭追踪"><a href="#关闭追踪" class="headerlink" title="关闭追踪"></a>关闭追踪</h3><p>关闭追踪是简单的。你只需要在 <code>current_tracer</code> 文件中用 <code>nop</code> 替换 <code>function</code> 追踪器即可：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ sudo cat current_tracer</span><br><span class="line">function</span><br><span class="line"></span><br><span class="line">$ sudo echo nop &gt; current_tracer</span><br><span class="line"></span><br><span class="line">$ sudo cat current_tracer</span><br><span class="line">nop</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="启用-function-graph-追踪器"><a href="#启用-function-graph-追踪器" class="headerlink" title="启用 function_graph 追踪器"></a>启用 function_graph 追踪器</h3><p>现在尝试第二个名为 <code>function_graph</code> 的追踪器。你可以使用和上面相同的步骤：在 <code>current_tracer</code> 文件中写入 <code>function_graph</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ sudo echo function_graph &gt; current_tracer</span><br><span class="line"></span><br><span class="line">$ sudo cat current_tracer</span><br><span class="line">function_graph</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="function-tracer-追踪器的追踪输出"><a href="#function-tracer-追踪器的追踪输出" class="headerlink" title="function_tracer 追踪器的追踪输出"></a>function_tracer 追踪器的追踪输出</h3><p>注意到目前 <code>trace</code> 文件的输出格式已经发生变化。现在，你可以看到 CPU ID 和内核函数的执行时长。接下来，一个花括号表示一个函数的开始，以及它内部调用了哪些其他函数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"># cat trace | head -20</span><br><span class="line"></span><br><span class="line"># tracer: function_graph</span><br><span class="line">#</span><br><span class="line"># CPU  DURATION                  FUNCTION CALLS</span><br><span class="line"># |     |   |                     |   |   |   |</span><br><span class="line"> 6)               |              n_tty_write() &#123;</span><br><span class="line"> 6)               |                down_read() &#123;</span><br><span class="line"> 6)               |                  __cond_resched() &#123;</span><br><span class="line"> 6)   0.341 us    |                    rcu_all_qs();</span><br><span class="line"> 6)   1.057 us    |                  &#125;</span><br><span class="line"> 6)   1.807 us    |                &#125;</span><br><span class="line"> 6)   0.402 us    |                process_echoes();</span><br><span class="line"> 6)               |                add_wait_queue() &#123;</span><br><span class="line"> 6)   0.391 us    |                  _raw_spin_lock_irqsave();</span><br><span class="line"> 6)   0.359 us    |                  _raw_spin_unlock_irqrestore();</span><br><span class="line"> 6)   1.757 us    |                &#125;</span><br><span class="line"> 6)   0.350 us    |                tty_hung_up_p();</span><br><span class="line"> 6)               |                mutex_lock() &#123;</span><br><span class="line"> 6)               |                  __cond_resched() &#123;</span><br><span class="line"> 6)   0.404 us    |                    rcu_all_qs();</span><br><span class="line"> 6)   1.067 us    |                  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="启用追踪的设置来增加追踪的深度"><a href="#启用追踪的设置来增加追踪的深度" class="headerlink" title="启用追踪的设置来增加追踪的深度"></a>启用追踪的设置来增加追踪的深度</h3><p>你可以使用下面的步骤来调整追踪器以看到更深层次的函数调用。完成之后，你可以查看 <code>trace</code> 文件的内容并发现输出变得更加详细了。为了文章的可读性，这个例子的输出被省略了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># cat max_graph_depth</span><br><span class="line">0</span><br><span class="line"></span><br><span class="line"># echo 1 &gt; max_graph_depth ## or:</span><br><span class="line"># echo 2 &gt; max_graph_depth</span><br><span class="line"></span><br><span class="line"># sudo cat trace</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="查找要追踪的函数"><a href="#查找要追踪的函数" class="headerlink" title="查找要追踪的函数"></a>查找要追踪的函数</h3><p>上面的步骤足以让你开始追踪。但是它产生的输出内容是巨大的，当你想试图找到自己感兴趣的内容时，往往会很困难。通常你更希望能够只追踪特定的函数，而忽略其他函数。但如果你不知道它们确切的名称，你怎么知道要追踪哪些进程？有一个文件可以帮助你解决这个问题 —— <code>available_filter_functions</code> 文件提供了一个可供追踪的函数列表：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo wc -l available_filter_functions  </span><br><span class="line">63165 available_filter_functions</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="查找一般的内核函数"><a href="#查找一般的内核函数" class="headerlink" title="查找一般的内核函数"></a>查找一般的内核函数</h3><p>现在试着搜索一个你所知道的简单内核函数。用户空间由 <code>malloc</code> 函数用来分配内存，而内核由 <code>kmalloc</code> 函数，它提供类似的功能。下面是所有与 <code>kmalloc</code> 相关的函数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ sudo grep kmalloc available_filter_functions</span><br><span class="line">debug_kmalloc</span><br><span class="line">mempool_kmalloc</span><br><span class="line">kmalloc_slab</span><br><span class="line">kmalloc_order</span><br><span class="line">kmalloc_order_trace</span><br><span class="line">kmalloc_fix_flags</span><br><span class="line">kmalloc_large_node</span><br><span class="line">__kmalloc</span><br><span class="line">__kmalloc_track_caller</span><br><span class="line">__kmalloc_node</span><br><span class="line">__kmalloc_node_track_caller</span><br><span class="line">[...]</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="查找内核模块或者驱动相关函数"><a href="#查找内核模块或者驱动相关函数" class="headerlink" title="查找内核模块或者驱动相关函数"></a>查找内核模块或者驱动相关函数</h3><p>在 <code>available_filter_functions</code> 文件的输出中，你可以看到一些以括号内文字结尾的行，例如下面的例子中的 <code>[kvm_intel]</code>。这些函数与当前加载的内核模块 <code>kvm_intel</code> 有关。你可以运行 <code>lsmod</code> 命令来验证：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$ sudo grep kvm available_filter_functions | tail</span><br><span class="line">__pi_post_block [kvm_intel]</span><br><span class="line">vmx_vcpu_pi_load [kvm_intel]</span><br><span class="line">vmx_vcpu_pi_put [kvm_intel]</span><br><span class="line">pi_pre_block [kvm_intel]</span><br><span class="line">pi_post_block [kvm_intel]</span><br><span class="line">pi_wakeup_handler [kvm_intel]</span><br><span class="line">pi_has_pending_interrupt [kvm_intel]</span><br><span class="line">pi_update_irte [kvm_intel]</span><br><span class="line">vmx_dump_dtsel [kvm_intel]</span><br><span class="line">vmx_dump_sel [kvm_intel]</span><br><span class="line"></span><br><span class="line">$ lsmod  | grep -i kvm</span><br><span class="line">kvm_intel             335872  0</span><br><span class="line">kvm                   987136  1 kvm_intel</span><br><span class="line">irqbypass              16384  1 kvm</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="仅追踪特定的函数"><a href="#仅追踪特定的函数" class="headerlink" title="仅追踪特定的函数"></a>仅追踪特定的函数</h3><p>为了实现对特定函数或模式的追踪，你可以利用 <code>set_ftrace_filter</code> 文件来指定你要追踪上述输出中的哪些函数。这个文件也接受 <code>*</code> 模式，它可以扩展到包括具有给定模式的其他函数。作为一个例子，我在我的机器上使用 ext4 文件系统。我可以用下面的命令指定 ext4 的特定内核函数来追踪：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># mount | grep home</span><br><span class="line">/dev/mapper/fedora-home on /home type ext4 (rw,relatime,seclabel)</span><br><span class="line"></span><br><span class="line"># pwd</span><br><span class="line">/sys/kernel/tracing</span><br><span class="line"></span><br><span class="line"># cat set_ftrace_filter</span><br><span class="line"></span><br><span class="line">#### all functions enabled ####</span><br><span class="line">$</span><br><span class="line">$ echo ext4_* &gt; set_ftrace_filter</span><br><span class="line">$</span><br><span class="line">$ cat set_ftrace_filter</span><br><span class="line">ext4_has_free_clusters</span><br><span class="line">ext4_validate_block_bitmap</span><br><span class="line">ext4_get_group_number</span><br><span class="line">ext4_get_group_no_and_offset</span><br><span class="line">ext4_get_group_desc</span><br><span class="line">[...]</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>现在当你可以看到追踪输出时，你只能看到与内核函数有关的 <code>ext4</code> 函数，而你之前已经为其设置了一个过滤器。所有其他的输出都被忽略了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"># cat trace |head -20</span><br><span class="line"></span><br><span class="line">## tracer: function</span><br><span class="line">#</span><br><span class="line"># entries-in-buffer/entries-written: 3871/3871   #P:8</span><br><span class="line">#</span><br><span class="line">#                                _-----=&gt; irqs-off</span><br><span class="line">#                               / _----=&gt; need-resched</span><br><span class="line">#                              | / _---=&gt; hardirq/softirq</span><br><span class="line">#                              || / _--=&gt; preempt-depth</span><br><span class="line">#                              ||| /     delay</span><br><span class="line">#           TASK-PID     CPU#  ||||   TIMESTAMP  FUNCTION</span><br><span class="line">#              | |         |   ||||      |         |</span><br><span class="line">           cupsd-1066    [004] ....  3308.989545: ext4_file_getattr &lt;-vfs_fstat</span><br><span class="line">           cupsd-1066    [004] ....  3308.989547: ext4_getattr &lt;-ext4_file_getattr</span><br><span class="line">           cupsd-1066    [004] ....  3308.989552: ext4_file_getattr &lt;-vfs_fstat</span><br><span class="line">           cupsd-1066    [004] ....  3308.989553: ext4_getattr &lt;-ext4_file_getattr</span><br><span class="line">           cupsd-1066    [004] ....  3308.990097: ext4_file_open &lt;-do_dentry_open</span><br><span class="line">           cupsd-1066    [004] ....  3308.990111: ext4_file_getattr &lt;-vfs_fstat</span><br><span class="line">           cupsd-1066    [004] ....  3308.990111: ext4_getattr &lt;-ext4_file_getattr</span><br><span class="line">           cupsd-1066    [004] ....  3308.990122: ext4_llseek &lt;-ksys_lseek</span><br><span class="line">           cupsd-1066    [004] ....  3308.990130: ext4_file_read_iter &lt;-new_sync_read</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="排除要被追踪的函数"><a href="#排除要被追踪的函数" class="headerlink" title="排除要被追踪的函数"></a>排除要被追踪的函数</h3><p>你并不总是知道你想追踪什么，但是，你肯定知道你不想追踪什么。因此，有一个 <code>set_ftrace_notrace</code> —— 请注意其中的 “no”。你可以在这个文件中写下你想要的模式，并启用追踪。这样除了所提到的模式外，任何其他东西都会被追踪到。这通常有助于删除那些使我们的输出变得混乱的普通功能：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo cat set_ftrace_notrace</span><br><span class="line">#### no functions disabled ####</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="具有目标性的追踪"><a href="#具有目标性的追踪" class="headerlink" title="具有目标性的追踪"></a>具有目标性的追踪</h3><p>到目前为止，你一直在追踪内核中发生的一切。但是，它无法帮助你追踪与某个特定命令有关的事件。为了达到这个目的，你可以按需打开和关闭跟踪，并且在它们之间，运行我们选择的命令，这样你就不会在跟踪输出中得到额外的输出。你可以通过向 <code>tracing_on</code> 写入 <code>1</code> 来启用跟踪，写 <code>0</code> 来关闭跟踪。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># cat tracing_on</span><br><span class="line">0</span><br><span class="line"></span><br><span class="line"># echo 1 &gt; tracing_on</span><br><span class="line"></span><br><span class="line"># cat tracing_on</span><br><span class="line">1</span><br><span class="line"></span><br><span class="line">### Run some specific command that we wish to trace here ###</span><br><span class="line"></span><br><span class="line"># echo 0 &gt; tracing_on</span><br><span class="line"></span><br><span class="line"># cat tracing_on</span><br><span class="line">0</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="追踪特定的-PID"><a href="#追踪特定的-PID" class="headerlink" title="追踪特定的 PID"></a>追踪特定的 PID</h3><p>如果你想追踪与正在运行的特定进程有关的活动，你可以将该 PID 写入一个名为 <code>set_ftrace_pid</code> 的文件，然后启用追踪。这样一来，追踪就只限于这个 PID，这在某些情况下是非常有帮助的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo echo $PID &gt; set_ftrace_pid</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><code>ftrace</code> 是一个了解 Linux 内核内部工作的很好方式。通过一些练习，你可以学会对 <code>ftrace</code> 进行调整以缩小搜索范围。要想更详细地了解 <code>ftrace</code> 和它的高级用法，请看 <code>ftrace</code> 的核心作者 Steven Rostedt 写的这些优秀文章。</p><ul><li><a target="_blank" rel="noopener" href="https://lwn.net/Articles/365835/">调试 Linux 内核，第一部分</a></li><li><a target="_blank" rel="noopener" href="https://lwn.net/Articles/366796/">调试 Linux 内核，第二部分</a></li><li><a target="_blank" rel="noopener" href="https://lwn.net/Articles/370423/">调试 Linux 内核，第三部分</a></li></ul><hr><p>via: <a target="_blank" rel="noopener" href="https://opensource.com/article/21/7/linux-kernel-ftrace">https://opensource.com/article/21/7/linux-kernel-ftrace</a></p><p>作者：<a target="_blank" rel="noopener" href="https://opensource.com/users/gkamathe">Gaurav Kamathe</a> 选题：<a target="_blank" rel="noopener" href="https://github.com/lujun9972">lujun9972</a> 译者：<a target="_blank" rel="noopener" href="https://github.com/mengxinayan">萌新阿岩</a> 校对：<a target="_blank" rel="noopener" href="https://github.com/wxy">wxy</a></p><p>本文由 <a target="_blank" rel="noopener" href="https://github.com/LCTT/TranslateProject">LCTT</a> 原创编译，<a target="_blank" rel="noopener" href="https://linux.cn/">Linux中国</a> 荣誉推出</p></div></div></div><div class="footer"><p class="footer-copyright"><span>Powered by <a target="_blank" href="https://hexo.io">Hexo</a></span> <span>Theme <a target="_blank" href="https://github.com/tinkink-co/hexo-theme-terminal">Terminal</a></span><script type="text/javascript" src="https://cdn.staticfile.net/jquery/3.4.1/jquery.min.js"></script><script>getCDNinfo=function(){$.ajax({url:"/cdn-cgi/trace",success:function(a,n){let i="Antananarivo, Madagascar - (TNR);Cape Town, South Africa - (CPT);Casablanca, Morocco - (CMN);Dar Es Salaam, Tanzania - (DAR);Djibouti City, Djibouti - (JIB);Durban, South Africa - (DUR);Johannesburg, South Africa - (JNB);Kigali, Rwanda - (KGL);Lagos, Nigeria - (LOS);Luanda, Angola - (LAD);Maputo, MZ - (MPM);Mombasa, Kenya - (MBA);Port Louis, Mauritius - (MRU);Réunion, France - (RUN);Bangalore, India - (BLR);Bangkok, Thailand - (BKK);Bandar Seri Begawan, Brunei - (BWN);Cebu, Philippines - (CEB);Chengdu, China - (CTU);Chennai, India - (MAA);Chittagong, Bangladesh - (CGP);Chongqing, China - (CKG);Colombo, Sri Lanka - (CMB);Dhaka, Bangladesh - (DAC);Dongguan, China - (SZX);Foshan, China - (FUO);Fuzhou, China - (FOC);Guangzhou, China - (CAN);Hangzhou, China - (HGH);Hanoi, Vietnam - (HAN);Hengyang, China - (HNY);Ho Chi Minh City, Vietnam - (SGN);Hong Kong - (HKG);Hyderabad, India - (HYD);Islamabad, Pakistan - (ISB);Jakarta, Indonesia - (CGK);Jinan, China - (TNA);Karachi, Pakistan - (KHI);Kathmandu, Nepal - (KTM);Kolkata, India - (CCU);Kuala Lumpur, Malaysia - (KUL);Lahore, Pakistan - (LHE);Langfang, China - (NAY);Luoyang, China - (LYA);Macau - (MFM);Malé, Maldives - (MLE);Manila, Philippines - (MNL);Mumbai, India - (BOM);Nagpur, India - (NAG);Nanning, China - (NNG);New Delhi, India - (DEL);Osaka, Japan - (KIX);Phnom Penh, Cambodia - (PNH);Qingdao, China - (TAO);Seoul, South Korea - (ICN);Shanghai, China - (SHA);Shenyang, China - (SHE);Shijiazhuang, China - (SJW);Singapore, Singapore - (SIN);Suzhou, China - (SZV);Taipei - (TPE);Thimphu, Bhutan - (PBH);Tianjin, China - (TSN);Tokyo, Japan - (NRT);Ulaanbaatar, Mongolia - (ULN);Vientiane, Laos - (VTE);Wuhan, China - (WUH);Wuxi, China - (WUX);Xi'an, China - (XIY);Yerevan, Armenia - (EVN);Zhengzhou, China - (CGO);Zuzhou, China - (CSX);Amsterdam, Netherlands - (AMS);Athens, Greece - (ATH);Barcelona, Spain - (BCN);Belgrade, Serbia - (BEG);Berlin, Germany - (TXL);Brussels, Belgium - (BRU);Bucharest, Romania - (OTP);Budapest, Hungary - (BUD);Chișinău, Moldova - (KIV);Copenhagen, Denmark - (CPH);Cork, Ireland -  (ORK);Dublin, Ireland - (DUB);Düsseldorf, Germany - (DUS);Edinburgh, United Kingdom - (EDI);Frankfurt, Germany - (FRA);Geneva, Switzerland - (GVA);Gothenburg, Sweden - (GOT);Hamburg, Germany - (HAM);Helsinki, Finland - (HEL);Istanbul, Turkey - (IST);Kyiv, Ukraine - (KBP);Lisbon, Portugal - (LIS);London, United Kingdom - (LHR);Luxembourg City, Luxembourg - (LUX);Madrid, Spain - (MAD);Manchester, United Kingdom - (MAN);Marseille, France - (MRS);Milan, Italy - (MXP);Moscow, Russia - (DME);Munich, Germany - (MUC);Nicosia, Cyprus - (LCA);Oslo, Norway - (OSL);Paris, France - (CDG);Prague, Czech Republic - (PRG);Reykjavík, Iceland - (KEF);Riga, Latvia - (RIX);Rome, Italy - (FCO);Saint Petersburg, Russia - (LED);Sofia, Bulgaria - (SOF);Stockholm, Sweden - (ARN);Tallinn, Estonia - (TLL);Thessaloniki, Greece - (SKG);Vienna, Austria - (VIE);Vilnius, Lithuania - (VNO);Warsaw, Poland - (WAW);Zagreb, Croatia - (ZAG);Zürich, Switzerland - (ZRH);Arica, Chile - (ARI);Asunción, Paraguay - (ASU);Bogotá, Colombia - (BOG);Buenos Aires, Argentina - (EZE);Curitiba, Brazil - (CWB);Fortaleza, Brazil - (FOR);Guatemala City, Guatemala - (GUA);Lima, Peru - (LIM);Medellín, Colombia - (MDE);Panama City, Panama - (PTY);Porto Alegre, Brazil - (POA);Quito, Ecuador - (UIO);Rio de Janeiro, Brazil - (GIG);São Paulo, Brazil - (GRU);Santiago, Chile - (SCL);Willemstad, Curaçao - (CUR);St. George's, Grenada - (GND);Amman, Jordan - (AMM);Baghdad, Iraq - (BGW);Baku, Azerbaijan - (GYD);Beirut, Lebanon - (BEY);Doha, Qatar - (DOH);Dubai, United Arab Emirates - (DXB);Kuwait City, Kuwait - (KWI);Manama, Bahrain - (BAH);Muscat, Oman - (MCT);Ramallah - (ZDM);Riyadh, Saudi Arabia - (RUH);Tel Aviv, Israel - (TLV);Ashburn, VA, United States - (IAD);Atlanta, GA, United States - (ATL);Boston, MA, United States - (BOS);Buffalo, NY, United States - (BUF);Calgary, AB, Canada - (YYC);Charlotte, NC, United States - (CLT);Chicago, IL, United States - (ORD);Columbus, OH, United States - (CMH);Dallas, TX, United States - (DFW);Denver, CO, United States - (DEN);Detroit, MI, United States - (DTW);Honolulu, HI, United States - (HNL);Houston, TX, United States - (IAH);Indianapolis, IN, United States - (IND);Jacksonville, FL, United States - (JAX);Kansas City, MO, United States - (MCI);Las Vegas, NV, United States - (LAS);Los Angeles, CA, United States - (LAX);McAllen, TX, United States - (MFE);Memphis, TN, United States - (MEM);Mexico City, Mexico - (MEX);Miami, FL, United States - (MIA);Minneapolis, MN, United States - (MSP);Montgomery, AL, United States - (MGM);Montréal, QC, Canada - (YUL);Nashville, TN, United States - (BNA);Newark, NJ, United States - (EWR);Norfolk, VA, United States - (ORF);Omaha, NE, United States - (OMA);Philadelphia, United States - (PHL);Phoenix, AZ, United States - (PHX);Pittsburgh, PA, United States - (PIT);Port-Au-Prince, Haiti - (PAP);Portland, OR, United States - (PDX);Queretaro, MX, Mexico - (QRO);Richmond, Virginia - (RIC);Sacramento, CA, United States - (SMF);Salt Lake City, UT, United States - (SLC);San Diego, CA, United States - (SAN);San Jose, CA, United States - (SJC);Saskatoon, SK, Canada - (YXE);Seattle, WA, United States - (SEA);St. Louis, MO, United States - (STL);Tampa, FL, United States - (TPA);Toronto, ON, Canada - (YYZ);Vancouver, BC, Canada - (YVR);Tallahassee, FL, United States - (TLH);Winnipeg, MB, Canada - (YWG);Adelaide, SA, Australia - (ADL);Auckland, New Zealand - (AKL);Brisbane, QLD, Australia - (BNE);Melbourne, VIC, Australia - (MEL);Noumea, New caledonia - (NOU);Perth, WA, Australia - (PER);Sydney, NSW, Australia - (SYD)".split(";"),e=a.split("colo=")[1].split("\n")[0],t=(a.split("colo=")[1].split("\n")[0],a.split("tls=")[1].split("\n")[0]),o=a.split("http=")[1].split("\n")[0],s=a.split("sni=")[1].split("\n")[0],r=a.split("ip=")[1].split("\n")[0],l=a.split("uag=")[1].split("\n")[0];for(var d=0;d<i.length;d++)if(-1!=i[d].indexOf(e)){document.getElementById("cdn").innerHTML=i[d];break}document.getElementById("tls").innerHTML=t,document.getElementById("http").innerHTML=o,document.getElementById("sni").innerHTML=s,document.getElementById("ip").innerHTML=r,document.getElementById("useragent").innerHTML=l}})},$(document).ready((function(){getCDNinfo()}))</script></p><p style="text-align:center">感谢陪伴与布道，开源之火不灭。​</p><p style="text-align:center"><script>document.write("本次加载耗时: "+(performance.getEntriesByType("navigation").reduce((e,r)=>e+r.responseEnd-r.startTime,0)+performance.getEntriesByType("resource").reduce((e,r)=>e+r.responseEnd-r.startTime,0)).toFixed(0)+"ms")</script></p><p style="text-align:center">当前 SNI 状态： <span id="sni">正在统计！或可能被浏览器防追踪拦截！</span></p><p style="text-align:center">当前 TLS 版本： <span id="tls">正在统计！或可能被浏览器防追踪拦截！</span></p><p style="text-align:center">当前 HTTP 版本： <span id="http">正在统计！或可能被浏览器防追踪拦截！</span></p><p style="text-align:center">当前您的客户端 IP 是： <span id="ip">正在统计！或可能被浏览器防追踪拦截！</span></p><p style="text-align:center">当前分配的 CDN 节点是: <span id="cdn">正在统计！或可能被浏览器防追踪拦截！</span></p><p style="text-align:center">您的 UserAgent 信息是: <span id="useragent">正在统计！或可能被浏览器防追踪拦截！</span></p><p></p><script defer src="https://pv.undefined.today/tracker.min.js" data-website-id="LinuxCNMirror-tracker"></script></div></div></body></html>