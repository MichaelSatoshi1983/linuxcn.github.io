<!doctype html><html lang="en"><head><meta name="msvalidate.01" content="D404690CEFCB54C7762AC84935B99171"><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?6618da70c90c8744eead2e9371fb5077";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><script type="text/javascript">!function(t,e,n,c,s,a,r){t[n]=t[n]||function(){(t[n].q=t[n].q||[]).push(arguments)},(a=e.createElement(c)).async=1,a.src="https://www.clarity.ms/tag/s5f3f0tojf",(r=e.getElementsByTagName(c)[0]).parentNode.insertBefore(a,r)}(window,document,"clarity","script")</script><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta http-equiv="X-UA-Compatible" content="ie=edge"><link rel="stylesheet" href="/styles/base.css"><link rel="stylesheet" href="/styles/theme.css"><link rel="shortcut icon" href="/favicon.png"><title>Btrfs 详解：快照 - 归墟星火集</title><meta name="generator" content="Hexo 7.3.0"></head><body><div class="header-title"><span class="header-light"></span> <span class="header-light"></span> <span class="header-light"></span> <span>归墟星火集 linuxcn.undefined.today<span></span></span></div><div class="container"><ul class="nav"><li><a href="/">首页</a></li><li><a href="/about/">关于</a></li><li><a target="_blank" rel="noopener" href="https://undefined.today/">Blog</a></li></ul><div class="content"><div class="post-container"><div class="post-header"><span class="ui-tips">标题：</span><h1 class="ui-keyword post-title">Btrfs 详解：快照</h1><span class="post-date">2023-10-16</span></div><div class="post-header"><span class="ui-tips">分类：</span> <a href="/categories/%E6%8A%80%E6%9C%AF/">技术</a></div><div class="post-header"><span class="ui-tips">标签：</span> <a href="/tags/Btrfs/">Btrfs</a></div><div class="post-content"><p><img src="https://linuxcn.img.undefined.today/data/attachment/album/202310/16/092244yog42vb0l3v5h33h.jpg"></p><p>这篇文章会探讨什么是 Btrfs 快照，它们如何工作的，你在日常生活中进行快照的好处。这篇文章是《Btrfs 详解》系列文章中的一篇。从 Fedora Linux 33 开始，Btrfs 就是 Fedora Workstation 和 Fedora Silverblue 的默认文件系统。</p><p>如果你错过了，这里是本系列的上一篇文章：<a href="/article-16250-1.html">Btrfs 详解：子卷</a></p><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>想象一下，你长时间处理一个文件，反复添加和撤销修改。然后，在某个时刻你意识到：两小时前你撤销的部分修改，现在会非常有用。而昨天在你销毁那个设计之前，你也已经修改了这个特殊的部分。当然，由于你会定期保存文件，所以旧的改动会丢失。很多人可能都遇到过这样的情况。如果能恢复旧版本的文件，而无需定期手动复制，岂不美哉？</p><p>这是一个 Btrfs 快照可以帮助你的特别场景。当你使用正确的话，快照同时也为你的电脑提供了很好的备份方案。</p><p>下面你会找到一些关于快照的例子。如果你想跟着操作，你必须拥有访问某些 Btrfs 文件系统的权限和 root 权限。你可以通过下面命令来验证一个目录的文件系统。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ findmnt -no FSTYPE /home</span><br><span class="line">btrfs</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这个命令会输出你 <code>/home/</code> 目录的文件系统名称。如果它是 <code>btrfs</code>，那就可以了。让我们创建一个新的目录去做实验：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir ~/btrfs-snapshot-test</span><br><span class="line">$ cd ~/btrfs-snapshot-test</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在下面的文本中，你会看到很多像上面显示的那样的命令输出框。请在阅读&#x2F;比较命令输出时请记住，<strong>框中的内容在行末会被换行</strong>。这使得识别跨多行的长行变得困难，降低了可读性。如果有疑问，试着调整浏览器窗口的大小，看看文本的变化！</p><h3 id="Btrfs-快照"><a href="#Btrfs-快照" class="headerlink" title="Btrfs 快照"></a>Btrfs 快照</h3><p>让我们从一个基本的问题开始：什么是 Btrfs 快照？如果你在文档 <sup class="footnote-ref"><a href="#fn1" id="fnref1">[1] </a></sup>和维基 <sup class="footnote-ref"><a href="#fn2" id="fnref2">[2] </a></sup>中查找，你不会立刻找到这个问题的答案。事实上，从“功能”一节里是找不到的。如果你搜索一下，你会发现快照和 Btrfs 子卷一起被大量地提及 <sup class="footnote-ref"><a href="#fn3" id="fnref3">[3] </a></sup>。所以现在做什么呢？</p><p>还记得快照在系列前面的文章里两次被提到吗？是这样说的：</p><blockquote><p>CoW 的优势在哪里？简单的说：文件被修改和编辑的历史被保存了下来。Btrfs 保存文件旧版本的引用（inode）可以轻易地被访问。这个引用就是快照：文件系统在某个时间点的状态镜像。这将是这系列文章里的单独的一篇，所以暂时留到后面介绍。</p><p>—— <a href="/article-16189-1.html">Btrfs 详解：基础概念</a></p></blockquote><p>以及：</p><blockquote><p>另外一个分离 <code>/</code> 和 <code>/home</code> 的优势是我们可以分别进行 <em>快照</em> 。子卷是快照的边界，对一个子卷的快照永远不会包含该子卷下面的其他子卷的内容。快照的更多细节会在后续的文章中介绍。</p><p>—— <a href="/article-16250-1.html">Btrfs 详解：子卷</a></p></blockquote><p>看起来快照是和 Btrfs 子卷相关的。你可能之前在其他地方听到过快照，比如说 LVM（逻辑卷管理器）。虽然技术角度上它们都是为了同一个目的，但它们在实现方面有所不同。</p><p>每个 Btrfs 快照是一个子卷。但是，不是每个子卷都是一份快照。区别在于子卷里面包含的内容。一个快照是子卷加上一些内容：它包含对现在和过去版本的文件的引用（inode）。让我们看看快照是从哪来的！</p><h3 id="创建-Btrfs-快照"><a href="#创建-Btrfs-快照" class="headerlink" title="创建 Btrfs 快照"></a>创建 Btrfs 快照</h3><p>想使用快照功能，你需要一个 Btrfs 子卷来进行快照。让我们在测试目录（<code>~/btrfs-snapshot-test</code>）里创建一个：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ cd ~/btrfs-snapshot-test</span><br><span class="line">$ sudo btrfs subvolume create demo</span><br><span class="line">Create subvolume &#x27;./demo&#x27;</span><br><span class="line">$ sudo chown -R $(id -u):$(id -g) demo/</span><br><span class="line">$ cd demo</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>因为 Btrfs 子卷默认是被 root 所有的，你必须用 <code>chown</code> 去修改子卷里的文件的所有权到普通用户上。现在我们在里面新加一些文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ touch foo bar baz</span><br><span class="line">$ echo &quot;Lorem ipsum dolor sit amet, &quot; &gt; foo</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>你的目录现在看起来像这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ ls -l</span><br><span class="line">total 4</span><br><span class="line">-rw-r--r--. 1 hartan hartan  0 Dec 20 08:11 bar</span><br><span class="line">-rw-r--r--. 1 hartan hartan  0 Dec 20 08:11 baz</span><br><span class="line">-rw-r--r--. 1 hartan hartan 29 Dec 20 08:11 foo</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>让我们从这里创建第一次快照：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ cd ..</span><br><span class="line">$ sudo btrfs subvolume snapshot demo demo-1</span><br><span class="line">Create a snapshot of &#x27;demo&#x27; in &#x27;./demo-1&#x27;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这就好了。让我们看看发生了什么：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$ ls -l</span><br><span class="line">total 0</span><br><span class="line">drwxr-xr-x. 1 hartan hartan 18 Dec 20 08:11 demo</span><br><span class="line">drwxr-xr-x. 1 hartan hartan 18 Dec 20 08:11 demo-1</span><br><span class="line">$ tree</span><br><span class="line">.</span><br><span class="line">├── demo</span><br><span class="line">│   ├── bar</span><br><span class="line">│   ├── baz</span><br><span class="line">│   └── foo</span><br><span class="line">└── demo-1</span><br><span class="line">    ├── bar</span><br><span class="line">    ├── baz</span><br><span class="line">    └── foo</span><br><span class="line"></span><br><span class="line">2 directories, 6 files</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这看起来是一份拷贝！为了验证，我们从快照里读取 <code>foo</code> 的内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ cat demo/foo</span><br><span class="line">Lorem ipsum dolor sit amet,</span><br><span class="line">$ cat demo-1/foo</span><br><span class="line">Lorem ipsum dolor sit amet,</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>当我们修改原始文件时，真正的效果变得明显：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ echo &quot;consectetur adipiscing elit, &quot; &gt;&gt; demo/foo</span><br><span class="line">$ cat demo/foo</span><br><span class="line">Lorem ipsum dolor sit amet,</span><br><span class="line">consectetur adipiscing elit,</span><br><span class="line">$ cat demo-1/foo</span><br><span class="line">Lorem ipsum dolor sit amet,</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这表明快照仍然持有“旧”版本的数据：<code>foo</code> 的内容没有改变。到目前为止，你可以通过一个简单的文件复制来实现完全相同的目标。现在你也可以继续处理旧文件了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ echo &quot;sed do eiusmod tempor incididunt&quot; &gt;&gt; demo-1/foo</span><br><span class="line">$ cat demo-1/foo</span><br><span class="line">Lorem ipsum dolor sit amet,</span><br><span class="line">sed do eiusmod tempor incididunt</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>但是在底层，我们的快照实际上是一个新的 Btrfs 子卷。你可以通过下面的命令来验证这一点：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ sudo btrfs subvolume list -o .</span><br><span class="line">ID 259 gen 265 top level 256 path home/hartan/btrfs-snapshot-test/demo</span><br><span class="line">ID 260 gen 264 top level 256 path home/hartan/btrfs-snapshot-test/demo-1</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Btrfs-子卷-vs-文件复制"><a href="#Btrfs-子卷-vs-文件复制" class="headerlink" title="Btrfs 子卷 vs. 文件复制"></a>Btrfs 子卷 vs. 文件复制</h3><p>这一切有什么意义呢？到目前为止快照看起来是一个更加复杂的复制文件的方式。事实上，快照不仅仅是表面上看起来那么简单。让我们来创建一个更大的文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ dd if=/dev/urandom of=demo/bigfile bs=1M count=512</span><br><span class="line">512+0 records in</span><br><span class="line">512+0 records out</span><br><span class="line">536870912 bytes (537 MB, 512 MiB) copied, 1.3454 s, 399 MB/s</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>现在有一个512 MB 大小的新文件 <code>demo/bigfile</code> 。让我们创建另一个快照，这样在你修改数据的时候就不会丢失：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo btrfs subvolume snapshot demo demo-2</span><br><span class="line">Create a snapshot of &#x27;demo&#x27; in &#x27;./demo-2&#x27;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>现在我们通过追加少量字符串到文件来模拟变化：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ echo &quot;small changes&quot; &gt;&gt; demo/bigfile</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这是生效后的文件结构：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">$ tree</span><br><span class="line">.</span><br><span class="line">├── demo</span><br><span class="line">│   ├── bar</span><br><span class="line">│   ├── baz</span><br><span class="line">│   ├── bigfile</span><br><span class="line">│   └── foo</span><br><span class="line">├── demo-1</span><br><span class="line">│   ├── bar</span><br><span class="line">│   ├── baz</span><br><span class="line">│   └── foo</span><br><span class="line">└── demo-2</span><br><span class="line">    ├── bar</span><br><span class="line">    ├── baz</span><br><span class="line">    ├── bigfile</span><br><span class="line">    └── foo</span><br><span class="line"></span><br><span class="line">3 directories, 11 files</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>但是真正的神奇的发生在其他地方。你已经复制了 <code>demo/bigfile</code> ，你现在拥有了两个大约 512 MiB 的文件。但是，因为它们是不同的拷贝，它们应该会占据共 1 GiB 的空间。记住两个文件的差异不超过 10 字节 —— 和原文件大小相比这几乎没什么差别。</p><p>Btrfs 快照工作原理与文件复制不同：而是它们保持对当前和过去的 inode 的引用。当你在文件追加更新时，在底层 Btrfs 分配更多的空间去存储更新，同时在原来的 inode 增加对新数据的引用。之前的内容保持不变。为了便于理解，你可以认为这是仅仅“存储”原文件和修改版本的差异。</p><p>让我们看看这个效果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ sudo compsize .</span><br><span class="line">Processed 11 files, 5 regular extents (9 refs), 3 inline.</span><br><span class="line">Type       Perc     Disk Usage   Uncompressed Referenced</span><br><span class="line">TOTAL      100%      512M         512M         1.0G</span><br><span class="line">none       100%      512M         512M         1.0G</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这个有趣的数字出现在 <code>TOTAL</code> 一行：</p><ul><li><code>Referenced</code> 是当前目录下所有文件大小的总和</li><li><code>Disk Usage</code> 是用于在磁盘上存储文件分配空间的大小</li></ul><p>你有一共 1 GiB 的文件，但存储它们仅仅占据了 512 MiB。</p><h3 id="Btrfs-快照和备份"><a href="#Btrfs-快照和备份" class="headerlink" title="Btrfs 快照和备份"></a>Btrfs 快照和备份</h3><p>目前为止，在这篇文章中，你已经看到如何创建 Btrfs 快照和它们的特别之处。有人可能会想：如果我在我的 PC 本地进行一系列的快照，我就有一个可靠的备份策略。 <strong>其实不是这样的</strong> 。如果 Btrfs 子卷共享的底层数据被偶然破坏了（被 Btrfs 之外的东西影响，比如宇宙射线），所有指向这些数据的子卷都会存在相同的错误。</p><p>为了让快照成为真正的备份，你应该将它们存储到一个不同的 Btrfs 系统上，例如在一个外部驱动器上。为了本文的目的，让我们在一个文件里创建一个新的 Btrfs 系统，并挂载它来模拟一个外部驱动。如果你有一个格式为 Btrfs 的外部驱动器，请随意替换以下命令中提到的所有路径来试试！让我们创建一个新的 Btrfs 文件系统：</p><p><strong>注意</strong>：下面的命令会在你的文件系统上创建一个 8 GB 大小的新文件。如果你想跟着下面的步骤，请确保你的磁盘空间至少有 8 GB 剩余。请不要分配小于 8 GB 到这个文件，否则 Btrfs 可能在挂载时会遇到问题。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ truncate -s 8G btrfs_filesystem.img</span><br><span class="line">$ sudo mkfs.btrfs -L &quot;backup-drive&quot; btrfs_filesystem.img</span><br><span class="line">btrfs-progs v5.18</span><br><span class="line">See http://btrfs.wiki.kernel.org for more information.</span><br><span class="line"></span><br><span class="line">[ ... ]</span><br><span class="line"></span><br><span class="line">Devices:</span><br><span class="line">    ID        SIZE  PATH</span><br><span class="line">    1     8.00GiB  btrfs_filesystem.img</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这些命令创建了名为 <code>btrfs_filesystem.img</code> 的 8 GB 新文件，同时在上面格式化了一个 Btrfs 文件系统。现在你可以像外部驱动器一样挂载它：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir backup-drive</span><br><span class="line">$ sudo mount btrfs_filesystem.img backup-drive</span><br><span class="line">$ sudo chown -R $(id -u):$(id -g) backup-drive</span><br><span class="line">$ ls -lh</span><br><span class="line">total 4.7M</span><br><span class="line">drwxr-xr-x. 1 hartan hartan    0 Dec 20 08:35 backup-drive</span><br><span class="line">-rw-r--r--. 1 hartan hartan 8.0G Dec 20 08:37 btrfs_filesystem.img</span><br><span class="line">drwxr-xr-x. 1 hartan hartan   32 Dec 20 08:14 demo</span><br><span class="line">drwxr-xr-x. 1 hartan hartan   18 Dec 20 08:11 demo-1</span><br><span class="line">drwxr-xr-x. 1 hartan hartan   32 Dec 20 08:14 demo-2</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>妙，现在挂载在 <code>backup-drive</code> 下面有一个独立的 Btrfs 文件系统！让我们尝试进行快照并且把快照放进去：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ sudo btrfs subvolume snapshot demo backup-drive/demo-3</span><br><span class="line">Create a snapshot of &#x27;demo&#x27; in &#x27;backup-drive/demo-3&#x27;</span><br><span class="line">ERROR: cannot snapshot &#x27;demo&#x27;: Invalid cross-device link</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>发生了什么？噢，你尝试对 <code>demo</code> 进行一次快照并把它存在不同的 Btrfs 文件系统里（从 Btrfs 视角来看是一个不同的设备）。还记得一个 Btrfs 子卷仅持有对文件和内容的引用（inode）？这正是问题所在：文件和内容存在于我们的 <code>home</code> 文件系统，但不在新创建的 <code>backup-drive</code> 。你得找到一种方式去传输子卷和其内容到新的文件系统里。</p><h4 id="在不同的-Btrfs-文件系统存储快照"><a href="#在不同的-Btrfs-文件系统存储快照" class="headerlink" title="在不同的 Btrfs 文件系统存储快照"></a>在不同的 Btrfs 文件系统存储快照</h4><p>针对这个目的 Btrfs 工具有两个特殊的命令。让我们首先来看看它们是如何工作的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ sudo btrfs send demo | sudo btrfs receive backup-drive/</span><br><span class="line">ERROR: subvolume /home/hartan/btrfs-snapshot-test/demo is not read-only</span><br><span class="line">ERROR: empty stream is not considered valid</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>另一个错误！这时它告诉你我们想要传输的子卷不是只读的。这是对的：你可以写入新内容到所有目前为止创建的快照&#x2F;子卷。你可以像这样创建一个只读的快照：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo btrfs subvolume snapshot -r demo demo-3-ro</span><br><span class="line">Create a readonly snapshot of &#x27;demo&#x27; in &#x27;./demo-3-ro&#x27;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>不像之前那样，这里 <code>-r</code> 选项被加到了 <code>snapshot</code> 子命令里。这创建一个只读的快照，这很容易去验证：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ touch demo-3-ro/another-file</span><br><span class="line">touch: cannot touch &#x27;demo-3-ro/another-file&#x27;: Read-only file system</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>现在你可以重新尝试传输子卷：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">$ sudo btrfs send demo-3-ro | sudo btrfs receive backup-drive/</span><br><span class="line">At subvol demo-3-ro</span><br><span class="line">At subvol demo-3-ro</span><br><span class="line">$ tree</span><br><span class="line"></span><br><span class="line">├── backup-drive</span><br><span class="line">│   └── demo-3-ro</span><br><span class="line">│       ├── bar</span><br><span class="line">│       ├── baz</span><br><span class="line">│       ├── bigfile</span><br><span class="line">│       └── foo</span><br><span class="line">├── btrfs_filesystem.img</span><br><span class="line">├── demo</span><br><span class="line">[ ... ]</span><br><span class="line">└── demo-3-ro</span><br><span class="line">    ├── bar</span><br><span class="line">    ├── baz</span><br><span class="line">    ├── bigfile</span><br><span class="line">    └── foo</span><br><span class="line"></span><br><span class="line">6 directories, 20 files</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>成功了！你成功传输原来子卷 <code>demo</code> 的一个只读快照到一个外部的 Btrfs 文件系统。</p><h4 id="在非-Btrfs-文件系统存储快照"><a href="#在非-Btrfs-文件系统存储快照" class="headerlink" title="在非 Btrfs 文件系统存储快照"></a>在非 Btrfs 文件系统存储快照</h4><p>上面你已经看到你如何能存储 Btrfs 子卷&#x2F;快照到其他的 Btrfs 文件系统。但如果你没有其他的 Btrfs 文件系统并且不能新创建一个，比如说外部驱动器需要一个和 Windows 或 MacOS 兼容的文件系统，你可以做什么呢？在这种情况下你可以存储子卷在文件里：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ sudo btrfs send -f demo-3-ro-subvolume.btrfs demo-3-ro</span><br><span class="line">At subvol demo-3-ro</span><br><span class="line">$ ls -lh demo-3-ro-subvolume.btrfs</span><br><span class="line">-rw-------. 1 root root 513M Dec 21 10:39 demo-3-ro-subvolume.btrfs</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>文件 <code>demo-3-ro-subvolume.btrfs</code> 现在包含了随后重建 <code>demo-3-ro</code> 子卷需要的所有东西。</p><h4 id="增量地发送快照"><a href="#增量地发送快照" class="headerlink" title="增量地发送快照"></a>增量地发送快照</h4><p>如果你对不同的子卷重复执行这个操作，你会发现在某些时间点不同的子卷不再共享它们的文件内容。这是因为像上面一样发送一个子卷，去重建这个单独的子卷的所有数据将被传送到目标位置。但是，你可以引导 Btrfs 只向目标位置发送不同子卷的差异！所谓的增量发送将保证共享的引用在子卷中仍然共享。为了展示这一点，新增一些变动到我们原来的子卷：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ echo &quot;a few more changes&quot; &gt;&gt; demo/bigfile</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后创建另一个只读子卷：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo btrfs subvolume snapshot -r demo demo-4-ro</span><br><span class="line">Create a readonly snapshot of &#x27;demo&#x27; in &#x27;./demo-4-ro&#x27;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后现在发送它：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ sudo btrfs send -p demo-3-ro demo-4-ro | sudo btrfs receive backup-drive</span><br><span class="line">At subvol demo-4-ro</span><br><span class="line">At snapshot demo-4-ro</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在上面的命令，<code>-p</code> 选项指定了一个父子卷用来计算差异。重要的是记住原 Btrfs 文件系统和目标 Btrfs 文件系统都必须包含相同的、未被修改过的父子卷！确保新的子卷真的在那里：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ ls backup-drive/</span><br><span class="line">demo-3-ro  demo-4-ro</span><br><span class="line">$ ls -lR backup-drive/demo-4-ro/</span><br><span class="line">backup-drive/demo-4-ro/:</span><br><span class="line">total 524296</span><br><span class="line">-rw-r--r--. 1 hartan hartan         0 Dec 20 08:11 bar</span><br><span class="line">-rw-r--r--. 1 hartan hartan         0 Dec 20 08:11 baz</span><br><span class="line">-rw-r--r--. 1 hartan hartan 536870945 Dec 21 10:49 bigfile</span><br><span class="line">-rw-r--r--. 1 hartan hartan        59 Dec 20 08:13 foo</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>但你怎样知道增量发送只传输了子卷间的差异呢？让我们传输数据流到一个文件里然后看看它有多大：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ sudo btrfs send -f demo-4-ro-diff.btrfs -p demo-3-ro demo-4-ro</span><br><span class="line">At subvol demo-4-ro</span><br><span class="line">$ ls -l demo-4-ro-diff.btrfs</span><br><span class="line">-rw-------. 1 root root 315 Dec 21 10:55 demo-4-ro-diff.btrfs</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>根据 <code>ls</code> ，这个文件仅仅只有 315 字节大小！这意味着增量传输只传输子卷间的差异，和额外的 Btrfs 相关的元数据。</p><h4 id="从快照中恢复子卷"><a href="#从快照中恢复子卷" class="headerlink" title="从快照中恢复子卷"></a>从快照中恢复子卷</h4><p>在继续之前，让我们清理掉这时候不再需要的东西：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ sudo rm -rf demo-4-ro-diff.btrfs demo-3-ro-subvolume.btrfs</span><br><span class="line">$ sudo btrfs subvolume delete demo-1 demo-2 demo-3-ro demo-4-ro</span><br><span class="line">$ ls -l</span><br><span class="line">total 531516</span><br><span class="line">drwxr-xr-x. 1 hartan hartan         36 Dec 21 10:50 backup-drive</span><br><span class="line">-rw-r--r--. 1 hartan hartan 8589934592 Dec 21 10:51 btrfs_filesystem.img</span><br><span class="line">drwxr-xr-x. 1 hartan hartan         32 Dec 20 08:14 demo</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>到目前为止你已经成功创建了可读&#x2F;写和只读的 Btrfs 子卷快照，并把它们发送到外部。但是，为了把这作为备份策略，还要有一种方式去发送子卷回原来的文件系统和让它们再次变为可写。出于这个目的，我们移动 <code>demo</code> 子卷到其他地方并且尝试从最近的快照中重建它。第一步：重命名为 <code>broken</code> 子卷。一旦恢复成功它会被删除：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ mv demo demo-broken</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>第二步: 传回最近的快照到这个文件系统：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ sudo btrfs send backup-drive/demo-4-ro | sudo btrfs receive .</span><br><span class="line">At subvol backup-drive/demo-4-ro</span><br><span class="line">At subvol demo-4-ro</span><br><span class="line">[hartan@fedora btrfs-snapshot-test]$ ls</span><br><span class="line">backup-drive  btrfs_filesystem.img  demo-4-ro  demo-broken</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>第三步: 从快照创建一个可读写的子卷：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ sudo btrfs subvolume snapshot demo-4-ro demo</span><br><span class="line">Create a snapshot of &#x27;demo-4-ro&#x27; in &#x27;./demo&#x27;</span><br><span class="line">$ ls</span><br><span class="line">backup-drive  btrfs_filesystem.img  demo  demo-4-ro  demo-broken</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上一步非常重要：你不能重命名 <code>demo-4-ro</code> 为 <code>demo</code> ，因为这仍然是一个只读子卷！最后你可以检查你所有你想要的东西是不是在那里：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ tree demo</span><br><span class="line">demo</span><br><span class="line">├── bar</span><br><span class="line">├── baz</span><br><span class="line">├── bigfile</span><br><span class="line">└── foo</span><br><span class="line"></span><br><span class="line">0 directories, 4 files</span><br><span class="line">$ tail -c -19 demo/bigfile</span><br><span class="line">a few more changes</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>最后的命令告诉你 <code>bigfile</code> 的最后 19 个字符实际上是上次变更执行的结果。这个时候，你可能想从 <code>demo-broken</code> 复制最近的更新到新的 <code>demo</code> 子卷。因为你没有执行任何更新，你可以过时的子卷：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ sudo btrfs subvolume delete demo-4-ro demo-broken</span><br><span class="line">Delete subvolume (no-commit): &#x27;/home/hartan/btrfs-snapshot-test/demo-4-ro&#x27;</span><br><span class="line">Delete subvolume (no-commit): &#x27;/home/hartan/btrfs-snapshot-test/demo-broken&#x27;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>就是这样！你成功从一个之前存在不同 Btrfs 文件系统（外部介质）的快照中恢复 <code>demo</code> 子卷。</p><h3 id="子卷作为快照的边界"><a href="#子卷作为快照的边界" class="headerlink" title="子卷作为快照的边界"></a>子卷作为快照的边界</h3><p>在本系列的第二篇文章中我提到子卷作为快照的边界，但这到底是什么意思呢？简单来说，子卷的一份快照仅包含这个子卷的内容，而不是下面嵌套的子卷。让我们来看看这个：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ sudo btrfs subvolume create demo/nested</span><br><span class="line">Create subvolume &#x27;demo/nested&#x27;</span><br><span class="line">$ sudo chown -R $(id -u):$(id -g) demo/nested</span><br><span class="line">$ touch demo/nested/another_file</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>让我们像以前一样进行一次快照：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo btrfs subvolume snapshot demo demo-nested</span><br><span class="line">Create a snapshot of &#x27;demo&#x27; in &#x27;./demo-nested&#x27;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后查看里面的内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">$ tree demo-nested</span><br><span class="line">demo-nested</span><br><span class="line">├── bar</span><br><span class="line">├── baz</span><br><span class="line">├── bigfile</span><br><span class="line">├── foo</span><br><span class="line">└── nested</span><br><span class="line"></span><br><span class="line">1 directory, 4 files</span><br><span class="line"></span><br><span class="line">$ tree demo</span><br><span class="line">demo</span><br><span class="line">├── bar</span><br><span class="line">├── baz</span><br><span class="line">├── bigfile</span><br><span class="line">├── foo</span><br><span class="line">└── nested</span><br><span class="line">    └── another_file</span><br><span class="line"></span><br><span class="line">1 directory, 5 files</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>注意到 <code>another_file</code> 不见了，仅仅是目录 <code>nested</code> 还在。这是因为 <code>nested</code> 是一个子卷：<code>demo</code> 的快照包含嵌套子卷的目录（挂载点），但里面的内容是缺失的。目前没有方法递归地执行快照去包含嵌套子卷。但是，我们可以利用这个优势去从快照中排除一些目录！这通常对那些你容易再现的数据有用，或者它们很少变化。例子有虚拟机或者容器镜像，电影，游戏文件等等。</p><p>在总结之前，我们移除所有测试过程中创建的东西：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ sudo btrfs subvolume delete demo/nested demo demo-nested</span><br><span class="line">Delete subvolume (no-commit): &#x27;/home/hartan/btrfs-snapshot-test/demo/nested&#x27;</span><br><span class="line">Delete subvolume (no-commit): &#x27;/home/hartan/btrfs-snapshot-test/demo&#x27;</span><br><span class="line">Delete subvolume (no-commit): &#x27;/home/hartan/btrfs-snapshot-test/demo-nested&#x27;</span><br><span class="line">$ sudo umount backup-drive</span><br><span class="line">$ cd ..</span><br><span class="line">$ rm -rf btrfs-snapshot-test/</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="基于-Btrfs-备份最后思考"><a href="#基于-Btrfs-备份最后思考" class="headerlink" title="基于 Btrfs 备份最后思考"></a>基于 Btrfs 备份最后思考</h3><p>如果你决定使用 Btrfs 来执行数据的定期备份，那么你可能需要使用一个工具来自动完成这项任务。Btrfs 维基有一个专门针对 Btrfs <sup class="footnote-ref"><a href="#fn4" id="fnref4">[4] </a></sup>的备份工具列表。在那里，你还将看到另一个手动执行 Btrfs 备份步骤的摘要。就我个人而言，我对 <code>btrbk</code> <sup class="footnote-ref"><a href="#fn5" id="fnref5">[5] </a></sup>有很多很好的体验，我正在使用它来执行我自己的备份。除了备份之外，<code>btrbk</code> 还可以在你的 PC 本地保存 Btrfs 快照列表。我使用它来防止意外的数据删除。</p><p>如果你想要了解更多有关使用 Btrfs 进行备份的内容，欢迎在下面评论，我会考虑写一篇专门讨论这个话题的后续文章。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本文研究了 Btrfs 快照，它们本质上是 Btrfs 子卷。你了解了如何创建可读写和只读快照，以及这种机制如何有助于防止数据丢失。</p><p>本系列的后续文章将讨论:</p><ul><li>压缩 - 透明地节省存储空间</li><li>配额组 - 限制文件系统大小</li><li>RAID - 替代 mdadm 配置</li></ul><p>如果你还想了解与 Btrfs 相关的其他主题，请查看 Btrfs 维基 <sup class="footnote-ref"><a href="#fn2" id="fnref2:1">[2:1] </a></sup>和文档 <sup class="footnote-ref"><a href="#fn1" id="fnref1:1">[1:1] </a></sup>。不要忘记查看本系列的前两篇文章！如果你认为本文缺少了一些内容，请在下面的评论中告诉我们。再会！</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ol><li><a target="_blank" rel="noopener" href="https://btrfs.readthedocs.io/en/latest/Introduction.html">https://btrfs.readthedocs.io/en/latest/Introduction.html</a> <a href="#fnref1">↩︎</a> <a href="#fnref1:1">↩︎</a></li><li><a target="_blank" rel="noopener" href="https://btrfs.wiki.kernel.org/index.php/Main_Page">https://btrfs.wiki.kernel.org/index.php/Main_Page</a> <a href="#fnref2">↩︎</a> <a href="#fnref2:1">↩︎</a></li><li><a target="_blank" rel="noopener" href="https://btrfs.readthedocs.io/en/latest/Subvolumes.html">https://btrfs.readthedocs.io/en/latest/Subvolumes.html</a> <a href="#fnref3">↩︎</a></li><li><a target="_blank" rel="noopener" href="https://btrfs.wiki.kernel.org/index.php/Incremental_Backup#Available_Backup_Tools">https://btrfs.wiki.kernel.org/index.php/Incremental_Backup#Available_Backup_Tools</a> <a href="#fnref4">↩︎</a></li><li><a target="_blank" rel="noopener" href="https://github.com/digint/btrbk">https://github.com/digint/btrbk</a> <a href="#fnref5">↩︎</a></li></ol><p><em>（题图：MJ&#x2F;ad8a61ed-ce6f-409e-b503-69104dd71149）</em></p><hr><p>via: <a target="_blank" rel="noopener" href="https://fedoramagazine.org/working-with-btrfs-snapshots/">https://fedoramagazine.org/working-with-btrfs-snapshots/</a></p><p>作者：<a target="_blank" rel="noopener" href="https://fedoramagazine.org/author/hartan/">Andreas Hartmann</a> 选题：<a target="_blank" rel="noopener" href="https://github.com/lujun9972">lujun9972</a> 译者：<a target="_blank" rel="noopener" href="https://github.com/A2ureStone">A2ureStone</a> 校对：<a target="_blank" rel="noopener" href="https://github.com/wxy">wxy</a></p><p>本文由 <a target="_blank" rel="noopener" href="https://github.com/LCTT/TranslateProject">LCTT</a> 原创编译，<a target="_blank" rel="noopener" href="https://linux.cn/">Linux中国</a> 荣誉推出</p></div></div></div><div class="footer"><p class="footer-copyright"><span>Powered by <a target="_blank" href="https://hexo.io">Hexo</a></span> <span>Theme <a target="_blank" href="https://github.com/tinkink-co/hexo-theme-terminal">Terminal</a></span><script type="text/javascript" src="https://cdn.staticfile.net/jquery/3.4.1/jquery.min.js"></script><script>getCDNinfo=function(){$.ajax({url:"/cdn-cgi/trace",success:function(a,n){let i="Antananarivo, Madagascar - (TNR);Cape Town, South Africa - (CPT);Casablanca, Morocco - (CMN);Dar Es Salaam, Tanzania - (DAR);Djibouti City, Djibouti - (JIB);Durban, South Africa - (DUR);Johannesburg, South Africa - (JNB);Kigali, Rwanda - (KGL);Lagos, Nigeria - (LOS);Luanda, Angola - (LAD);Maputo, MZ - (MPM);Mombasa, Kenya - (MBA);Port Louis, Mauritius - (MRU);Réunion, France - (RUN);Bangalore, India - (BLR);Bangkok, Thailand - (BKK);Bandar Seri Begawan, Brunei - (BWN);Cebu, Philippines - (CEB);Chengdu, China - (CTU);Chennai, India - (MAA);Chittagong, Bangladesh - (CGP);Chongqing, China - (CKG);Colombo, Sri Lanka - (CMB);Dhaka, Bangladesh - (DAC);Dongguan, China - (SZX);Foshan, China - (FUO);Fuzhou, China - (FOC);Guangzhou, China - (CAN);Hangzhou, China - (HGH);Hanoi, Vietnam - (HAN);Hengyang, China - (HNY);Ho Chi Minh City, Vietnam - (SGN);Hong Kong - (HKG);Hyderabad, India - (HYD);Islamabad, Pakistan - (ISB);Jakarta, Indonesia - (CGK);Jinan, China - (TNA);Karachi, Pakistan - (KHI);Kathmandu, Nepal - (KTM);Kolkata, India - (CCU);Kuala Lumpur, Malaysia - (KUL);Lahore, Pakistan - (LHE);Langfang, China - (NAY);Luoyang, China - (LYA);Macau - (MFM);Malé, Maldives - (MLE);Manila, Philippines - (MNL);Mumbai, India - (BOM);Nagpur, India - (NAG);Nanning, China - (NNG);New Delhi, India - (DEL);Osaka, Japan - (KIX);Phnom Penh, Cambodia - (PNH);Qingdao, China - (TAO);Seoul, South Korea - (ICN);Shanghai, China - (SHA);Shenyang, China - (SHE);Shijiazhuang, China - (SJW);Singapore, Singapore - (SIN);Suzhou, China - (SZV);Taipei - (TPE);Thimphu, Bhutan - (PBH);Tianjin, China - (TSN);Tokyo, Japan - (NRT);Ulaanbaatar, Mongolia - (ULN);Vientiane, Laos - (VTE);Wuhan, China - (WUH);Wuxi, China - (WUX);Xi'an, China - (XIY);Yerevan, Armenia - (EVN);Zhengzhou, China - (CGO);Zuzhou, China - (CSX);Amsterdam, Netherlands - (AMS);Athens, Greece - (ATH);Barcelona, Spain - (BCN);Belgrade, Serbia - (BEG);Berlin, Germany - (TXL);Brussels, Belgium - (BRU);Bucharest, Romania - (OTP);Budapest, Hungary - (BUD);Chișinău, Moldova - (KIV);Copenhagen, Denmark - (CPH);Cork, Ireland -  (ORK);Dublin, Ireland - (DUB);Düsseldorf, Germany - (DUS);Edinburgh, United Kingdom - (EDI);Frankfurt, Germany - (FRA);Geneva, Switzerland - (GVA);Gothenburg, Sweden - (GOT);Hamburg, Germany - (HAM);Helsinki, Finland - (HEL);Istanbul, Turkey - (IST);Kyiv, Ukraine - (KBP);Lisbon, Portugal - (LIS);London, United Kingdom - (LHR);Luxembourg City, Luxembourg - (LUX);Madrid, Spain - (MAD);Manchester, United Kingdom - (MAN);Marseille, France - (MRS);Milan, Italy - (MXP);Moscow, Russia - (DME);Munich, Germany - (MUC);Nicosia, Cyprus - (LCA);Oslo, Norway - (OSL);Paris, France - (CDG);Prague, Czech Republic - (PRG);Reykjavík, Iceland - (KEF);Riga, Latvia - (RIX);Rome, Italy - (FCO);Saint Petersburg, Russia - (LED);Sofia, Bulgaria - (SOF);Stockholm, Sweden - (ARN);Tallinn, Estonia - (TLL);Thessaloniki, Greece - (SKG);Vienna, Austria - (VIE);Vilnius, Lithuania - (VNO);Warsaw, Poland - (WAW);Zagreb, Croatia - (ZAG);Zürich, Switzerland - (ZRH);Arica, Chile - (ARI);Asunción, Paraguay - (ASU);Bogotá, Colombia - (BOG);Buenos Aires, Argentina - (EZE);Curitiba, Brazil - (CWB);Fortaleza, Brazil - (FOR);Guatemala City, Guatemala - (GUA);Lima, Peru - (LIM);Medellín, Colombia - (MDE);Panama City, Panama - (PTY);Porto Alegre, Brazil - (POA);Quito, Ecuador - (UIO);Rio de Janeiro, Brazil - (GIG);São Paulo, Brazil - (GRU);Santiago, Chile - (SCL);Willemstad, Curaçao - (CUR);St. George's, Grenada - (GND);Amman, Jordan - (AMM);Baghdad, Iraq - (BGW);Baku, Azerbaijan - (GYD);Beirut, Lebanon - (BEY);Doha, Qatar - (DOH);Dubai, United Arab Emirates - (DXB);Kuwait City, Kuwait - (KWI);Manama, Bahrain - (BAH);Muscat, Oman - (MCT);Ramallah - (ZDM);Riyadh, Saudi Arabia - (RUH);Tel Aviv, Israel - (TLV);Ashburn, VA, United States - (IAD);Atlanta, GA, United States - (ATL);Boston, MA, United States - (BOS);Buffalo, NY, United States - (BUF);Calgary, AB, Canada - (YYC);Charlotte, NC, United States - (CLT);Chicago, IL, United States - (ORD);Columbus, OH, United States - (CMH);Dallas, TX, United States - (DFW);Denver, CO, United States - (DEN);Detroit, MI, United States - (DTW);Honolulu, HI, United States - (HNL);Houston, TX, United States - (IAH);Indianapolis, IN, United States - (IND);Jacksonville, FL, United States - (JAX);Kansas City, MO, United States - (MCI);Las Vegas, NV, United States - (LAS);Los Angeles, CA, United States - (LAX);McAllen, TX, United States - (MFE);Memphis, TN, United States - (MEM);Mexico City, Mexico - (MEX);Miami, FL, United States - (MIA);Minneapolis, MN, United States - (MSP);Montgomery, AL, United States - (MGM);Montréal, QC, Canada - (YUL);Nashville, TN, United States - (BNA);Newark, NJ, United States - (EWR);Norfolk, VA, United States - (ORF);Omaha, NE, United States - (OMA);Philadelphia, United States - (PHL);Phoenix, AZ, United States - (PHX);Pittsburgh, PA, United States - (PIT);Port-Au-Prince, Haiti - (PAP);Portland, OR, United States - (PDX);Queretaro, MX, Mexico - (QRO);Richmond, Virginia - (RIC);Sacramento, CA, United States - (SMF);Salt Lake City, UT, United States - (SLC);San Diego, CA, United States - (SAN);San Jose, CA, United States - (SJC);Saskatoon, SK, Canada - (YXE);Seattle, WA, United States - (SEA);St. Louis, MO, United States - (STL);Tampa, FL, United States - (TPA);Toronto, ON, Canada - (YYZ);Vancouver, BC, Canada - (YVR);Tallahassee, FL, United States - (TLH);Winnipeg, MB, Canada - (YWG);Adelaide, SA, Australia - (ADL);Auckland, New Zealand - (AKL);Brisbane, QLD, Australia - (BNE);Melbourne, VIC, Australia - (MEL);Noumea, New caledonia - (NOU);Perth, WA, Australia - (PER);Sydney, NSW, Australia - (SYD)".split(";"),e=a.split("colo=")[1].split("\n")[0],t=(a.split("colo=")[1].split("\n")[0],a.split("tls=")[1].split("\n")[0]),o=a.split("http=")[1].split("\n")[0],s=a.split("sni=")[1].split("\n")[0],r=a.split("ip=")[1].split("\n")[0],l=a.split("uag=")[1].split("\n")[0];for(var d=0;d<i.length;d++)if(-1!=i[d].indexOf(e)){document.getElementById("cdn").innerHTML=i[d];break}document.getElementById("tls").innerHTML=t,document.getElementById("http").innerHTML=o,document.getElementById("sni").innerHTML=s,document.getElementById("ip").innerHTML=r,document.getElementById("useragent").innerHTML=l}})},$(document).ready((function(){getCDNinfo()}))</script></p><p style="text-align:center">感谢陪伴与布道，开源之火不灭。​</p><p style="text-align:center"><script>document.write("本次加载耗时: "+(performance.getEntriesByType("navigation").reduce((e,r)=>e+r.responseEnd-r.startTime,0)+performance.getEntriesByType("resource").reduce((e,r)=>e+r.responseEnd-r.startTime,0)).toFixed(0)+"ms")</script></p><p style="text-align:center">当前 SNI 状态： <span id="sni">正在统计！或可能被浏览器防追踪拦截！</span></p><p style="text-align:center">当前 TLS 版本： <span id="tls">正在统计！或可能被浏览器防追踪拦截！</span></p><p style="text-align:center">当前 HTTP 版本： <span id="http">正在统计！或可能被浏览器防追踪拦截！</span></p><p style="text-align:center">当前您的客户端 IP 是： <span id="ip">正在统计！或可能被浏览器防追踪拦截！</span></p><p style="text-align:center">当前分配的 CDN 节点是: <span id="cdn">正在统计！或可能被浏览器防追踪拦截！</span></p><p style="text-align:center">您的 UserAgent 信息是: <span id="useragent">正在统计！或可能被浏览器防追踪拦截！</span></p><p></p></div></div></body></html>