<!doctype html><html lang="en"><head><meta name="msvalidate.01" content="D404690CEFCB54C7762AC84935B99171"><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?6618da70c90c8744eead2e9371fb5077";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><script type="text/javascript">!function(t,e,n,c,s,a,r){t[n]=t[n]||function(){(t[n].q=t[n].q||[]).push(arguments)},(a=e.createElement(c)).async=1,a.src="https://www.clarity.ms/tag/s5f3f0tojf",(r=e.getElementsByTagName(c)[0]).parentNode.insertBefore(a,r)}(window,document,"clarity","script")</script><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta http-equiv="X-UA-Compatible" content="ie=edge"><link rel="stylesheet" href="/styles/base.css"><link rel="stylesheet" href="/styles/theme.css"><link rel="shortcut icon" href="/favicon.png"><title>Linux 中的 DTrace ：BPF 进入 4.9 内核 - 归墟星火集</title><meta name="generator" content="Hexo 7.3.0"></head><body><div class="header-title"><span class="header-light"></span> <span class="header-light"></span> <span class="header-light"></span> <span>归墟星火集 linuxcn.undefined.today<span></span></span></div><div class="container"><ul class="nav"><li><a href="/">首页</a></li><li><a href="/about/">关于</a></li><li><a target="_blank" rel="noopener" href="https://undefined.today/">Blog</a></li></ul><div class="content"><div class="post-container"><div class="post-header"><span class="ui-tips">标题：</span><h1 class="ui-keyword post-title">Linux 中的 DTrace ：BPF 进入 4.9 内核</h1><span class="post-date">2016-12-15</span></div><div class="post-header"><span class="ui-tips">分类：</span> <a href="/categories/%E6%8A%80%E6%9C%AF/">技术</a></div><div class="post-header"><span class="ui-tips">标签：</span> <a href="/tags/%E6%80%A7%E8%83%BD/">性能</a> <a href="/tags/%E8%B7%9F%E8%B8%AA/">跟踪</a> <a href="/tags/BPF/">BPF</a> <a href="/tags/DTrace/">DTrace</a></div><div class="post-content"><blockquote><p>本文作者 <a target="_blank" rel="noopener" href="http://www.brendangregg.com/">Brendan Gregg</a> 目前是 Netflix 的高级性能架构师 ，他在那里做大规模计算机性能设计、分析和调优。他是《Systems Performance》等技术书的作者，因在系统管理员方面的成绩，获得过 2013年 USENIX LISA 大奖。他之前是 SUN 公司是性能领头人和内核工程师，研究存储和网络性能。他也发明和开发过一大波性能分析工具，很多已集成到操作系统中了 。</p></blockquote><p>随着 BPF 追踪系统（基于时间采样）最后一个主要功能被合并至 Linux 4.9-rc1 版本的内核中，现在 Linux 内核拥有类似 DTrace 的原生追踪功能。DTrace 是 Solaris 系统中的高级追踪器。对于长期使用 DTrace 的用户和专家，这将是一个振奋人心的里程碑！现在在 Linux 系统上，你可以在生产环境中使用安全的、低负载的定制追踪系统，通过执行时间的柱状图和频率统计等信息，分析应用的性能以及内核。</p><p><img src="https://linuxcn.img.undefined.today/data/attachment/album/201612/15/122148mch4g3sfkk7uc9hf.jpg"></p><p>用于 Linux 的追踪项目有很多，但是这个最终被合并进 Linux 内核的技术从一开始就根本不是一个追踪项目：它是最开始是用于<ruby>伯克利包过滤器 <rp>（ </rp><rt>Berkeley Packet Filter</rt> <rp>）</rp></ruby>（BPF）的增强功能。这些补丁允许 BPF 重定向数据包，从而创建软件定义网络（SDN）。久而久之，对事件追踪的支持就被添加进来了，使得程序追踪可用于 Linux 系统。</p><p>尽管目前 BPF 没有像 DTrace 一样的高级语言，但它所提供的前端已经足够让我创建很多 BPF 工具了，其中有些是基于我以前的 <a target="_blank" rel="noopener" href="https://github.com/opendtrace/toolkit">DTraceToolkit</a>。这个帖子将告诉你怎么去用这些 BPF 提供的前端工具，以及畅谈这项技术将会何去何从。</p><p><img src="https://linuxcn.img.undefined.today/data/attachment/album/201612/15/122242u33plex1xg11xk8p.png"></p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>我已经将基于 BPF 的追踪工具添加到了开源的 <a target="_blank" rel="noopener" href="https://github.com/iovisor/bcc">bcc</a> 项目里（感谢 PLUMgrid 公司的 Brenden Blanco 带领 bcc 项目的发展）。详见 <a target="_blank" rel="noopener" href="https://github.com/iovisor/bcc/blob/master/INSTALL.md">bcc 安装</a> 手册。它会在 <code>/usr/share/bcc/tools</code> 目录下添加一系列工具，包括接下来的那些工具。</p><p>捕获新进程：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># execsnoop</span><br><span class="line">PCOMM            PID    RET ARGS</span><br><span class="line">bash             15887    0 /usr/bin/man ls</span><br><span class="line">preconv          15894    0 /usr/bin/preconv -e UTF-8</span><br><span class="line">man              15896    0 /usr/bin/tbl</span><br><span class="line">man              15897    0 /usr/bin/nroff -mandoc -rLL=169n -rLT=169n -Tutf8</span><br><span class="line">man              15898    0 /usr/bin/pager -s</span><br><span class="line">nroff            15900    0 /usr/bin/locale charmap</span><br><span class="line">nroff            15901    0 /usr/bin/groff -mtty-char -Tutf8 -mandoc -rLL=169n -rLT=169n</span><br><span class="line">groff            15902    0 /usr/bin/troff -mtty-char -mandoc -rLL=169n -rLT=169n -Tutf8</span><br><span class="line">groff            15903    0 /usr/bin/grotty</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>硬盘 I&#x2F;O 延迟的柱状图：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># biolatency -m</span><br><span class="line">Tracing block device I/O... Hit Ctrl-C to end.</span><br><span class="line">^C</span><br><span class="line">     msecs           : count     distribution</span><br><span class="line">       0 -&gt; 1        : 96       |************************************  |</span><br><span class="line">       2 -&gt; 3        : 25       |*********                             |</span><br><span class="line">       4 -&gt; 7        : 29       |***********                           |</span><br><span class="line">       8 -&gt; 15       : 62       |***********************               |</span><br><span class="line">      16 -&gt; 31       : 100      |**************************************|</span><br><span class="line">      32 -&gt; 63       : 62       |***********************               |</span><br><span class="line">      64 -&gt; 127      : 18       |******                                |</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>追踪慢于 5 毫秒的 ext4 常见操作：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># ext4slower 5</span><br><span class="line">Tracing ext4 operations slower than 5 ms</span><br><span class="line">TIME     COMM           PID    T BYTES   OFF_KB   LAT(ms) FILENAME</span><br><span class="line">21:49:45 supervise      3570   W 18      0           5.48 status.new</span><br><span class="line">21:49:48 supervise      12770  R 128     0           7.55 run</span><br><span class="line">21:49:48 run            12770  R 497     0          16.46 nsswitch.conf</span><br><span class="line">21:49:48 run            12770  R 1680    0          17.42 netflix_environment.sh</span><br><span class="line">21:49:48 run            12770  R 1079    0           9.53 service_functions.sh</span><br><span class="line">21:49:48 run            12772  R 128     0          17.74 svstat</span><br><span class="line">21:49:48 svstat         12772  R 18      0           8.67 status</span><br><span class="line">21:49:48 run            12774  R 128     0          15.76 stat</span><br><span class="line">21:49:48 run            12777  R 128     0           7.89 grep</span><br><span class="line">21:49:48 run            12776  R 128     0           8.25 ps</span><br><span class="line">21:49:48 run            12780  R 128     0          11.07 xargs</span><br><span class="line">21:49:48 ps             12776  R 832     0          12.02 libprocps.so.4.0.0</span><br><span class="line">21:49:48 run            12779  R 128     0          13.21 cut</span><br><span class="line">[...]</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>追踪新建的 TCP 活跃连接（<code>connect()</code>）:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># tcpconnect</span><br><span class="line">PID    COMM         IP SADDR            DADDR            DPORT</span><br><span class="line">1479   telnet       4  127.0.0.1        127.0.0.1        23</span><br><span class="line">1469   curl         4  10.201.219.236   54.245.105.25    80</span><br><span class="line">1469   curl         4  10.201.219.236   54.67.101.145    80</span><br><span class="line">1991   telnet       6  ::1              ::1              23</span><br><span class="line">2015   ssh          6  fe80::2000:bff:fe82:3ac fe80::2000:bff:fe82:3ac 22</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>通过跟踪 <code>getaddrinfo()</code>&#x2F;<code>gethostbyname()</code> 库的调用来追踪 DNS 延迟：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># gethostlatency</span><br><span class="line">TIME      PID    COMM          LATms HOST</span><br><span class="line">06:10:24  28011  wget          90.00 www.iovisor.org</span><br><span class="line">06:10:28  28127  wget           0.00 www.iovisor.org</span><br><span class="line">06:10:41  28404  wget           9.00 www.netflix.com</span><br><span class="line">06:10:48  28544  curl          35.00 www.netflix.com.au</span><br><span class="line">06:11:10  29054  curl          31.00 www.plumgrid.com</span><br><span class="line">06:11:16  29195  curl           3.00 www.facebook.com</span><br><span class="line">06:11:25  29404  curl          72.00 foo</span><br><span class="line">06:11:28  29475  curl           1.00 foo</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>按类别划分 VFS 操作的时间间隔统计：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># vfsstat</span><br><span class="line">TIME         READ/s  WRITE/s CREATE/s   OPEN/s  FSYNC/s</span><br><span class="line">18:35:32:       231       12        4       98        0</span><br><span class="line">18:35:33:       274       13        4      106        0</span><br><span class="line">18:35:34:       586       86        4      251        0</span><br><span class="line">18:35:35:       241       15        4       99        0</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>对一个给定的 PID，通过内核和用户堆栈轨迹来追踪 CPU 处理之外的时间（由内核进行统计）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"># offcputime -d -p 24347</span><br><span class="line">Tracing off-CPU time (us) of PID 24347 by user + kernel stack... Hit Ctrl-C to end.</span><br><span class="line">^C</span><br><span class="line">[...]</span><br><span class="line">    ffffffff810a9581 finish_task_switch</span><br><span class="line">    ffffffff8185d385 schedule</span><br><span class="line">    ffffffff81085672 do_wait</span><br><span class="line">    ffffffff8108687b sys_wait4</span><br><span class="line">    ffffffff81861bf6 entry_SYSCALL_64_fastpath</span><br><span class="line">    --</span><br><span class="line">    00007f6733a6b64a waitpid</span><br><span class="line">    -                bash (24347)</span><br><span class="line">        4952</span><br><span class="line"></span><br><span class="line">    ffffffff810a9581 finish_task_switch</span><br><span class="line">    ffffffff8185d385 schedule</span><br><span class="line">    ffffffff81860c48 schedule_timeout</span><br><span class="line">    ffffffff810c5672 wait_woken</span><br><span class="line">    ffffffff8150715a n_tty_read</span><br><span class="line">    ffffffff815010f2 tty_read</span><br><span class="line">    ffffffff8122cd67 __vfs_read</span><br><span class="line">    ffffffff8122df65 vfs_read</span><br><span class="line">    ffffffff8122f465 sys_read</span><br><span class="line">    ffffffff81861bf6 entry_SYSCALL_64_fastpath</span><br><span class="line">    --</span><br><span class="line">    00007f6733a969b0 read</span><br><span class="line">    -                bash (24347)</span><br><span class="line">        1450908</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>追踪 MySQL 查询延迟（通过 USDT 探针）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># mysqld_qslower `pgrep -n mysqld`</span><br><span class="line">Tracing MySQL server queries for PID 14371 slower than 1 ms...</span><br><span class="line">TIME(s)        PID          MS QUERY</span><br><span class="line">0.000000       18608   130.751 SELECT * FROM words WHERE word REGEXP &#x27;^bre.*n$&#x27;</span><br><span class="line">2.921535       18608   130.590 SELECT * FROM words WHERE word REGEXP &#x27;^alex.*$&#x27;</span><br><span class="line">4.603549       18608    24.164 SELECT COUNT(*) FROM words</span><br><span class="line">9.733847       18608   130.936 SELECT count(*) AS count FROM words WHERE word REGEXP &#x27;^bre.*n$&#x27;</span><br><span class="line">17.864776      18608   130.298 SELECT * FROM words WHERE word REGEXP &#x27;^bre.*n$&#x27; ORDER BY word</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>监测 pam 库并使用多种追踪工具观察登录请求：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># trace &#x27;pam:pam_start &quot;%s: %s&quot;, arg1, arg2&#x27;</span><br><span class="line">TIME     PID    COMM         FUNC             -</span><br><span class="line">17:49:45 5558   sshd         pam_start        sshd: root</span><br><span class="line">17:49:47 5662   sudo         pam_start        sudo: root</span><br><span class="line">17:49:49 5727   login        pam_start        login: bgregg</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>bcc 项目里的很多工具都有帮助信息（<code>-h</code> 选项），并且都应该包含有示例的 man 页面和文本文件。</p><h3 id="必要性"><a href="#必要性" class="headerlink" title="必要性"></a>必要性</h3><p>2014 年，Linux 追踪程序就有一些内核相关的特性（来自 <code>ftrace</code> 和 <code>pref_events</code>），但是我们仍然要转储并报告进程数据，这种几十年前的老技术有很多的限制。你不能频繁地访问进程名、函数名、堆栈轨迹或内核中的任意的其它数据。你不能在将变量保存到一个监测事件里，又在另一个事件里访问它们，这意味着你不能在你需要的地方计算延迟（或者说时间增量）。你也不能创建一个内核内部的延迟柱状图，也不能追踪 USDT 探针，甚至不能写个自定义的程序。DTrace 可以做到所有这些，但仅限于 Solaris 或 BSD 系统。在 Linux 系统中，有些不在主线内核的追踪器，比如 SystemTap 就可以满足你的这些需求，但它也有自身的不足。（理论上说，你可以写一个基于探针的内核模块来满足需求-但实际上没人这么做。）</p><p>2014 年我加入了 Netflix cloud performance 团队。做了这么久的 DTrace 方面的专家，转到 Linux 对我来说简直不可思议。但我确实这么做了，而且遇到了巨大的挑战：在应用快速变化、采用微服务架构和分布式系统的情况下，调优 Netflix cloud。有时要用到系统追踪，而我之前是用的 DTrace。在 Linux 系统上可没有 DTrace，我就开始用 Linux 内核内建的 <code>ftrace</code> 和 <code>perf_events</code> 工具，构建了一个追踪工具（<a target="_blank" rel="noopener" href="https://github.com/brendangregg/perf-tools">perf-tools</a>）。这些工具很有用，但有些工作还是没法完成，尤其是延迟柱状图以及堆栈踪迹计数。我们需要的是内核追踪的可程序化。</p><h3 id="发生了什么？"><a href="#发生了什么？" class="headerlink" title="发生了什么？"></a>发生了什么？</h3><p>BPF 将程序化的功能添加到现有的内核追踪工具中（<code>tracepoints</code>、<code>kprobes</code>、<code>uprobes</code>）。在 Linux 4.x 系列的内核里，这些功能大大加强了。</p><p>时间采样是最主要的部分，它被 Linux 4.9-rc1 所采用（<a target="_blank" rel="noopener" href="https://lkml.org/lkml/2016/9/1/831">patchset</a>）。十分感谢 Alexei Starovoitov（在 Facebook 致力于 BPF 的开发），他是这些 BPF 增强功能的主要开发者。</p><p>Linux 内核现在内建有以下这些特性（自 2.6 版本到 4.9 版本之间增加）：</p><ul><li>内核级的动态追踪（BPF 对 <code>kprobes</code> 的支持）</li><li>用户级的动态追踪（BPF 对 <code>uprobes</code> 的支持）</li><li>内核级的静态追踪（BPF 对 <code>tracepoints</code> 的支持）</li><li>时间采样事件（BPF 的 <code>pref_event_open</code>）</li><li>PMC 事件（BPF 的 <code>pref_event_open</code>）</li><li>过滤器（通过 BPF 程序）</li><li>调试输出（<code>bpf_trace_printk()</code>）</li><li>按事件输出（<code>bpf_perf_event_output()</code>）</li><li>基础变量（全局的和每个线程的变量，基于 BPF 映射）</li><li>关联数组（通过 BPF 映射）</li><li>频率计数（基于 BPF 映射）</li><li>柱状图（2 的冥次方、线性及自定义，基于 BPF 映射）</li><li>时间戳和时间增量（<code>bpf_ktime_get_ns()</code>，和 BPF 程序）</li><li>内核态的堆栈轨迹（BPF 栈映射）</li><li>用户态的堆栈轨迹 (BPF 栈映射)</li><li>重写 ring 缓存（<code>pref_event_attr.write_backward</code>）</li></ul><p>我们采用的前端是 bcc，它同时提供 Python 和 lua 接口。bcc 添加了：</p><ul><li>用户级静态追踪（基于 <code>uprobes</code> 的 USDT 探针）</li><li>调试输出（Python 中调用 <code>BPF.trace_pipe()</code> 和 <code>BPF.trace_fields()</code> 函数 ）</li><li>按事件输出（<code>BPF_PERF_OUTPUT</code> 宏和 <code>BPF.open_perf_buffer()</code>）</li><li>间隔输出（<code>BPF.get_table()</code> 和 <code>table.clear()</code>）</li><li>打印柱状图（<code>table.print_log2_hist()</code>）</li><li>内核级的 C 结构体导航（bcc 重写器映射到 <code>bpf_probe_read()</code> 函数）</li><li>内核级的符号解析（<code>ksym()</code>、 <code>ksymaddr()</code>）</li><li>用户级的符号解析（<code>usymaddr()</code>）</li><li>BPF 跟踪点支持（通过 <code>TRACEPOINT_PROBE</code>）</li><li>BPF 堆栈轨迹支持（包括针对堆栈框架的 <code>walk</code> 方法）</li><li>其它各种辅助宏和方法</li><li>例子（位于 <code>/examples</code> 目录）</li><li>工具（位于 <code>/tools</code> 目录）</li><li>教程（<code>/docs/tutorial*.md</code>）</li><li>参考手册（<code>/docs/reference_guide.md</code>）</li></ul><p>直到最新也是最主要的特性被整合进来，我才开始写这篇文章，现在它在 4.9-rc1 内核中。我们还需要去完成一些次要的东西，还有另外一些事情要做，但是现在我们所拥有的已经值得欢呼了。现在 Linux 拥有了内建的高级追踪能力。</p><h3 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h3><p>设计 BPF 及其增强功能时就考虑到生产环境级安全，它被用在大范围的生产环境里。不过你想的话，你还是可以找到一个挂起内核的方法。这种情况是偶然的，而不是必然，类似的漏洞会被快速修复，尤其是当 BPF 合并入了 Linux。因为 Linux 可是公众的焦点。</p><p>在开发过程中我们碰到了一些非 BPF 的漏洞，它们需要被修复：rcu 不可重入，这可能导致内核由于 funccount 挂起，在 4.6 内核版本中这个漏洞被 “bpf: map pre-alloc” 补丁集所修复，旧版本内核的漏洞 bcc 有个临时处理方案。还有一个是 uprobe 的内存计算问题，这导致 uprobe 分配内存失败，在 4.8 内核版本这个漏洞由 “uprobes: Fix the memcg accounting” 补丁所修复，并且该补丁还将被移植到之前版本的内核中（例如，它现在被移植到了 4.4.27 和 4.4.0-45.66 版本中）。</p><h3 id="为什么-Linux-追踪用了这么久才加进来？"><a href="#为什么-Linux-追踪用了这么久才加进来？" class="headerlink" title="为什么 Linux 追踪用了这么久才加进来？"></a>为什么 Linux 追踪用了这么久才加进来？</h3><p>首要任务被分到了若干追踪器中间：这些不是某个追踪器单个的事情。想要了解更多关于这个或其它方面的问题，可以看一看我在 2014 年 <a target="_blank" rel="noopener" href="http://www.slideshare.net/brendangregg/from-dtrace-to-linux">tracing summit 上的讲话</a>。我忽视了部分方案的反面影响：有些公司发现其它追踪器（SystemTap 和 LTTng）能满足他们的需求，尽管他们乐于听到 BPF 的开发进程，但考虑到他们现有的解决方案，帮助 BPF 的开发就不那么重要了。</p><p>BPF 仅在近两年里在追踪领域得到加强。这一过程原本可以更快的，但早期缺少全职从事于 BPF 追踪的工程师。Alexei Starovoitov (BPF 领导者)，Brenden Blanco (bcc 领导者)，我还有其它一些开发者，都有其它的事情要做。我在 Netflix 公司花了大量时间（志愿地），大概有 7% 的时间是花在 BPF 和 bcc 上。某种程度上这不是我的首要任务，因为我还有自己的工作（包括我的 perf-tools，一个可以工作在旧版本内核上的程序）。</p><p>现在BPF 追踪器已经推出了，已经有科技公司开始寻找会 BPF 的人了。但我还是推荐 <a target="_blank" rel="noopener" href="http://www.brendangregg.com/blog/2016-03-30/working-at-netflix-2016.html">Netflix 公司</a>。（如果你为了 BPF 而要聘请我，那我还是十分乐于待在 Netflix 公司的！）</p><h3 id="使用简单"><a href="#使用简单" class="headerlink" title="使用简单"></a>使用简单</h3><p>DTrace 和 bcc&#x2F;BPF 现在的最大区别就是哪个更好使用。这取决于你要用 BPF 追踪做什么了。如果你要</p><ul><li><strong>使用 BPF 工具&#x2F;度量</strong>：应该是没什么区别的。工具的表现都差不多，图形用户界面都能取得类似度量指标。大部分用户通过这种方式使用 BPF。</li><li><strong>开发工具&#x2F;度量</strong>：bcc 的开发可难多了。DTrace 有一套自己的简单语言，D 语音，和 awk 语言相似，而 bcc 使用已有的语言（C 语言，Python 和 lua）及其类库。一个用 C 和 Python 写的 bcc 工具与仅仅用 D 语言写出来的工具相比，可能要多十多倍行数的代码，或者更多。但是很多 DTrace 工具用 shell 封装来提供参数和差错检查，会让代码变得十分臃肿。编程的难处是不同的：重写 bcc 更需要巧妙性，这导致某些脚本更加难开发。（尤其是 <code>bpf_probe_read()</code> 这类的函数，需要了解更多 BPF 的内涵知识）。当计划改进 bcc 时，这一情形将得到改善。</li><li><strong>运行常见的命令</strong>：十分相近。通过 <code>dtrace</code> 命令，DTrace 能做很多事，但 bcc 有各种工具，<code>trace</code>、<code>argdist</code>、<code>funccount</code>、<code>funclatency</code> 等等。</li><li><strong>编写自定义的特殊命令</strong>：使用 DTrace 的话，这就没有必要了。允许定制消息快速传递和系统快速响应，DTrace 的高级分析很快。而 bcc 现在受限于它的多种工具以及它们的适用范围。</li></ul><p>简单来说，如果你只使用 BPF 工具的话，就不必关注这些差异了。如果你经验丰富，是个开发者（像我一样），目前 bcc 的使用更难一些。</p><p>举一个 bcc 的 Python 前端的例子，下面是追踪硬盘 I&#x2F;O 并打印出 I&#x2F;O 大小的柱状图代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">from bcc import BPF</span><br><span class="line">from time import sleep</span><br><span class="line"></span><br><span class="line"># load BPF program</span><br><span class="line">b = BPF(text=&quot;&quot;&quot;</span><br><span class="line">#include &lt;uapi/linux/ptrace.h&gt;</span><br><span class="line">#include &lt;linux/blkdev.h&gt;</span><br><span class="line"></span><br><span class="line">BPF_HISTOGRAM(dist);</span><br><span class="line"></span><br><span class="line">int kprobe__blk_account_io_completion(struct pt_regs *ctx, struct request *req)</span><br><span class="line">&#123;</span><br><span class="line">    dist.increment(bpf_log2l(req-&gt;__data_len / 1024));</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">&quot;&quot;&quot;)</span><br><span class="line"></span><br><span class="line"># header</span><br><span class="line">print(&quot;Tracing... Hit Ctrl-C to end.&quot;)</span><br><span class="line"></span><br><span class="line"># trace until Ctrl-C</span><br><span class="line">try:</span><br><span class="line">    sleep(99999999)</span><br><span class="line">except KeyboardInterrupt:</span><br><span class="line">    print</span><br><span class="line"></span><br><span class="line"># output</span><br><span class="line">b[&quot;dist&quot;].print_log2_hist(&quot;kbytes&quot;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>注意 Python 代码中嵌入的 C 语句（<code>text=</code>）。</p><p>这就完成了任务，但仍有改进的空间。好在我们有时间去做：人们使用 Linux 4.9 并能用上 BPF 还得好几个月呢，所以我们有时间来制造工具和前端。</p><h3 id="高级语言"><a href="#高级语言" class="headerlink" title="高级语言"></a>高级语言</h3><p>前端越简单，比如高级语言，所改进的可能就越不如你所期望的。绝大多数人使用封装好的工具（和图形界面），仅有少部分人能写出这些工具。但我不反对使用高级语言，比如 SystemTap，毕竟已经开发出来了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/stap</span><br><span class="line">/*</span><br><span class="line"> * opensnoop.stp    Trace file open()s.  Basic version of opensnoop.</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">probe begin</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;\n%6s %6s %16s %s\n&quot;, &quot;UID&quot;, &quot;PID&quot;, &quot;COMM&quot;, &quot;PATH&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">probe syscall.open</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;%6d %6d %16s %s\n&quot;, uid(), pid(), execname(), filename);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如果拥有整合了语言和脚本的 SystemTap 前端与高性能的内置在内核中的 BPF 后端，会不会令人满意呢？RedHat 公司的 Richard Henderson 已经在进行相关工作了，并且发布了 <a target="_blank" rel="noopener" href="https://lkml.org/lkml/2016/6/14/749">初代版本</a>！</p><p>这是 <a target="_blank" rel="noopener" href="https://wkz.github.io/ply/">ply</a>，一个完全新颖的 BPF 高级语言：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env ply</span><br><span class="line"></span><br><span class="line">kprobe:SyS_*</span><br><span class="line">&#123;</span><br><span class="line">    $syscalls[func].count()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这也是一份承诺。</p><p>尽管如此，我认为工具开发者的实际难题不是使用什么语言：而是要了解要用这些强大的工具做什么？</p><h3 id="如何帮助我们"><a href="#如何帮助我们" class="headerlink" title="如何帮助我们"></a>如何帮助我们</h3><ul><li><strong>推广</strong>：BPF 追踪器目前还没有什么市场方面的进展。尽管有公司了解并在使用它（Facebook、Netflix、Github 和其它公司），但要广为人知尚需时日。你可以分享关于 BPF 的文章和资源给业内的其它公司来帮助我们。</li><li><strong>教育</strong>：你可以撰写文章，发表演讲，甚至参与 bcc 文档的编写。分享 BPF 如何解决实际问题以及为公司带来收益的实例。</li><li><strong>解决 bcc 的问题</strong>：参考 <a target="_blank" rel="noopener" href="https://github.com/iovisor/bcc/issues">bcc issue list</a>，这包含了错误和需要的特性。</li><li><strong>提交错误</strong>：使用 bcc&#x2F;BPF，提交你发现的错误。</li><li><strong>创造工具</strong>：有很多可视化的工具需要开发，但请不要太草率，因为大家会先花几个小时学习使用你做的工具，所以请尽量把工具做的直观好用（参考我的<a target="_blank" rel="noopener" href="https://github.com/iovisor/bcc/blob/master/CONTRIBUTING-SCRIPTS.md">文档</a>）。就像 Mike Muuss 提及到他自己的 <a target="_blank" rel="noopener" href="http://ftp.arl.army.mil/%7Emike/ping.html">ping</a> 程序：“要是我早知道这是我一生中最出名的成就，我就多开发一两天，添加更多选项。”</li><li><strong>高级语言</strong>：如果现有的 bcc 前端语言让你很困扰，或许你能弄门更好的语言。要是你想将这门语言内建到 bcc 里面，你需要使用 libbcc。或者你可以帮助 SystemTap BPF 或 ply 的工作。</li><li><strong>整合图形界面</strong>：除了 bcc 可以使用的 CLI 命令行工具，怎么让这些信息可视呢？延迟热点图，火焰图等等。</li></ul><h3 id="其它追踪器"><a href="#其它追踪器" class="headerlink" title="其它追踪器"></a>其它追踪器</h3><p>那么 SystemTap、ktap、sysdig、LTTng 等追踪器怎么样呢？它们有个共同点，要么使用了 BPF，要么在自己的领域做得更好。会有单独的文章介绍它们自己。</p><p>至于 DTrace ？我们公司目前还在基于 FreeBSD 系统的 CDN 中使用它。</p><h3 id="更多-bcc-BPF-的信息"><a href="#更多-bcc-BPF-的信息" class="headerlink" title="更多 bcc&#x2F;BPF 的信息"></a>更多 bcc&#x2F;BPF 的信息</h3><p>我已经写了一篇《<a target="_blank" rel="noopener" href="https://github.com/iovisor/bcc/blob/master/docs/tutorial.md">bcc&#x2F;BPF 工具最终用户教程</a>》，一篇《<a target="_blank" rel="noopener" href="https://github.com/iovisor/bcc/blob/master/docs/tutorial_bcc_python_developer.md">bcc Python 开发者教程</a>》，一篇《<a target="_blank" rel="noopener" href="https://github.com/iovisor/bcc/blob/master/docs/reference_guide.md">bcc&#x2F;BPF 参考手册</a>》，并提供了一些有用的<a target="_blank" rel="noopener" href="https://github.com/iovisor/bcc/tree/master/tools">工具</a>，每一个工具都有一个 <a target="_blank" rel="noopener" href="https://github.com/iovisor/bcc/tree/master/tools">example.txt</a> 文件和 <a target="_blank" rel="noopener" href="https://github.com/iovisor/bcc/tree/master/man/man8">man page</a>。我之前写过的关于 bcc 和 BPF 的文章有：</p><ul><li><a target="_blank" rel="noopener" href="http://www.brendangregg.com/blog/2015-05-15/ebpf-one-small-step.html">eBPF: One Small Step</a> （后来就叫做 BPF）</li><li><a target="_blank" rel="noopener" href="http://www.brendangregg.com/blog/2015-09-22/bcc-linux-4.3-tracing.html">bcc: Taming Linux 4.3+ Tracing Superpowers</a></li><li><a target="_blank" rel="noopener" href="http://www.brendangregg.com/blog/2016-01-18/ebpf-stack-trace-hack.html">Linux eBPF Stack Trace Hack</a> （现在官方支持追踪堆栈了）</li><li><a target="_blank" rel="noopener" href="http://www.brendangregg.com/blog/2016-01-20/ebpf-offcpu-flame-graph.html">Linux eBPF Off-CPU Flame Graph</a></li><li><a target="_blank" rel="noopener" href="http://www.brendangregg.com/blog/2016-02-01/linux-wakeup-offwake-profiling.html">Linux Wakeup and Off-Wake Profiling</a></li><li><a target="_blank" rel="noopener" href="http://www.brendangregg.com/blog/2016-02-05/ebpf-chaingraph-prototype.html">Linux Chain Graph Prototype</a></li><li><a target="_blank" rel="noopener" href="http://www.brendangregg.com/blog/2016-02-08/linux-ebpf-bcc-uprobes.html">Linux eBPF&#x2F;bcc uprobes</a></li><li><a target="_blank" rel="noopener" href="http://www.brendangregg.com/blog/2016-03-05/linux-bpf-superpowers.html">Linux BPF Superpowers</a></li><li><a target="_blank" rel="noopener" href="http://www.brendangregg.com/blog/2016-06-14/ubuntu-xenial-bcc-bpf.html">Ubuntu Xenial bcc&#x2F;BPF</a></li><li><a target="_blank" rel="noopener" href="http://www.brendangregg.com/blog/2016-10-01/linux-bcc-security-capabilities.html">Linux bcc Tracing Security Capabilities</a></li><li><a target="_blank" rel="noopener" href="http://www.brendangregg.com/blog/2016-10-04/linux-bcc-mysqld-qslower.html">Linux MySQL Slow Query Tracing with bcc&#x2F;BPF</a></li><li><a target="_blank" rel="noopener" href="http://www.brendangregg.com/blog/2016-10-06/linux-bcc-ext4dist-ext4slower.html">Linux bcc ext4 Latency Tracing</a></li><li><a target="_blank" rel="noopener" href="http://www.brendangregg.com/blog/2016-10-08/linux-bcc-runqlat.html">Linux bcc&#x2F;BPF Run Queue (Scheduler) Latency</a></li><li><a target="_blank" rel="noopener" href="http://www.brendangregg.com/blog/2016-10-12/linux-bcc-nodejs-usdt.html">Linux bcc&#x2F;BPF Node.js USDT Tracing</a></li><li><a target="_blank" rel="noopener" href="http://www.brendangregg.com/blog/2016-10-15/linux-bcc-tcptop.html">Linux bcc tcptop</a></li><li><a target="_blank" rel="noopener" href="http://www.brendangregg.com/blog/2016-10-21/linux-efficient-profiler.html">Linux 4.9’s Efficient BPF-based Profiler</a></li></ul><p>我在 Facebook 的 Performance@Scale <a target="_blank" rel="noopener" href="http://www.brendangregg.com/blog/2016-03-05/linux-bpf-superpowers.html">Linux BPF Superpowers</a> 大会上发表过一次演讲。十二月份，我将在 Boston 发表关于 BPF&#x2F;bcc 在 <a target="_blank" rel="noopener" href="https://www.usenix.org/conference/lisa16">USENIX LISA</a> 方面的演讲和教程。</p><h3 id="致谢"><a href="#致谢" class="headerlink" title="致谢"></a>致谢</h3><ul><li>Van Jacobson 和 Steve McCanne，他们创建了最初用作过滤器的 BPF 。</li><li>Barton P. Miller，Jeffrey K. Hollingsworth，and Jon Cargille，发明了动态追踪，并发表论文《Dynamic Program Instrumentation for Scalable Performance Tools》，可扩展高性能计算协议 （SHPCC），于田纳西州诺克斯维尔市，1994 年 5 月发表。</li><li>kerninst (ParaDyn, UW-Madison)，展示了动态跟踪的价值的早期动态跟踪工具（上世纪 90 年代后期）</li><li>Mathieu Desnoyers (在 LTTng)，内核的主要开发者，主导 tracepoints 项目。</li><li>IBM 开发的作为 DProbes 一部分的 kprobes，DProbes 在 2000 年时曾与 LTT 一起提供 Linux 动态追踪，但没有整合到一起。</li><li>Bryan Cantrill, Mike Shapiro, and Adam Leventhal (Sun Microsystems)，DTrace 的核心开发者，DTrace 是一款很棒的动态追踪工具，安全而且简单（2004 年）。对于动态追踪技术，DTrace 是科技的重要转折点：它很安全，默认安装在 Solaris 以及其它以可靠性著称的系统里。</li><li>来自 Sun Microsystems 的各部门的许多员工，促进了 DTrace，为我们带来了高级系统追踪的意识。</li><li>Roland McGrath (在 Red Hat)，utrace 项目的主要开发者，utrace 变成了后来的 uprobes。</li><li>Alexei Starovoitov (PLUMgrid， 后来是 Facebook)，加强版 BPF（可编程内核部件）的主要开发者。</li><li>那些帮助反馈、提交代码、测试以及针对增强版 BPF 补丁（请在 lkml 搜索 BPF）的 Linux 内核工程师： Wang Nan、 Daniel Borkmann、 David S. Miller、 Peter Zijlstra 以及其它很多人。</li><li>Brenden Blanco (PLUMgrid)，bcc 的主要开发者。</li><li>Sasha Goldshtein (Sela) 开发了 bcc 中的跟踪点支持，和功能最强大的 bcc 工具 trace 及 argdist，帮助 USDT 项目的开发。</li><li>Vicent Martí 和其它 Github 上的工程师，为 bcc 编写了基于 lua 的前端，帮助 USDT 部分项目的开发。</li><li>Allan McAleavy、 Mark Drayton，和其他的改进 bcc 的贡献者。</li></ul><p>感觉 Netflix 提供的环境和支持，让我能够编写 BPF 和 bcc 跟踪器并完成它们。我已经编写了多年的追踪工具（使用 TNF&#x2F;prex、DTrace、SystemTap、ktap、ftrace、perf，现在是 bcc&#x2F;BPF），并写书、博客以及评论，</p><p>最后，感谢 <a target="_blank" rel="noopener" href="http://www.brendangregg.com/blog/2016-07-23/deirdre.html">Deirdré</a> 编辑了另外一篇文章。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Linux 没有 DTrace（语言），但它现在有了，或者说拥有了 DTraceTookit（工具）。</p><p>通过增强内置的 BPF 引擎，Linux 4.9 内核拥有了用来支持现代化追踪的最后一项能力。内核支持这一最难的部分已经做完了。今后的任务包括更多的命令行执行工具，以及高级语言和图形用户界面。</p><p>对于性能分析产品的客户，这也是一件好事：你能查看延迟柱状图和热点图，CPU 处理和 CPU 之外的火焰图，拥有更好的时延断点和更低耗的工具。在用户空间按包跟踪和处理是没有效率的方式。</p><p>那么你什么时候会升级到 Linux 4.9 呢？一旦官方发布，新的性能测试工具就来了：<code>apt-get install bcc-tools</code> 。</p><p>开始享受它吧!</p><p>Brendan</p><hr><p>via: <a target="_blank" rel="noopener" href="http://www.brendangregg.com/blog/2016-10-27/dtrace-for-linux-2016.html">http://www.brendangregg.com/blog/2016-10-27/dtrace-for-linux-2016.html</a></p><p>作者：<a target="_blank" rel="noopener" href="http://www.brendangregg.com/">Brendan Gregg</a> 译者：<a target="_blank" rel="noopener" href="https://github.com/GitFuture">GitFuture</a> 校对：<a target="_blank" rel="noopener" href="https://github.com/wxy">wxy</a></p><p>本文由 <a target="_blank" rel="noopener" href="https://github.com/LCTT/TranslateProject">LCTT</a> 原创编译，<a target="_blank" rel="noopener" href="https://linux.cn/">Linux中国</a> 荣誉推出</p></div></div></div><div class="footer"><p class="footer-copyright"><span>Powered by <a target="_blank" href="https://hexo.io">Hexo</a></span> <span>Theme <a target="_blank" href="https://github.com/tinkink-co/hexo-theme-terminal">Terminal</a></span><script type="text/javascript" src="https://cdn.staticfile.net/jquery/3.4.1/jquery.min.js"></script><script>getCDNinfo=function(){$.ajax({url:"/cdn-cgi/trace",success:function(a,n){let i="Antananarivo, Madagascar - (TNR);Cape Town, South Africa - (CPT);Casablanca, Morocco - (CMN);Dar Es Salaam, Tanzania - (DAR);Djibouti City, Djibouti - (JIB);Durban, South Africa - (DUR);Johannesburg, South Africa - (JNB);Kigali, Rwanda - (KGL);Lagos, Nigeria - (LOS);Luanda, Angola - (LAD);Maputo, MZ - (MPM);Mombasa, Kenya - (MBA);Port Louis, Mauritius - (MRU);Réunion, France - (RUN);Bangalore, India - (BLR);Bangkok, Thailand - (BKK);Bandar Seri Begawan, Brunei - (BWN);Cebu, Philippines - (CEB);Chengdu, China - (CTU);Chennai, India - (MAA);Chittagong, Bangladesh - (CGP);Chongqing, China - (CKG);Colombo, Sri Lanka - (CMB);Dhaka, Bangladesh - (DAC);Dongguan, China - (SZX);Foshan, China - (FUO);Fuzhou, China - (FOC);Guangzhou, China - (CAN);Hangzhou, China - (HGH);Hanoi, Vietnam - (HAN);Hengyang, China - (HNY);Ho Chi Minh City, Vietnam - (SGN);Hong Kong - (HKG);Hyderabad, India - (HYD);Islamabad, Pakistan - (ISB);Jakarta, Indonesia - (CGK);Jinan, China - (TNA);Karachi, Pakistan - (KHI);Kathmandu, Nepal - (KTM);Kolkata, India - (CCU);Kuala Lumpur, Malaysia - (KUL);Lahore, Pakistan - (LHE);Langfang, China - (NAY);Luoyang, China - (LYA);Macau - (MFM);Malé, Maldives - (MLE);Manila, Philippines - (MNL);Mumbai, India - (BOM);Nagpur, India - (NAG);Nanning, China - (NNG);New Delhi, India - (DEL);Osaka, Japan - (KIX);Phnom Penh, Cambodia - (PNH);Qingdao, China - (TAO);Seoul, South Korea - (ICN);Shanghai, China - (SHA);Shenyang, China - (SHE);Shijiazhuang, China - (SJW);Singapore, Singapore - (SIN);Suzhou, China - (SZV);Taipei - (TPE);Thimphu, Bhutan - (PBH);Tianjin, China - (TSN);Tokyo, Japan - (NRT);Ulaanbaatar, Mongolia - (ULN);Vientiane, Laos - (VTE);Wuhan, China - (WUH);Wuxi, China - (WUX);Xi'an, China - (XIY);Yerevan, Armenia - (EVN);Zhengzhou, China - (CGO);Zuzhou, China - (CSX);Amsterdam, Netherlands - (AMS);Athens, Greece - (ATH);Barcelona, Spain - (BCN);Belgrade, Serbia - (BEG);Berlin, Germany - (TXL);Brussels, Belgium - (BRU);Bucharest, Romania - (OTP);Budapest, Hungary - (BUD);Chișinău, Moldova - (KIV);Copenhagen, Denmark - (CPH);Cork, Ireland -  (ORK);Dublin, Ireland - (DUB);Düsseldorf, Germany - (DUS);Edinburgh, United Kingdom - (EDI);Frankfurt, Germany - (FRA);Geneva, Switzerland - (GVA);Gothenburg, Sweden - (GOT);Hamburg, Germany - (HAM);Helsinki, Finland - (HEL);Istanbul, Turkey - (IST);Kyiv, Ukraine - (KBP);Lisbon, Portugal - (LIS);London, United Kingdom - (LHR);Luxembourg City, Luxembourg - (LUX);Madrid, Spain - (MAD);Manchester, United Kingdom - (MAN);Marseille, France - (MRS);Milan, Italy - (MXP);Moscow, Russia - (DME);Munich, Germany - (MUC);Nicosia, Cyprus - (LCA);Oslo, Norway - (OSL);Paris, France - (CDG);Prague, Czech Republic - (PRG);Reykjavík, Iceland - (KEF);Riga, Latvia - (RIX);Rome, Italy - (FCO);Saint Petersburg, Russia - (LED);Sofia, Bulgaria - (SOF);Stockholm, Sweden - (ARN);Tallinn, Estonia - (TLL);Thessaloniki, Greece - (SKG);Vienna, Austria - (VIE);Vilnius, Lithuania - (VNO);Warsaw, Poland - (WAW);Zagreb, Croatia - (ZAG);Zürich, Switzerland - (ZRH);Arica, Chile - (ARI);Asunción, Paraguay - (ASU);Bogotá, Colombia - (BOG);Buenos Aires, Argentina - (EZE);Curitiba, Brazil - (CWB);Fortaleza, Brazil - (FOR);Guatemala City, Guatemala - (GUA);Lima, Peru - (LIM);Medellín, Colombia - (MDE);Panama City, Panama - (PTY);Porto Alegre, Brazil - (POA);Quito, Ecuador - (UIO);Rio de Janeiro, Brazil - (GIG);São Paulo, Brazil - (GRU);Santiago, Chile - (SCL);Willemstad, Curaçao - (CUR);St. George's, Grenada - (GND);Amman, Jordan - (AMM);Baghdad, Iraq - (BGW);Baku, Azerbaijan - (GYD);Beirut, Lebanon - (BEY);Doha, Qatar - (DOH);Dubai, United Arab Emirates - (DXB);Kuwait City, Kuwait - (KWI);Manama, Bahrain - (BAH);Muscat, Oman - (MCT);Ramallah - (ZDM);Riyadh, Saudi Arabia - (RUH);Tel Aviv, Israel - (TLV);Ashburn, VA, United States - (IAD);Atlanta, GA, United States - (ATL);Boston, MA, United States - (BOS);Buffalo, NY, United States - (BUF);Calgary, AB, Canada - (YYC);Charlotte, NC, United States - (CLT);Chicago, IL, United States - (ORD);Columbus, OH, United States - (CMH);Dallas, TX, United States - (DFW);Denver, CO, United States - (DEN);Detroit, MI, United States - (DTW);Honolulu, HI, United States - (HNL);Houston, TX, United States - (IAH);Indianapolis, IN, United States - (IND);Jacksonville, FL, United States - (JAX);Kansas City, MO, United States - (MCI);Las Vegas, NV, United States - (LAS);Los Angeles, CA, United States - (LAX);McAllen, TX, United States - (MFE);Memphis, TN, United States - (MEM);Mexico City, Mexico - (MEX);Miami, FL, United States - (MIA);Minneapolis, MN, United States - (MSP);Montgomery, AL, United States - (MGM);Montréal, QC, Canada - (YUL);Nashville, TN, United States - (BNA);Newark, NJ, United States - (EWR);Norfolk, VA, United States - (ORF);Omaha, NE, United States - (OMA);Philadelphia, United States - (PHL);Phoenix, AZ, United States - (PHX);Pittsburgh, PA, United States - (PIT);Port-Au-Prince, Haiti - (PAP);Portland, OR, United States - (PDX);Queretaro, MX, Mexico - (QRO);Richmond, Virginia - (RIC);Sacramento, CA, United States - (SMF);Salt Lake City, UT, United States - (SLC);San Diego, CA, United States - (SAN);San Jose, CA, United States - (SJC);Saskatoon, SK, Canada - (YXE);Seattle, WA, United States - (SEA);St. Louis, MO, United States - (STL);Tampa, FL, United States - (TPA);Toronto, ON, Canada - (YYZ);Vancouver, BC, Canada - (YVR);Tallahassee, FL, United States - (TLH);Winnipeg, MB, Canada - (YWG);Adelaide, SA, Australia - (ADL);Auckland, New Zealand - (AKL);Brisbane, QLD, Australia - (BNE);Melbourne, VIC, Australia - (MEL);Noumea, New caledonia - (NOU);Perth, WA, Australia - (PER);Sydney, NSW, Australia - (SYD)".split(";"),e=a.split("colo=")[1].split("\n")[0],t=(a.split("colo=")[1].split("\n")[0],a.split("tls=")[1].split("\n")[0]),o=a.split("http=")[1].split("\n")[0],s=a.split("sni=")[1].split("\n")[0],r=a.split("ip=")[1].split("\n")[0],l=a.split("uag=")[1].split("\n")[0];for(var d=0;d<i.length;d++)if(-1!=i[d].indexOf(e)){document.getElementById("cdn").innerHTML=i[d];break}document.getElementById("tls").innerHTML=t,document.getElementById("http").innerHTML=o,document.getElementById("sni").innerHTML=s,document.getElementById("ip").innerHTML=r,document.getElementById("useragent").innerHTML=l}})},$(document).ready((function(){getCDNinfo()}))</script></p><p style="text-align:center">感谢陪伴与布道，开源之火不灭。​</p><p style="text-align:center"><script>document.write("本次加载耗时: "+(performance.getEntriesByType("navigation").reduce((e,r)=>e+r.responseEnd-r.startTime,0)+performance.getEntriesByType("resource").reduce((e,r)=>e+r.responseEnd-r.startTime,0)).toFixed(0)+"ms")</script></p><p style="text-align:center">当前 SNI 状态： <span id="sni">正在统计！或可能被浏览器防追踪拦截！</span></p><p style="text-align:center">当前 TLS 版本： <span id="tls">正在统计！或可能被浏览器防追踪拦截！</span></p><p style="text-align:center">当前 HTTP 版本： <span id="http">正在统计！或可能被浏览器防追踪拦截！</span></p><p style="text-align:center">当前您的客户端 IP 是： <span id="ip">正在统计！或可能被浏览器防追踪拦截！</span></p><p style="text-align:center">当前分配的 CDN 节点是: <span id="cdn">正在统计！或可能被浏览器防追踪拦截！</span></p><p style="text-align:center">您的 UserAgent 信息是: <span id="useragent">正在统计！或可能被浏览器防追踪拦截！</span></p><p></p></div></div></body></html>