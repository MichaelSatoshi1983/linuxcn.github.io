<!doctype html><html lang="en"><head><meta name="msvalidate.01" content="D404690CEFCB54C7762AC84935B99171"><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?6618da70c90c8744eead2e9371fb5077";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><script type="text/javascript">!function(t,e,n,c,s,a,r){t[n]=t[n]||function(){(t[n].q=t[n].q||[]).push(arguments)},(a=e.createElement(c)).async=1,a.src="https://www.clarity.ms/tag/s5f3f0tojf",(r=e.getElementsByTagName(c)[0]).parentNode.insertBefore(a,r)}(window,document,"clarity","script")</script><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta http-equiv="X-UA-Compatible" content="ie=edge"><link rel="stylesheet" href="/styles/base.css"><link rel="stylesheet" href="/styles/theme.css"><link rel="shortcut icon" href="/favicon.png"><title>C++ 程序员 Protocol Buffers 基础指南 - 归墟星火集</title><meta name="generator" content="Hexo 7.3.0"></head><body><div class="header-title"><span class="header-light"></span> <span class="header-light"></span> <span class="header-light"></span> <span>归墟星火集 linuxcn.undefined.today<span></span></span></div><div class="container"><ul class="nav"><li><a href="/">首页</a></li><li><a href="/about/">关于</a></li><li><a target="_blank" rel="noopener" href="https://undefined.today/">Blog</a></li></ul><div class="content"><div class="post-container"><div class="post-header"><span class="ui-tips">标题：</span><h1 class="ui-keyword post-title">C++ 程序员 Protocol Buffers 基础指南</h1><span class="post-date">2016-11-04</span></div><div class="post-header"><span class="ui-tips">分类：</span> <a href="/categories/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/">软件开发</a></div><div class="post-header"><span class="ui-tips">标签：</span> <a href="/tags/C/">C++</a> <a href="/tags/XML/">XML</a> <a href="/tags/Protocol-Buffers/">Protocol Buffers</a></div><div class="post-content"><p>这篇教程提供了一个面向 C++ 程序员关于 protocol buffers 的基础介绍。通过创建一个简单的示例应用程序，它将向我们展示：</p><ul><li>在 <code>.proto</code> 文件中定义消息格式</li><li>使用 protocol buffer 编译器</li><li>使用 C++ protocol buffer API 读写消息</li></ul><p>这不是一个关于在 C++ 中使用 protocol buffers 的全面指南。要获取更详细的信息，请参考 <a target="_blank" rel="noopener" href="https://developers.google.com/protocol-buffers/docs/proto">Protocol Buffer Language Guide</a> 和 <a target="_blank" rel="noopener" href="https://developers.google.com/protocol-buffers/docs/encoding">Encoding Reference</a>。</p><h3 id="为什么使用-Protocol-Buffers"><a href="#为什么使用-Protocol-Buffers" class="headerlink" title="为什么使用 Protocol Buffers"></a>为什么使用 Protocol Buffers</h3><p>我们接下来要使用的例子是一个非常简单的”地址簿”应用程序，它能从文件中读取联系人详细信息。地址簿中的每一个人都有一个名字、ID、邮件地址和联系电话。</p><p>如何序列化和获取结构化的数据？这里有几种解决方案：</p><ul><li>以二进制形式发送&#x2F;接收原生的内存数据结构。通常，这是一种脆弱的方法，因为接收&#x2F;读取代码必须基于完全相同的内存布局、大小端等环境进行编译。同时，当文件增加时，原始格式数据会随着与该格式相关的软件而迅速扩散，这将导致很难扩展文件格式。</li><li>你可以创造一种 ad-hoc 方法，将数据项编码为一个字符串——比如将 4 个整数编码为 <code>12:3:-23:67</code>。虽然它需要编写一次性的编码和解码代码且解码需要耗费一点运行时成本，但这是一种简单灵活的方法。这最适合编码非常简单的数据。</li><li>序列化数据为 XML。这种方法是非常吸引人的，因为 XML 是一种适合人阅读的格式，并且有为许多语言开发的库。如果你想与其他程序和项目共享数据，这可能是一种不错的选择。然而，众所周知，XML 是空间密集型的，且在编码和解码时，它对程序会造成巨大的性能损失。同时，使用 XML DOM 树被认为比操作一个类的简单字段更加复杂。</li></ul><p>Protocol buffers 是针对这个问题的一种灵活、高效、自动化的解决方案。使用 Protocol buffers，你需要写一个 <code>.proto</code> 说明，用于描述你所希望存储的数据结构。利用 <code>.proto</code> 文件，protocol buffer 编译器可以创建一个类，用于实现对高效的二进制格式的 protocol buffer 数据的自动化编码和解码。产生的类提供了构造 protocol buffer 的字段的 getters 和 setters，并且作为一个单元来处理读写 protocol buffer 的细节。重要的是，protocol buffer 格式支持格式的扩展，代码仍然可以读取以旧格式编码的数据。</p><p><img src="https://linuxcn.img.undefined.today/data/attachment/album/201611/03/235451klrr358u5pz8trxu.png"></p><h3 id="在哪可以找到示例代码"><a href="#在哪可以找到示例代码" class="headerlink" title="在哪可以找到示例代码"></a>在哪可以找到示例代码</h3><p>示例代码被包含于源代码包，位于“examples”文件夹。可在<a target="_blank" rel="noopener" href="https://developers.google.com/protocol-buffers/docs/downloads.html">这里</a>下载代码。</p><h3 id="定义你的协议格式"><a href="#定义你的协议格式" class="headerlink" title="定义你的协议格式"></a>定义你的协议格式</h3><p>为了创建自己的地址簿应用程序，你需要从 <code>.proto</code> 开始。<code>.proto</code> 文件中的定义很简单：为你所需要序列化的每个数据结构添加一个<ruby>消息 <rp>（ </rp><rt>message</rt> <rp>）</rp></ruby>，然后为消息中的每一个字段指定一个名字和类型。这里是定义你消息的 <code>.proto</code> 文件 <code>addressbook.proto</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">package tutorial;</span><br><span class="line"></span><br><span class="line">message Person &#123;</span><br><span class="line">  required string name = 1;</span><br><span class="line">  required int32 id = 2;</span><br><span class="line">  optional string email = 3;</span><br><span class="line"></span><br><span class="line">  enum PhoneType &#123;</span><br><span class="line">    MOBILE = 0;</span><br><span class="line">    HOME = 1;</span><br><span class="line">    WORK = 2;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  message PhoneNumber &#123;</span><br><span class="line">    required string number = 1;</span><br><span class="line">    optional PhoneType type = 2 [default = HOME];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  repeated PhoneNumber phone = 4;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message AddressBook &#123;</span><br><span class="line">  repeated Person person = 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如你所见，其语法类似于 C++ 或 Java。我们开始看看文件的每一部分内容做了什么。</p><p><code>.proto</code> 文件以一个 <code>package</code> 声明开始，这可以避免不同项目的命名冲突。在 C++，你生成的类会被置于与 <code>package</code> 名字一样的命名空间。</p><p>下一步，你需要定义<ruby>消息 <rp>（ </rp><rt>message</rt> <rp>）</rp></ruby>。消息只是一个包含一系列类型字段的集合。大多标准的简单数据类型是可以作为字段类型的，包括 <code>bool</code>、<code>int32</code>、<code>float</code>、<code>double</code> 和 <code>string</code>。你也可以通过使用其他消息类型作为字段类型，将更多的数据结构添加到你的消息中——在以上的示例，<code>Person</code> 消息包含了 <code>PhoneNumber</code> 消息，同时 <code>AddressBook</code> 消息包含 <code>Person</code> 消息。你甚至可以定义嵌套在其他消息内的消息类型——如你所见，<code>PhoneNumber</code> 类型定义于 <code>Person</code> 内部。如果你想要其中某一个字段的值是预定义值列表中的某个值，你也可以定义 <code>enum</code> 类型——这儿你可以指定一个电话号码是 <code>MOBILE</code>、<code>HOME</code> 或 <code>WORK</code> 中的某一个。</p><p>每一个元素上的 <code>= 1</code>、<code>= 2</code> 标记确定了用于二进制编码的唯一<ruby>“标签” <rp>（ </rp><rt>tag</rt> <rp>）</rp></ruby>。标签数字 1-15 的编码比更大的数字少需要一个字节，因此作为一种优化，你可以将这些标签用于经常使用的元素或 <code>repeated</code> 元素，剩下 16 以及更高的标签用于非经常使用的元素或 <code>optional</code> 元素。每一个 <code>repeated</code> 字段的元素需要重新编码标签数字，因此 <code>repeated</code> 字段适合于使用这种优化手段。</p><p>每一个字段必须使用下面的修饰符加以标注：</p><ul><li><code>required</code>：必须提供该字段的值，否则消息会被认为是<ruby>“未初始化的” <rp>（ </rp><rt>uninitialized</rt> <rp>）</rp></ruby>。如果 <code>libprotobuf</code> 以调试模式编译，序列化未初始化的消息将引起一个断言失败。以优化形式构建，将会跳过检查，并且无论如何都会写入该消息。然而，解析未初始化的消息总是会失败（通过 <code>parse</code> 方法返回 <code>false</code>）。除此之外，一个 <code>required</code> 字段的表现与 <code>optional</code> 字段完全一样。</li><li><code>optional</code>：字段可能会被设置，也可能不会。如果一个 <code>optional</code> 字段没被设置，它将使用默认值。对于简单类型，你可以指定你自己的默认值，正如例子中我们对电话号码的 <code>type</code> 一样，否则使用系统默认值：数字类型为 0、字符串为空字符串、布尔值为 false。对于嵌套消息，默认值总为消息的“默认实例”或“原型”，它的所有字段都没被设置。调用 accessor 来获取一个没有显式设置的 <code>optional</code>（或 <code>required</code>） 字段的值总是返回字段的默认值。</li><li><code>repeated</code>：字段可以重复任意次数（包括 0 次）。<code>repeated</code> 值的顺序会被保存于 protocol buffer。可以将 <code>repeated</code> 字段想象为动态大小的数组。</li></ul><p>你可以查找关于编写 <code>.proto</code> 文件的完整指导——包括所有可能的字段类型——在 <a target="_blank" rel="noopener" href="https://developers.google.com/protocol-buffers/docs/proto">Protocol Buffer Language Guide</a> 里面。不要在这里面查找与类继承相似的特性，因为 protocol buffers 不会做这些。</p><blockquote><p><strong><code>required</code> 是永久性的</strong></p><p>在把一个字段标识为 <code>required</code> 的时候，你应该特别小心。如果在某些情况下你不想写入或者发送一个 <code>required</code> 的字段，那么将该字段更改为 <code>optional</code> 可能会遇到问题——旧版本的读者（LCTT 译注：即读取、解析旧版本 Protocol Buffer 消息的一方）会认为不含该字段的消息是不完整的，从而有可能会拒绝解析。在这种情况下，你应该考虑编写特别针对于应用程序的、自定义的消息校验函数。Google 的一些工程师得出了一个结论：使用 <code>required</code> 弊多于利；他们更愿意使用 <code>optional</code> 和 <code>repeated</code> 而不是 <code>required</code>。当然，这个观点并不具有普遍性。</p></blockquote><h3 id="编译你的-Protocol-Buffers"><a href="#编译你的-Protocol-Buffers" class="headerlink" title="编译你的 Protocol Buffers"></a>编译你的 Protocol Buffers</h3><p>既然你有了一个 <code>.proto</code>，那你需要做的下一件事就是生成一个将用于读写 <code>AddressBook</code> 消息的类（从而包括 <code>Person</code> 和 <code>PhoneNumber</code>）。为了做到这样，你需要在你的 <code>.proto</code> 上运行 protocol buffer 编译器 <code>protoc</code>：</p><ol><li>如果你没有安装编译器，请<a target="_blank" rel="noopener" href="https://developers.google.com/protocol-buffers/docs/downloads.html">下载这个包</a>，并按照 README 中的指令进行安装。</li><li>现在运行编译器，指定源目录（你的应用程序源代码位于哪里——如果你没有提供任何值，将使用当前目录）、目标目录（你想要生成的代码放在哪里；常与 <code>$SRC_DIR</code> 相同），以及你的 <code>.proto</code> 路径。在此示例中：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">protoc -I=$SRC_DIR --cpp_out=$DST_DIR $SRC_DIR/addressbook.proto</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>因为你想要 C++ 的类，所以你使用了 <code>--cpp_out</code> 选项——也为其他支持的语言提供了类似选项。</p><p>在你指定的目标文件夹，将生成以下的文件：</p><ul><li><code>addressbook.pb.h</code>，声明你生成类的头文件。</li><li><code>addressbook.pb.cc</code>，包含你的类的实现。</li></ul><h3 id="Protocol-Buffer-API"><a href="#Protocol-Buffer-API" class="headerlink" title="Protocol Buffer API"></a>Protocol Buffer API</h3><p>让我们看看生成的一些代码，了解一下编译器为你创建了什么类和函数。如果你查看 <code>addressbook.pb.h</code>，你可以看到有一个在 <code>addressbook.proto</code> 中指定所有消息的类。关注 <code>Person</code> 类，可以看到编译器为每个字段生成了<ruby>读写函数 <rp>（ </rp><rt>accessors</rt> <rp>）</rp></ruby>。例如，对于 <code>name</code>、<code>id</code>、<code>email</code> 和 <code>phone</code> 字段，有下面这些方法：（LCTT 译注：此处原文所指文件名有误，径该之。）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">// name</span><br><span class="line">inline bool has_name() const;</span><br><span class="line">inline void clear_name();</span><br><span class="line">inline const ::std::string&amp; name() const;</span><br><span class="line">inline void set_name(const ::std::string&amp; value);</span><br><span class="line">inline void set_name(const char* value);</span><br><span class="line">inline ::std::string* mutable_name();</span><br><span class="line"></span><br><span class="line">// id</span><br><span class="line">inline bool has_id() const;</span><br><span class="line">inline void clear_id();</span><br><span class="line">inline int32_t id() const;</span><br><span class="line">inline void set_id(int32_t value);</span><br><span class="line"></span><br><span class="line">// email</span><br><span class="line">inline bool has_email() const;</span><br><span class="line">inline void clear_email();</span><br><span class="line">inline const ::std::string&amp; email() const;</span><br><span class="line">inline void set_email(const ::std::string&amp; value);</span><br><span class="line">inline void set_email(const char* value);</span><br><span class="line">inline ::std::string* mutable_email();</span><br><span class="line"></span><br><span class="line">// phone</span><br><span class="line">inline int phone_size() const;</span><br><span class="line">inline void clear_phone();</span><br><span class="line">inline const ::google::protobuf::RepeatedPtrField&lt; ::tutorial::Person_PhoneNumber &gt;&amp; phone() const;</span><br><span class="line">inline ::google::protobuf::RepeatedPtrField&lt; ::tutorial::Person_PhoneNumber &gt;* mutable_phone();</span><br><span class="line">inline const ::tutorial::Person_PhoneNumber&amp; phone(int index) const;</span><br><span class="line">inline ::tutorial::Person_PhoneNumber* mutable_phone(int index);</span><br><span class="line">inline ::tutorial::Person_PhoneNumber* add_phone();</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>正如你所见到，getters 的名字与字段的小写名字完全一样，并且 setter 方法以 <code>set_</code> 开头。同时每个<ruby>单一 <rp>（ </rp><rt>singular</rt> <rp>）</rp></ruby>（<code>required</code> 或 <code>optional</code>）字段都有 <code>has_</code> 方法，该方法在字段被设置了值的情况下返回 true。最后，所有字段都有一个 <code>clear_</code> 方法，用以清除字段到<ruby>空 <rp>（ </rp><rt>empty</rt> <rp>）</rp></ruby>状态。</p><p>数字型的 <code>id</code> 字段仅有上述的基本<ruby>读写函数 <rp>（ </rp><rt>accessors</rt> <rp>）</rp></ruby>集合，而 <code>name</code> 和 <code>email</code> 字段有两个额外的方法，因为它们是字符串——一个是可以获得字符串直接指针的<code>mutable_</code> 的 getter ，另一个为额外的 setter。注意，尽管 <code>email</code> 还没被<ruby>设置 <rp>（ </rp><rt>set</rt> <rp>）</rp></ruby>，你也可以调用 <code>mutable_email</code>；因为 <code>email</code> 会被自动地初始化为空字符串。在本例中，如果你有一个单一的（<code>required</code> 或 <code>optional</code>）消息字段，它会有一个 <code>mutable_</code> 方法，而没有 <code>set_</code> 方法。</p><p><code>repeated</code> 字段也有一些特殊的方法——如果你看看 <code>repeated</code> 的 <code>phone</code> 字段的方法，你可以看到：</p><ul><li>检查 <code>repeated</code> 字段的 <code>_size</code>（也就是说，与 <code>Person</code> 相关的电话号码的个数）</li><li>使用下标取得特定的电话号码</li><li>更新特定下标的电话号码</li><li>添加新的电话号码到消息中，之后你便可以编辑。（<code>repeated</code> 标量类型有一个 <code>add_</code> 方法，用于传入新的值）</li></ul><p>为了获取 protocol 编译器为所有字段定义生成的方法的信息，可以查看 <a target="_blank" rel="noopener" href="https://developers.google.com/protocol-buffers/docs/reference/cpp-generated">C++ generated code reference</a>。</p><h4 id="枚举和嵌套类"><a href="#枚举和嵌套类" class="headerlink" title="枚举和嵌套类"></a>枚举和嵌套类</h4><p>与 <code>.proto</code> 的枚举相对应，生成的代码包含了一个 <code>PhoneType</code> 枚举。你可以通过 <code>Person::PhoneType</code> 引用这个类型，通过 <code>Person::MOBILE</code>、<code>Person::HOME</code> 和 <code>Person::WORK</code> 引用它的值。（实现细节有点复杂，但是你无须了解它们而可以直接使用）</p><p>编译器也生成了一个 <code>Person::PhoneNumber</code> 的嵌套类。如果你查看代码，你可以发现真正的类型为 <code>Person_PhoneNumber</code>，但它通过在 <code>Person</code> 内部使用 <code>typedef</code> 定义，使你可以把 <code>Person_PhoneNumber</code> 当成嵌套类。唯一产生影响的一个例子是，如果你想要在其他文件前置声明该类——在 C++ 中你不能前置声明嵌套类，但是你可以前置声明 <code>Person_PhoneNumber</code>。</p><h4 id="标准的消息方法"><a href="#标准的消息方法" class="headerlink" title="标准的消息方法"></a>标准的消息方法</h4><p>所有的消息方法都包含了许多别的方法，用于检查和操作整个消息，包括：</p><ul><li><code>bool IsInitialized() const;</code> ：检查是否所有 <code>required</code> 字段已经被设置。</li><li><code>string DebugString() const;</code> ：返回人类可读的消息表示，对调试特别有用。</li><li><code>void CopyFrom(const Person&amp; from);</code>：使用给定的值重写消息。</li><li><code>void Clear();</code>：清除所有元素为空的状态。</li></ul><p>上面这些方法以及下一节要讲的 I&#x2F;O 方法实现了被所有 C++ protocol buffer 类共享的<ruby>消息 <rp>（ </rp><rt>Message</rt> <rp>）</rp></ruby>接口。为了获取更多信息，请查看 <a target="_blank" rel="noopener" href="https://developers.google.com/protocol-buffers/docs/reference/cpp/google.protobuf.message.html#Message">complete API documentation for Message</a>。</p><h4 id="解析和序列化"><a href="#解析和序列化" class="headerlink" title="解析和序列化"></a>解析和序列化</h4><p>最后，所有 protocol buffer 类都有读写你选定类型消息的方法，这些方法使用了特定的 protocol buffer <a target="_blank" rel="noopener" href="https://developers.google.com/protocol-buffers/docs/encoding">二进制格式</a>。这些方法包括：</p><ul><li><code>bool SerializeToString(string* output) const;</code>：序列化消息并将消息字节数据存储在给定的字符串中。注意，字节数据是二进制格式的，而不是文本格式；我们只使用 <code>string</code> 类作为合适的容器。</li><li><code>bool ParseFromString(const string&amp; data);</code>：从给定的字符创解析消息。</li><li><code>bool SerializeToOstream(ostream* output) const;</code>：将消息写到给定的 C++ <code>ostream</code>。</li><li><code>bool ParseFromIstream(istream* input);</code>：从给定的 C++ <code>istream</code> 解析消息。</li></ul><p>这些只是两个用于解析和序列化的选择。再次说明，可以查看 <code>Message API reference</code> 完整的列表。</p><blockquote><p><strong>Protocol Buffers 和面向对象设计</strong></p><p>Protocol buffer 类通常只是纯粹的数据存储器（像 C++ 中的结构体）；它们在对象模型中并不是一等公民。如果你想向生成的 protocol buffer 类中添加更丰富的行为，最好的方法就是在应用程序中对它进行封装。如果你无权控制 <code>.proto</code> 文件的设计的话，封装 protocol buffers 也是一个好主意（例如，你从另一个项目中重用一个 <code>.proto</code> 文件）。在那种情况下，你可以用封装类来设计接口，以更好地适应你的应用程序的特定环境：隐藏一些数据和方法，暴露一些便于使用的函数，等等。**但是你绝对不要通过继承生成的类来添加行为。**这样做的话，会破坏其内部机制，并且不是一个好的面向对象的实践。</p></blockquote><h3 id="写消息"><a href="#写消息" class="headerlink" title="写消息"></a>写消息</h3><p>现在我们尝试使用 protocol buffer 类。你的地址簿程序想要做的第一件事是将个人详细信息写入到地址簿文件。为了做到这一点，你需要创建、填充 protocol buffer 类实例，并且将它们写入到一个<ruby>输出流 <rp>（ </rp><rt>output stream</rt> <rp>）</rp></ruby>。</p><p>这里的程序可以从文件读取 <code>AddressBook</code>，根据用户输入，将新 <code>Person</code> 添加到 <code>AddressBook</code>，并且再次将新的 <code>AddressBook</code> 写回文件。这部分直接调用或引用 protocol buffer 类的代码会以“<code>// pb</code>”标出。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;fstream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &quot;addressbook.pb.h&quot; // pb</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">// This function fills in a Person message based on user input.</span><br><span class="line">void PromptForAddress(tutorial::Person* person) &#123;</span><br><span class="line">  cout &lt;&lt; &quot;Enter person ID number: &quot;;</span><br><span class="line">  int id;</span><br><span class="line">  cin &gt;&gt; id;</span><br><span class="line">  person-&gt;set_id(id);   // pb</span><br><span class="line">  cin.ignore(256, &#x27;\n&#x27;);</span><br><span class="line"></span><br><span class="line">  cout &lt;&lt; &quot;Enter name: &quot;;</span><br><span class="line">  getline(cin, *person-&gt;mutable_name());    // pb</span><br><span class="line"></span><br><span class="line">  cout &lt;&lt; &quot;Enter email address (blank for none): &quot;;</span><br><span class="line">  string email;</span><br><span class="line">  getline(cin, email);</span><br><span class="line">  if (!email.empty()) &#123; // pb</span><br><span class="line">    person-&gt;set_email(email);   // pb</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  while (true) &#123;</span><br><span class="line">    cout &lt;&lt; &quot;Enter a phone number (or leave blank to finish): &quot;;</span><br><span class="line">    string number;</span><br><span class="line">    getline(cin, number);</span><br><span class="line">    if (number.empty()) &#123;</span><br><span class="line">      break;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tutorial::Person::PhoneNumber* phone_number = person-&gt;add_phone();  //pb</span><br><span class="line">    phone_number-&gt;set_number(number);   // pb</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; &quot;Is this a mobile, home, or work phone? &quot;;</span><br><span class="line">    string type;</span><br><span class="line">    getline(cin, type);</span><br><span class="line">    if (type == &quot;mobile&quot;) &#123;</span><br><span class="line">      phone_number-&gt;set_type(tutorial::Person::MOBILE); // pb</span><br><span class="line">    &#125; else if (type == &quot;home&quot;) &#123;</span><br><span class="line">      phone_number-&gt;set_type(tutorial::Person::HOME);   // pb</span><br><span class="line">    &#125; else if (type == &quot;work&quot;) &#123;</span><br><span class="line">      phone_number-&gt;set_type(tutorial::Person::WORK);   // pb</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      cout &lt;&lt; &quot;Unknown phone type.  Using default.&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Main function:  Reads the entire address book from a file,</span><br><span class="line">//   adds one person based on user input, then writes it back out to the same</span><br><span class="line">//   file.</span><br><span class="line">int main(int argc, char* argv[]) &#123;</span><br><span class="line">  // Verify that the version of the library that we linked against is</span><br><span class="line">  // compatible with the version of the headers we compiled against.</span><br><span class="line">  GOOGLE_PROTOBUF_VERIFY_VERSION;   // pb</span><br><span class="line"></span><br><span class="line">  if (argc != 2) &#123;</span><br><span class="line">    cerr &lt;&lt; &quot;Usage:  &quot; &lt;&lt; argv[0] &lt;&lt; &quot; ADDRESS_BOOK_FILE&quot; &lt;&lt; endl;</span><br><span class="line">    return -1;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  tutorial::AddressBook address_book;   // pb</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line">    // Read the existing address book.</span><br><span class="line">    fstream input(argv[1], ios::in | ios::binary);</span><br><span class="line">    if (!input) &#123;</span><br><span class="line">      cout &lt;&lt; argv[1] &lt;&lt; &quot;: File not found.  Creating a new file.&quot; &lt;&lt; endl;</span><br><span class="line">    &#125; else if (!address_book.ParseFromIstream(&amp;input)) &#123;    // pb</span><br><span class="line">      cerr &lt;&lt; &quot;Failed to parse address book.&quot; &lt;&lt; endl;</span><br><span class="line">      return -1;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // Add an address.</span><br><span class="line">  PromptForAddress(address_book.add_person());  // pb</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line">    // Write the new address book back to disk.</span><br><span class="line">    fstream output(argv[1], ios::out | ios::trunc | ios::binary);</span><br><span class="line">    if (!address_book.SerializeToOstream(&amp;output)) &#123;    // pb</span><br><span class="line">      cerr &lt;&lt; &quot;Failed to write address book.&quot; &lt;&lt; endl;</span><br><span class="line">      return -1;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // Optional:  Delete all global objects allocated by libprotobuf.</span><br><span class="line">  google::protobuf::ShutdownProtobufLibrary();  // pb</span><br><span class="line"></span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>注意 <code>GOOGLE_PROTOBUF_VERIFY_VERSION</code> 宏。它是一种好的实践——虽然不是严格必须的——在使用 C++ Protocol Buffer 库之前执行该宏。它可以保证避免不小心链接到一个与编译的头文件版本不兼容的库版本。如果被检查出来版本不匹配，程序将会终止。注意，每个 <code>.pb.cc</code> 文件在初始化时会自动调用这个宏。</p><p>同时注意在程序最后调用 <code>ShutdownProtobufLibrary()</code>。它用于释放 Protocol Buffer 库申请的所有全局对象。对大部分程序，这不是必须的，因为虽然程序只是简单退出，但是 OS 会处理释放程序的所有内存。然而，如果你使用了内存泄漏检测工具，工具要求全部对象都要释放，或者你正在写一个 Protocol Buffer 库，该库可能会被一个进程多次加载和卸载，那么你可能需要强制 Protocol Buffer 清除所有东西。</p><h3 id="读取消息"><a href="#读取消息" class="headerlink" title="读取消息"></a>读取消息</h3><p>当然，如果你无法从它获取任何信息，那么这个地址簿没多大用处！这个示例读取上面例子创建的文件，并打印文件里的所有内容。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;fstream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &quot;addressbook.pb.h&quot; // pb</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">// Iterates though all people in the AddressBook and prints info about them.</span><br><span class="line">void ListPeople(const tutorial::AddressBook&amp; address_book) &#123;    // pb</span><br><span class="line">  for (int i = 0; i &lt; address_book.person_size(); i++) &#123;        // pb</span><br><span class="line">    const tutorial::Person&amp; person = address_book.person(i);    // pb</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; &quot;Person ID: &quot; &lt;&lt; person.id() &lt;&lt; endl;   // pb</span><br><span class="line">    cout &lt;&lt; &quot;  Name: &quot; &lt;&lt; person.name() &lt;&lt; endl;    // pb</span><br><span class="line">    if (person.has_email()) &#123;   // pb</span><br><span class="line">      cout &lt;&lt; &quot;  E-mail address: &quot; &lt;&lt; person.email() &lt;&lt; endl;   // pb</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (int j = 0; j &lt; person.phone_size(); j++) &#123; // pb</span><br><span class="line">      const tutorial::Person::PhoneNumber&amp; phone_number = person.phone(j);  // pb</span><br><span class="line"></span><br><span class="line">      switch (phone_number.type()) &#123;    // pb</span><br><span class="line">        case tutorial::Person::MOBILE:  // pb</span><br><span class="line">          cout &lt;&lt; &quot;  Mobile phone #: &quot;;</span><br><span class="line">          break;</span><br><span class="line">        case tutorial::Person::HOME:    // pb</span><br><span class="line">          cout &lt;&lt; &quot;  Home phone #: &quot;;</span><br><span class="line">          break;</span><br><span class="line">        case tutorial::Person::WORK:    // pb</span><br><span class="line">          cout &lt;&lt; &quot;  Work phone #: &quot;;</span><br><span class="line">          break;</span><br><span class="line">      &#125;</span><br><span class="line">      cout &lt;&lt; phone_number.number() &lt;&lt; endl;    // ob</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Main function:  Reads the entire address book from a file and prints all</span><br><span class="line">//   the information inside.</span><br><span class="line">int main(int argc, char* argv[]) &#123;</span><br><span class="line">  // Verify that the version of the library that we linked against is</span><br><span class="line">  // compatible with the version of the headers we compiled against.</span><br><span class="line">  GOOGLE_PROTOBUF_VERIFY_VERSION;   // pb</span><br><span class="line"></span><br><span class="line">  if (argc != 2) &#123;</span><br><span class="line">    cerr &lt;&lt; &quot;Usage:  &quot; &lt;&lt; argv[0] &lt;&lt; &quot; ADDRESS_BOOK_FILE&quot; &lt;&lt; endl;</span><br><span class="line">    return -1;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  tutorial::AddressBook address_book;   // pb</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line">    // Read the existing address book.</span><br><span class="line">    fstream input(argv[1], ios::in | ios::binary);</span><br><span class="line">    if (!address_book.ParseFromIstream(&amp;input)) &#123;   // pb</span><br><span class="line">      cerr &lt;&lt; &quot;Failed to parse address book.&quot; &lt;&lt; endl;</span><br><span class="line">      return -1;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ListPeople(address_book);</span><br><span class="line"></span><br><span class="line">  // Optional:  Delete all global objects allocated by libprotobuf.</span><br><span class="line">  google::protobuf::ShutdownProtobufLibrary();  // pb</span><br><span class="line"></span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="扩展-Protocol-Buffer"><a href="#扩展-Protocol-Buffer" class="headerlink" title="扩展 Protocol Buffer"></a>扩展 Protocol Buffer</h3><p>或早或晚在你发布了使用 protocol buffer 的代码之后，毫无疑问，你会想要 “改善” protocol buffer 的定义。如果你想要新的 buffers 向后兼容，并且老的 buffers 向前兼容——几乎可以肯定你很渴望这个——这里有一些规则，你需要遵守。在新的 protocol buffer 版本：</p><ul><li>你绝不可以修改任何已存在字段的标签数字</li><li>你绝不可以添加或删除任何 <code>required</code> 字段</li><li>你可以删除 <code>optional</code> 或 <code>repeated</code> 字段</li><li>你可以添加新的 <code>optional</code> 或 <code>repeated</code> 字段，但是你必须使用新的标签数字（也就是说，标签数字在 protocol buffer 中从未使用过，甚至不能是已删除字段的标签数字）。</li></ul><p>（对于上面规则有一些<a target="_blank" rel="noopener" href="https://developers.google.com/protocol-buffers/docs/proto#updating">例外情况</a>，但它们很少用到。）</p><p>如果你能遵守这些规则，旧代码则可以欢快地读取新的消息，并且简单地忽略所有新的字段。对于旧代码来说，被删除的 <code>optional</code> 字段将会简单地赋予默认值，被删除的 <code>repeated</code> 字段会为空。新代码显然可以读取旧消息。然而，请记住新的 <code>optional</code> 字段不会呈现在旧消息中，因此你需要显式地使用 <code>has_</code> 检查它们是否被设置或者在 <code>.proto</code> 文件在标签数字后使用 <code>[default = value]</code> 提供一个合理的默认值。如果一个 <code>optional</code> 元素没有指定默认值，它将会使用类型特定的默认值：对于字符串，默认值为空字符串；对于布尔值，默认值为 false；对于数字类型，默认类型为 0。注意，如果你添加一个新的 <code>repeated</code> 字段，新代码将无法辨别它被留空（被新代码）或者从没被设置（被旧代码），因为 <code>repeated</code> 字段没有 <code>has_</code> 标志。</p><h3 id="优化技巧"><a href="#优化技巧" class="headerlink" title="优化技巧"></a>优化技巧</h3><p>C++ Protocol Buffer 库已极度优化过了。但是，恰当的用法能够更多地提高性能。这里是一些技巧，可以帮你从库中挤压出最后一点速度：</p><ul><li>尽可能复用消息对象。即使它们被清除掉，消息也会尽量保存所有被分配来重用的内存。因此，如果我们正在处理许多相同类型或一系列相似结构的消息，一个好的办法是重用相同的消息对象，从而减少内存分配的负担。但是，随着时间的流逝，对象可能会膨胀变大，尤其是当你的消息尺寸（LCTT 译注：各消息内容不同，有些消息内容多一些，有些消息内容少一些）不同的时候，或者你偶尔创建了一个比平常大很多的消息的时候。你应该自己通过调用 <a target="_blank" rel="noopener" href="https://developers.google.com/protocol-buffers/docs/reference/cpp/google.protobuf.message.html#Message.SpaceUsed.details">SpaceUsed</a> 方法监测消息对象的大小，并在它太大的时候删除它。</li><li>对于在多线程中分配大量小对象的情况，你的操作系统内存分配器可能优化得不够好。你可以尝试使用 google 的 <a target="_blank" rel="noopener" href="http://code.google.com/p/google-perftools/">tcmalloc</a>。</li></ul><h3 id="高级用法"><a href="#高级用法" class="headerlink" title="高级用法"></a>高级用法</h3><p>Protocol Buffers 绝不仅用于简单的数据存取以及序列化。请阅读 <a target="_blank" rel="noopener" href="https://developers.google.com/protocol-buffers/docs/reference/cpp/index.html">C++ API reference</a> 来看看你还能用它来做什么。</p><p>protocol 消息类所提供的一个关键特性就是<ruby>反射 <rp>（ </rp><rt>reflection</rt> <rp>）</rp></ruby>。你不需要针对一个特殊的消息类型编写代码，就可以遍历一个消息的字段并操作它们的值。一个使用反射的有用方法是 protocol 消息与其他编码互相转换，比如 XML 或 JSON。反射的一个更高级的用法可能就是可以找出两个相同类型的消息之间的区别，或者开发某种“协议消息的正则表达式”，利用正则表达式，你可以对某种消息内容进行匹配。只要你发挥你的想像力，就有可能将 Protocol Buffers 应用到一个更广泛的、你可能一开始就期望解决的问题范围上。</p><p>反射是由 <a target="_blank" rel="noopener" href="https://developers.google.com/protocol-buffers/docs/reference/cpp/google.protobuf.message.html#Message.Reflection">Message::Reflection interface</a> 提供的。</p><hr><p>via: <a target="_blank" rel="noopener" href="https://developers.google.com/protocol-buffers/docs/cpptutorial">https://developers.google.com/protocol-buffers/docs/cpptutorial</a></p><p>作者：<a target="_blank" rel="noopener" href="https://developers.google.com/protocol-buffers/docs/cpptutorial">Google</a> 译者：<a target="_blank" rel="noopener" href="https://github.com/cposture">cposture</a> 校对：<a target="_blank" rel="noopener" href="https://github.com/wxy">wxy</a></p><p>本文由 <a target="_blank" rel="noopener" href="https://github.com/LCTT/TranslateProject">LCTT</a> 原创编译，<a target="_blank" rel="noopener" href="https://linux.cn/">Linux中国</a> 荣誉推出</p></div></div></div><div class="footer"><p class="footer-copyright"><span>Powered by <a target="_blank" href="https://hexo.io">Hexo</a></span> <span>Theme <a target="_blank" href="https://github.com/tinkink-co/hexo-theme-terminal">Terminal</a></span><script type="text/javascript" src="https://cdn.staticfile.net/jquery/3.4.1/jquery.min.js"></script><script>getCDNinfo=function(){$.ajax({url:"/cdn-cgi/trace",success:function(a,n){let i="Antananarivo, Madagascar - (TNR);Cape Town, South Africa - (CPT);Casablanca, Morocco - (CMN);Dar Es Salaam, Tanzania - (DAR);Djibouti City, Djibouti - (JIB);Durban, South Africa - (DUR);Johannesburg, South Africa - (JNB);Kigali, Rwanda - (KGL);Lagos, Nigeria - (LOS);Luanda, Angola - (LAD);Maputo, MZ - (MPM);Mombasa, Kenya - (MBA);Port Louis, Mauritius - (MRU);Réunion, France - (RUN);Bangalore, India - (BLR);Bangkok, Thailand - (BKK);Bandar Seri Begawan, Brunei - (BWN);Cebu, Philippines - (CEB);Chengdu, China - (CTU);Chennai, India - (MAA);Chittagong, Bangladesh - (CGP);Chongqing, China - (CKG);Colombo, Sri Lanka - (CMB);Dhaka, Bangladesh - (DAC);Dongguan, China - (SZX);Foshan, China - (FUO);Fuzhou, China - (FOC);Guangzhou, China - (CAN);Hangzhou, China - (HGH);Hanoi, Vietnam - (HAN);Hengyang, China - (HNY);Ho Chi Minh City, Vietnam - (SGN);Hong Kong - (HKG);Hyderabad, India - (HYD);Islamabad, Pakistan - (ISB);Jakarta, Indonesia - (CGK);Jinan, China - (TNA);Karachi, Pakistan - (KHI);Kathmandu, Nepal - (KTM);Kolkata, India - (CCU);Kuala Lumpur, Malaysia - (KUL);Lahore, Pakistan - (LHE);Langfang, China - (NAY);Luoyang, China - (LYA);Macau - (MFM);Malé, Maldives - (MLE);Manila, Philippines - (MNL);Mumbai, India - (BOM);Nagpur, India - (NAG);Nanning, China - (NNG);New Delhi, India - (DEL);Osaka, Japan - (KIX);Phnom Penh, Cambodia - (PNH);Qingdao, China - (TAO);Seoul, South Korea - (ICN);Shanghai, China - (SHA);Shenyang, China - (SHE);Shijiazhuang, China - (SJW);Singapore, Singapore - (SIN);Suzhou, China - (SZV);Taipei - (TPE);Thimphu, Bhutan - (PBH);Tianjin, China - (TSN);Tokyo, Japan - (NRT);Ulaanbaatar, Mongolia - (ULN);Vientiane, Laos - (VTE);Wuhan, China - (WUH);Wuxi, China - (WUX);Xi'an, China - (XIY);Yerevan, Armenia - (EVN);Zhengzhou, China - (CGO);Zuzhou, China - (CSX);Amsterdam, Netherlands - (AMS);Athens, Greece - (ATH);Barcelona, Spain - (BCN);Belgrade, Serbia - (BEG);Berlin, Germany - (TXL);Brussels, Belgium - (BRU);Bucharest, Romania - (OTP);Budapest, Hungary - (BUD);Chișinău, Moldova - (KIV);Copenhagen, Denmark - (CPH);Cork, Ireland -  (ORK);Dublin, Ireland - (DUB);Düsseldorf, Germany - (DUS);Edinburgh, United Kingdom - (EDI);Frankfurt, Germany - (FRA);Geneva, Switzerland - (GVA);Gothenburg, Sweden - (GOT);Hamburg, Germany - (HAM);Helsinki, Finland - (HEL);Istanbul, Turkey - (IST);Kyiv, Ukraine - (KBP);Lisbon, Portugal - (LIS);London, United Kingdom - (LHR);Luxembourg City, Luxembourg - (LUX);Madrid, Spain - (MAD);Manchester, United Kingdom - (MAN);Marseille, France - (MRS);Milan, Italy - (MXP);Moscow, Russia - (DME);Munich, Germany - (MUC);Nicosia, Cyprus - (LCA);Oslo, Norway - (OSL);Paris, France - (CDG);Prague, Czech Republic - (PRG);Reykjavík, Iceland - (KEF);Riga, Latvia - (RIX);Rome, Italy - (FCO);Saint Petersburg, Russia - (LED);Sofia, Bulgaria - (SOF);Stockholm, Sweden - (ARN);Tallinn, Estonia - (TLL);Thessaloniki, Greece - (SKG);Vienna, Austria - (VIE);Vilnius, Lithuania - (VNO);Warsaw, Poland - (WAW);Zagreb, Croatia - (ZAG);Zürich, Switzerland - (ZRH);Arica, Chile - (ARI);Asunción, Paraguay - (ASU);Bogotá, Colombia - (BOG);Buenos Aires, Argentina - (EZE);Curitiba, Brazil - (CWB);Fortaleza, Brazil - (FOR);Guatemala City, Guatemala - (GUA);Lima, Peru - (LIM);Medellín, Colombia - (MDE);Panama City, Panama - (PTY);Porto Alegre, Brazil - (POA);Quito, Ecuador - (UIO);Rio de Janeiro, Brazil - (GIG);São Paulo, Brazil - (GRU);Santiago, Chile - (SCL);Willemstad, Curaçao - (CUR);St. George's, Grenada - (GND);Amman, Jordan - (AMM);Baghdad, Iraq - (BGW);Baku, Azerbaijan - (GYD);Beirut, Lebanon - (BEY);Doha, Qatar - (DOH);Dubai, United Arab Emirates - (DXB);Kuwait City, Kuwait - (KWI);Manama, Bahrain - (BAH);Muscat, Oman - (MCT);Ramallah - (ZDM);Riyadh, Saudi Arabia - (RUH);Tel Aviv, Israel - (TLV);Ashburn, VA, United States - (IAD);Atlanta, GA, United States - (ATL);Boston, MA, United States - (BOS);Buffalo, NY, United States - (BUF);Calgary, AB, Canada - (YYC);Charlotte, NC, United States - (CLT);Chicago, IL, United States - (ORD);Columbus, OH, United States - (CMH);Dallas, TX, United States - (DFW);Denver, CO, United States - (DEN);Detroit, MI, United States - (DTW);Honolulu, HI, United States - (HNL);Houston, TX, United States - (IAH);Indianapolis, IN, United States - (IND);Jacksonville, FL, United States - (JAX);Kansas City, MO, United States - (MCI);Las Vegas, NV, United States - (LAS);Los Angeles, CA, United States - (LAX);McAllen, TX, United States - (MFE);Memphis, TN, United States - (MEM);Mexico City, Mexico - (MEX);Miami, FL, United States - (MIA);Minneapolis, MN, United States - (MSP);Montgomery, AL, United States - (MGM);Montréal, QC, Canada - (YUL);Nashville, TN, United States - (BNA);Newark, NJ, United States - (EWR);Norfolk, VA, United States - (ORF);Omaha, NE, United States - (OMA);Philadelphia, United States - (PHL);Phoenix, AZ, United States - (PHX);Pittsburgh, PA, United States - (PIT);Port-Au-Prince, Haiti - (PAP);Portland, OR, United States - (PDX);Queretaro, MX, Mexico - (QRO);Richmond, Virginia - (RIC);Sacramento, CA, United States - (SMF);Salt Lake City, UT, United States - (SLC);San Diego, CA, United States - (SAN);San Jose, CA, United States - (SJC);Saskatoon, SK, Canada - (YXE);Seattle, WA, United States - (SEA);St. Louis, MO, United States - (STL);Tampa, FL, United States - (TPA);Toronto, ON, Canada - (YYZ);Vancouver, BC, Canada - (YVR);Tallahassee, FL, United States - (TLH);Winnipeg, MB, Canada - (YWG);Adelaide, SA, Australia - (ADL);Auckland, New Zealand - (AKL);Brisbane, QLD, Australia - (BNE);Melbourne, VIC, Australia - (MEL);Noumea, New caledonia - (NOU);Perth, WA, Australia - (PER);Sydney, NSW, Australia - (SYD)".split(";"),e=a.split("colo=")[1].split("\n")[0],t=(a.split("colo=")[1].split("\n")[0],a.split("tls=")[1].split("\n")[0]),o=a.split("http=")[1].split("\n")[0],s=a.split("sni=")[1].split("\n")[0],r=a.split("ip=")[1].split("\n")[0],l=a.split("uag=")[1].split("\n")[0];for(var d=0;d<i.length;d++)if(-1!=i[d].indexOf(e)){document.getElementById("cdn").innerHTML=i[d];break}document.getElementById("tls").innerHTML=t,document.getElementById("http").innerHTML=o,document.getElementById("sni").innerHTML=s,document.getElementById("ip").innerHTML=r,document.getElementById("useragent").innerHTML=l}})},$(document).ready((function(){getCDNinfo()}))</script></p><p style="text-align:center">感谢陪伴与布道，开源之火不灭。​</p><p style="text-align:center"><script>document.write("本次加载耗时: "+(performance.getEntriesByType("navigation").reduce((e,r)=>e+r.responseEnd-r.startTime,0)+performance.getEntriesByType("resource").reduce((e,r)=>e+r.responseEnd-r.startTime,0)).toFixed(0)+"ms")</script></p><p style="text-align:center">当前 SNI 状态： <span id="sni">正在统计！或可能被浏览器防追踪拦截！</span></p><p style="text-align:center">当前 TLS 版本： <span id="tls">正在统计！或可能被浏览器防追踪拦截！</span></p><p style="text-align:center">当前 HTTP 版本： <span id="http">正在统计！或可能被浏览器防追踪拦截！</span></p><p style="text-align:center">当前您的客户端 IP 是： <span id="ip">正在统计！或可能被浏览器防追踪拦截！</span></p><p style="text-align:center">当前分配的 CDN 节点是: <span id="cdn">正在统计！或可能被浏览器防追踪拦截！</span></p><p style="text-align:center">您的 UserAgent 信息是: <span id="useragent">正在统计！或可能被浏览器防追踪拦截！</span></p><p></p></div></div></body></html>