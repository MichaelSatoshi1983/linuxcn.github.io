<!doctype html><html lang="en"><head><meta name="msvalidate.01" content="D404690CEFCB54C7762AC84935B99171"><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?6618da70c90c8744eead2e9371fb5077";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><script type="text/javascript">!function(t,e,n,c,s,a,r){t[n]=t[n]||function(){(t[n].q=t[n].q||[]).push(arguments)},(a=e.createElement(c)).async=1,a.src="https://www.clarity.ms/tag/s5f3f0tojf",(r=e.getElementsByTagName(c)[0]).parentNode.insertBefore(a,r)}(window,document,"clarity","script")</script><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta http-equiv="X-UA-Compatible" content="ie=edge"><link rel="stylesheet" href="/styles/base.css"><link rel="stylesheet" href="/styles/theme.css"><link rel="shortcut icon" href="/favicon.png"><title>如何使用 OpenSSL：哈希值、数字签名等 - 归墟星火集</title><meta name="generator" content="Hexo 7.3.0"></head><body><div class="header-title"><span class="header-light"></span> <span class="header-light"></span> <span class="header-light"></span> <span>归墟星火集 linuxcn.undefined.today<span></span></span></div><div class="container"><ul class="nav"><li><a href="/">首页</a></li><li><a href="/about/">关于</a></li><li><a target="_blank" rel="noopener" href="https://undefined.today/">Blog</a></li></ul><div class="content"><div class="post-container"><div class="post-header"><span class="ui-tips">标题：</span><h1 class="ui-keyword post-title">如何使用 OpenSSL：哈希值、数字签名等</h1><span class="post-date">2020-08-13</span></div><div class="post-header"><span class="ui-tips">分类：</span> <a href="/categories/%E6%8A%80%E6%9C%AF/">技术</a></div><div class="post-header"><span class="ui-tips">标签：</span> <a href="/tags/OpenSSL/">OpenSSL</a></div><div class="post-content"><blockquote><p>通过 OpenSSL 深入了解密码学的细节：哈希值、数字签名、数字证书等。</p></blockquote><p><img src="https://linuxcn.img.undefined.today/data/attachment/album/202008/13/150012t7zwwk6x7wr69wih.jpg"></p><p><a href="/article-11810-1.html">本系列的第一篇文章</a>通过 OpenSSL 库和命令行实用程序介绍了哈希、加密&#x2F;解密、数字签名和数字证书。这第二篇文章将对细节进行深入探讨。让我们从计算中无处不在的哈希开始，并考虑是什么使哈希函数<em>具备密码学意义</em>。</p><h3 id="密码学哈希"><a href="#密码学哈希" class="headerlink" title="密码学哈希"></a>密码学哈希</h3><p>OpenSSL 源代码的<a target="_blank" rel="noopener" href="https://www.openssl.org/source/">下载页面</a>包含了一个带有最新版本的表格。每个版本都有两个<ruby>哈希值 <rt>hash</rt></ruby>：160 位 SHA1 和 256 位 SHA256。这些值可以用来验证下载的文件是否与存储库中的原始文件相匹配：下载者在本地重新计算下载文件的哈希值，然后将结果与原始文件进行比较。现代系统有计算这种哈希值的实用程序。例如，Linux 有 <code>md5sum</code> 和 <code>sha256sum</code>。OpenSSL 本身也提供了类似的命令行实用程序。</p><p>哈希值被用于计算的许多领域。例如，比特币区块链使用 SHA256 哈希值作为区块标识符。挖比特币就是生成一个低于指定阈值的 SHA256 哈希值，也就是至少有 N 个前导零的哈希值。（N 的值可以上升或下降，这取决于特定时间的挖矿生产力）。作为一个兴趣点，如今的矿机是为并行生成 SHA256 哈希值而设计的硬件集群。在 2018 年的一个高峰期，全球的比特币矿工每秒产生约 7500 万个<ruby>太哈希值 <rt>terahash</rt></ruby> —— 这真是一个不可思议的数字。</p><p>网络协议也使用哈希值（在这里通常叫做“<ruby>校验和 <rt>checksum</rt></ruby>”）来支持消息的完整性；也就是说，保证收到的消息与发送的消息是一样的。消息发送者计算消息的校验和，并将结果与消息一起发送。当消息到达时，接收方重新计算校验和。如果发送的校验和与重新计算的校验和不一致，那么消息在传输过程中可能出现了一些问题，或者发送的校验和出现了问题，或者两者都出现了问题。在这种情况下，应该重新发送消息和它的校验和，或者至少应该触发一个错误情况。（如 UDP 这样的低级网络协议不会理会校验和。）</p><p>哈希的其他例子大家都很熟悉。比如一个网站，要求用户用密码进行验证，用户在浏览器中输入密码，然后，他们通过 HTTPS 连接到服务器，密码从浏览器加密发送到服务器。一旦密码到达服务器，就会被解密，然后进行数据库表的查询。</p><p>在这个查询表中应该存储什么？存储密码本身是有风险的。风险要小得多的方式是存储一个由密码生成的哈希值，也许在计算哈希值之前“加一些<ruby>盐 <rt>salt</rt></ruby>（额外的位）改善口味”。你的密码可能会被发送到 Web 服务器上，但网站可以向你保证，密码不会存储在那里。</p><p>哈希值还出现在安全的各个领域。例如，<ruby>基于哈希值的消息认证码 <rt>hash-based message authentication code</rt></ruby>（<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/HMAC">HMAC</a>）使用一个哈希值和一个秘密的<ruby>加密密钥 <rt>cryptographic key</rt></ruby>来认证通过网络发送的消息。HMAC 码轻量级且易于在程序中使用，在 Web 服务中很受欢迎。一个 X509 数字证书包括一个称为<ruby>指纹 <rt>fingerprint</rt></ruby>的哈希值，它可以方便证书验证。一个存放于内存中的<ruby>可信存储 <rt>truststore</rt></ruby>可以实现为一个以这种指纹为键的查找表 —— 作为一个支持恒定查找时间的<ruby>哈希映射 <rt>hash map</rt></ruby>。来自传入的证书的指纹可以与可信存储中的密钥进行比较，以确定是否匹配。</p><p><ruby>密码学哈希函数 <rt>cryptographic hash function</rt></ruby>应该具有什么特殊属性？它应该是<ruby>单向 <rt>one-way</rt></ruby>的，这意味着很难被逆转。一个加密哈希函数应该是比较容易计算的，但是计算它的反函数（将哈希值映射回输入位串的函数）在计算上应该是困难的。下面是一个描述，用 <code>chf</code> 作为加密哈希函数，我的密码 <code>foobar</code> 作为样本输入。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">        +---+</span><br><span class="line">foobar—&gt;|chf|—&gt;hash value ## 简单直接</span><br><span class="line">        +--–+</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>相比之下，逆向操作是不可行的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">            +-----------+</span><br><span class="line">hash value—&gt;|chf inverse|—&gt;foobar ## 棘手困难</span><br><span class="line">            +-----------+</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>例如，回忆一下 SHA256 哈希函数。对于一个任意长度为 N &gt; 0 的输入位串，这个函数会生成一个 256 位的固定长度的哈希值；因此，这个哈希值甚至不会反映出输入位串的长度 N，更不用说字符串中每个位的值了。顺便说一下，SHA256 不容易受到<ruby><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Length_extension_attack">长度扩展攻击 </a><rt>length extension attack</rt></ruby>。唯一有效的逆向工程方法是通过蛮力搜索将计算出的 SHA256 哈希值逆向返回到输入位串，这意味着需要尝试所有可能的输入位串，直到找到与目标哈希值匹配的位串。这样的搜索在 SHA256 这样一个完善的加密哈希函数上是不可行的。</p><p>现在，最后一个回顾的知识点是<ruby>有序 <rt>in order</rt></ruby>。加密哈希值是统计学上的唯一，而不是无条件的唯一，这意味着两个不同的输入位串产生相同的哈希值是不太可能的，但也不是不可能的 —— 这称之为<ruby>碰撞 <rt>collision</rt></ruby>。<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Birthday_problem">生日问题</a>提供了一个很好的反直觉的碰撞例子。对各种哈希算法的<ruby>抗碰撞性 <rt>collision resistance</rt></ruby>有着广泛的研究。例如，MD5（128 位哈希值）在大约 2<sup> 21</sup> 次哈希之后，抗碰撞能力就会崩溃。对于 SHA1（160 位哈希值），大约在 2<sup> 61</sup> 次哈希后开始崩溃。</p><p>对于 SHA256 的抗碰撞能力的剖析，目前还没有一个很好的估计。这个事实并不奇怪。SHA256 有 2<sup> 256</sup> 个不同的哈希值范围，这个数字的十进制表示法有 78 位之多！那么，SHA256 哈希会不会发生碰撞呢？当然可能，但可能性极小。</p><p>在下面的命令行示例中，有两个输入文件被用作位串源：<code>hashIn1.txt</code> 和 <code>hashIn2.txt</code>。第一个文件包含 <code>abc</code>，第二个文件包含 <code>1a2b3c</code>。</p><p>为了便于阅读，这些文件包含的是文本，但也可以使用二进制文件代替。</p><p>在命令行（百分号 <code>%</code> 是提示符）使用 Linux <code>sha256sum</code> 实用程序对这两个文件进行处理产生以下哈希值（十六进制）:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">% sha256sum hashIn1.txt</span><br><span class="line">9e83e05bbf9b5db17ac0deec3b7ce6cba983f6dc50531c7a919f28d5fb3696c3 hashIn1.txt</span><br><span class="line"></span><br><span class="line">% sha256sum hashIn2.txt</span><br><span class="line">3eaac518777682bf4e8840dd012c0b104c2e16009083877675f00e995906ed13 hashIn2.txt</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>OpenSSL 哈希对应的结果与预期相同：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">% openssl dgst -sha256 hashIn1.txt</span><br><span class="line">SHA256(hashIn1.txt)= 9e83e05bbf9b5db17ac0deec3b7ce6cba983f6dc50531c7a919f28d5fb3696c3</span><br><span class="line"></span><br><span class="line">% openssl dgst -sha256 hashIn2.txt</span><br><span class="line">SHA256(hashIn2.txt)= 3eaac518777682bf4e8840dd012c0b104c2e16009083877675f00e995906ed13</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这种对密码学哈希函数的研究，为我们仔细研究数字签名及其与密钥对的关系奠定了基础。</p><h3 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h3><p>顾名思义，<ruby>数字签字 <rt>digital signature</rt></ruby>可以附在文件或其他一些电子<ruby>工件 <rt>artifact</rt></ruby>（如程序）上，以证明其真实性。因此，这种签名类似于纸质文件上的手写签名。验证数字签名就是要确认两件事：第一，被担保的工件在签名被附上后没有改变，因为它部分是基于文件的加密学哈希值。第二，签名属于一个人（例如 Alice），只有她才能获得一对密钥中的私钥。顺便说一下，对代码（源码或编译后的代码）进行数字签名已经成为程序员的普遍做法。</p><p>让我们来了解一下数字签名是如何创建的。如前所述，没有公钥和私钥对就没有数字签名。当使用 OpenSSL 创建这些密钥时，有两个独立的命令：一个是创建私钥，另一个是从私钥中提取匹配的公钥。这些密钥对用 base64 编码，在这个过程中可以指定它们的大小。</p><p><ruby>私钥 <rt>private key</rt></ruby>由数值组成，其中两个数值（一个<ruby>模数 <rt>modulus</rt></ruby>和一个<ruby>指数 <rt>exponent</rt></ruby>）组成了公钥。虽然私钥文件包含了<ruby>公钥 <rt>public key</rt></ruby>，但提取出来的公钥并<strong>不会</strong>透露相应私钥的值。</p><p>因此，生成的带有私钥的文件包含了完整的密钥对。将公钥提取到自己的文件中是很实用的，因为这两把钥匙有不同的用途，而这种提取方式也将私钥可能被意外公开的危险降到最低。</p><p>接下来，这对密钥的私钥被用来生成目标工件（如电子邮件）的哈希值，从而创建签名。在另一端，接收者的系统使用这对密钥的公钥来验证附在工件上的签名。</p><p>现在举个例子。首先，用 OpenSSL 生成一个 2048 位的 RSA 密钥对：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">openssl genpkey -out privkey.pem -algorithm rsa 2048</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在这个例子中，我们可以舍去 <code>-algorithm rsa</code> 标志，因为 <code>genpkey</code> 默认为 RSA 类型。文件的名称（<code>privkey.pem</code>）是任意的，但是<ruby>隐私增强邮件 <rt>Privacy Enhanced Mail</rt></ruby>（PEM）扩展名 <code>.pem</code> 是默认 PEM 格式的惯用扩展名。（如果需要的话，OpenSSL 有命令可以在各种格式之间进行转换。）如果需要更大的密钥大小（例如 4096），那么最后一个参数 <code>2048</code> 可以改成 <code>4096</code>。这些大小总是二的幂。</p><p>下面是产生的 <code>privkey.pem</code> 文件的一个片断，它是 base64 编码的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-----BEGIN PRIVATE KEY-----</span><br><span class="line">MIICdgIBADANBgkqhkiG9w0BAQEFAASCAmAwggJcAgEAAoGBANnlAh4jSKgcNj/Z</span><br><span class="line">JF4J4WdhkljP2R+TXVGuKVRtPkGAiLWE4BDbgsyKVLfs2EdjKL1U+/qtfhYsqhkK</span><br><span class="line">...</span><br><span class="line">-----END PRIVATE KEY-----</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>接下来的命令就会从私钥中提取出这对密钥的公钥：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">openssl rsa -in privkey.pem -outform PEM -pubout -out pubkey.pem</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>由此产生的 <code>pubkey.pem</code> 文件很小，可以在这里完整地显示出来：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-----BEGIN PUBLIC KEY-----</span><br><span class="line">MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDZ5QIeI0ioHDY/2SReCeFnYZJY</span><br><span class="line">z9kfk11RrilUbT5BgIi1hOAQ24LMilS37NhHYyi9VPv6rX4WLKoZCmkeYaWk/TR5</span><br><span class="line">4nbH1E/AkniwRoXpeh5VncwWMuMsL5qPWGY8fuuTE27GhwqBiKQGBOmU+MYlZonO</span><br><span class="line">O0xnAKpAvysMy7G7qQIDAQAB</span><br><span class="line">-----END PUBLIC KEY-----</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>现在，有了密钥对，数字签名就很容易了 —— 在本例中，源文件 <code>client.c</code> 是要签名的工件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">openssl dgst -sha256 -sign privkey.pem -out sign.sha256 client.c</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>client.c</code> 源文件的摘要是 SHA256，私钥在前面创建的 <code>privkey.pem</code> 文件中。由此产生的二进制签名文件是 <code>sign.sha256</code>，这是一个任意的名字。要得到这个文件的可读版本（比如 base64），后续命令是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">openssl enc -base64 -in sign.sha256 -out sign.sha256.base64</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>文件 <code>sign.sha256.base64</code> 现在包含如下内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">h+e+3UPx++KKSlWKIk34fQ1g91XKHOGFRmjc0ZHPEyyjP6/lJ05SfjpAJxAPm075</span><br><span class="line">VNfFwysvqRGmL0jkp/TTdwnDTwt756Ej4X3OwAVeYM7i5DCcjVsQf5+h7JycHKlM</span><br><span class="line">o/Jd3kUIWUkZ8+Lk0ZwzNzhKJu6LM5KWtL+MhJ2DpVc=</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>或者，可执行文件 <code>client</code> 也可以被签名，由此产生的 base64 编码签名将如预期的不同：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">VMVImPgVLKHxVBapJ8DgLNJUKb98GbXgehRPD8o0ImADhLqlEKVy0HKRm/51m9IX</span><br><span class="line">xRAN7DoL4Q3uuVmWWi749Vampong/uT5qjgVNTnRt9jON112fzchgEoMb8CHNsCT</span><br><span class="line">XIMdyaPtnJZdLALw6rwMM55MoLamSc6M/MV1OrJnk/g=</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这一过程的最后一步是用公钥验证数字签名。作为验证的一个重要步骤，应重新计算用于签署工件（在本例中，是可执行的 <code>client</code> 程序）的哈希值，因为验证过程应表明工件在签署后是否发生了变化。</p><p>有两个 OpenSSL 命令用于这个目的。第一条命令是对 base64 签名进行解码。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">openssl enc -base64 -d -in sign.sha256.base64 -out sign.sha256</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>第二条是核实签名：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">openssl dgst -sha256 -verify pubkey.pem -signature sign.sha256 client</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>第二条命令的输出，应该是这样的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Verified OK</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>为了了解验证失败时的情况，一个简短但有用的练习是将最后一个 OpenSSL 命令中的可执行的 <code>client</code> 文件替换为源文件 <code>client.c</code>，然后尝试验证。另一个练习是改变 <code>client</code> 程序，无论多么轻微，然后再试一次。</p><h3 id="数字证书"><a href="#数字证书" class="headerlink" title="数字证书"></a>数字证书</h3><p><ruby>数字证书 <rt>digital certificate</rt></ruby>汇集了到目前为止所分析的各个部分：哈希值、密钥对、数字签名和加密&#x2F;解密。生产级证书的第一步是创建一个<ruby>证书签名请求 <rt>certificate signing request</rt></ruby>（CSR），然后将其发送给<ruby>证书颁发机构 <rt>certificate authority</rt></ruby>（CA）。在 OpenSSL 的例子中，要做到这一点，请运行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">openssl req -out myserver.csr -new -newkey rsa:4096 -nodes -keyout myserverkey.pem</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这个例子生成了一个 CSR 文档，并将该文档存储在文件 <code>myserver.csr</code>（base64 文本）中。这里的目的是：CSR 文档要求 CA 保证与指定域名相关联的身份，域名也就是 CA 所说的<ruby>通用名 <rt>common name</rt></ruby>（CN）。</p><p>尽管可以使用现有的密钥对，但这个命令也会生成一个新的密钥对。请注意，在诸如 <code>myserver.csr</code> 和 <code>myserverkey.pem</code> 等名称中使用 <code>server</code> 暗示了数字证书的典型用途：作为与 <a target="_blank" rel="noopener" href="http://www.google.com/">www.google.com</a> 等域名相关的 Web 服务器的身份担保。</p><p>然而，无论数字证书如何使用，同样使用这个命令都会创建一个 CSR。它还会启动一个问题&#x2F;回答的交互式会话，提示有关域名的相关信息，以便与请求者的数字证书相连接。这个交互式会话可以通过在命令中提供基本的信息，用反斜杠来续行一步完成。<code>-subj</code> 标志提供了所需的信息。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">% openssl req -new \</span><br><span class="line">-newkey rsa:2048 -nodes -keyout privkeyDC.pem \</span><br><span class="line">-out myserver.csr \</span><br><span class="line">-subj &quot;/C=US/ST=Illinois/L=Chicago/O=Faulty Consulting/OU=IT/CN=myserver.com&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>产生的 CSR 文件在发送给 CA 之前可以进行检查和验证。这个过程可以创建具有所需格式（如 X509）、签名、有效期等的数字证书。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">openssl req -text -in myserver.csr -noout -verify</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这是输出的一个片断：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">verify OK</span><br><span class="line">Certificate Request:</span><br><span class="line">Data:</span><br><span class="line">Version: 0 (0x0)</span><br><span class="line">Subject: C=US, ST=Illinois, L=Chicago, O=Faulty Consulting, OU=IT, CN=myserver.com</span><br><span class="line">Subject Public Key Info:</span><br><span class="line">Public Key Algorithm: rsaEncryption</span><br><span class="line">Public-Key: (2048 bit)</span><br><span class="line">Modulus:</span><br><span class="line">00:ba:36:fb:57:17:65:bc:40:30:96:1b:6e:de:73:</span><br><span class="line">…</span><br><span class="line">Exponent: 65537 (0x10001)</span><br><span class="line">Attributes:</span><br><span class="line">a0:00</span><br><span class="line">Signature Algorithm: sha256WithRSAEncryption</span><br><span class="line">…</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="自签证书"><a href="#自签证书" class="headerlink" title="自签证书"></a>自签证书</h3><p>在开发 HTTPS 网站的过程中，手头有一个不用经过 CA 流程的数字证书是很方便的。在 HTTPS 握手的认证阶段，<ruby>自签证书 <rt>self-signed certificate</rt></ruby>就能满足要求，尽管任何现代浏览器都会警告说这样的证书毫无价值。继续这个例子，自签证书的 OpenSSL 命令（有效期为一年，使用 RSA 公钥）如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">openssl req -x509 -sha256 -nodes -days 365 -newkey rsa:4096 -keyout myserver.pem -out myserver.crt</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>下面的 OpenSSL 命令呈现了生成的证书的可读版本：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">openssl x509 -in myserver.crt -text -noout</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这是自签证书的部分输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">Certificate:</span><br><span class="line">Data:</span><br><span class="line">Version: 3 (0x2)</span><br><span class="line">Serial Number: 13951598013130016090 (0xc19e087965a9055a)</span><br><span class="line">Signature Algorithm: sha256WithRSAEncryption</span><br><span class="line">Issuer: C=US, ST=Illinois, L=Chicago, O=Faulty Consulting, OU=IT, CN=myserver.com</span><br><span class="line">Validity</span><br><span class="line">Not Before: Apr 11 17:22:18 2019 GMT</span><br><span class="line">Not After : Apr 10 17:22:18 2020 GMT</span><br><span class="line">Subject: C=US, ST=Illinois, L=Chicago, O=Faulty Consulting, OU=IT, CN=myserver.com</span><br><span class="line">Subject Public Key Info:</span><br><span class="line">Public Key Algorithm: rsaEncryption</span><br><span class="line">Public-Key: (4096 bit)</span><br><span class="line">Modulus:</span><br><span class="line">00:ba:36:fb:57:17:65:bc:40:30:96:1b:6e:de:73:</span><br><span class="line">...</span><br><span class="line">Exponent: 65537 (0x10001)</span><br><span class="line">X509v3 extensions:</span><br><span class="line">X509v3 Subject Key Identifier:</span><br><span class="line">3A:32:EF:3D:EB:DF:65:E5:A8:96:D7:D7:16:2C:1B:29:AF:46:C4:91</span><br><span class="line">X509v3 Authority Key Identifier:</span><br><span class="line">keyid:3A:32:EF:3D:EB:DF:65:E5:A8:96:D7:D7:16:2C:1B:29:AF:46:C4:91</span><br><span class="line"></span><br><span class="line">        X509v3 Basic Constraints:</span><br><span class="line">            CA:TRUE</span><br><span class="line">Signature Algorithm: sha256WithRSAEncryption</span><br><span class="line">     3a:eb:8d:09:53:3b:5c:2e:48:ed:14:ce:f9:20:01:4e:90:c9:</span><br><span class="line">     ...</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如前所述，RSA 私钥包含的值是用来生成公钥的。但是，给定的公钥<strong>不会</strong>泄露匹配的私钥。关于底层数学理论的介绍，见 <a target="_blank" rel="noopener" href="https://simple.wikipedia.org/wiki/RSA_algorithm">https://simple.wikipedia.org/wiki/RSA_algorithm</a>。</p><p>数字证书与用于生成该证书的密钥对之间存在着重要的对应关系，即使证书只是自签的：</p><ul><li>数字证书包含构成公钥的指数和模数值。这些值是最初生成的 PEM 文件中密钥对的一部分，在本例中，是文件 <code>myserver.pem</code>。</li><li><ruby>指数 <rt>exponent</rt></ruby>几乎总是 65,537（如本例中），所以可以忽略。</li><li>密钥对的<ruby>模数 <rt>modulus</rt></ruby>应该与数字证书的模数相匹配。</li></ul><p>模数是一个很大的值，为了便于阅读，可以进行哈希处理。下面是两个 OpenSSL 命令，它们检查相同的模数，从而确认数字证书是基于 PEM 文件中的密钥对。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">% openssl x509 -noout -modulus -in myserver.crt | openssl sha1 ## 证书中的模数</span><br><span class="line">(stdin)= 364d21d5e53a59d482395b1885aa2c3a5d2e3769</span><br><span class="line"></span><br><span class="line">% openssl rsa -noout -modulus -in myserver.pem | openssl sha1 ## 密钥中的模数</span><br><span class="line">(stdin)= 364d21d5e53a59d482395b1885aa2c3a5d2e3769</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>所产生的哈希值匹配，从而确认数字证书是基于指定的密钥对。</p><h3 id="回到密钥分发问题上"><a href="#回到密钥分发问题上" class="headerlink" title="回到密钥分发问题上"></a>回到密钥分发问题上</h3><p>让我们回到第一部分末尾提出的一个问题：<code>client</code> 程序和 Google Web 服务器之间的 TLS 握手。握手协议有很多种，即使是用在 <code>client</code> 例子中的 Diffie-Hellman 版本也有不同的方式。尽管如此，<code>client</code> 例子遵循了一个共同的模式。</p><p>首先，在 TLS 握手过程中，<code>client</code> 程序和 Web 服务器就<ruby>加密套件 <rt>cipher suite</rt></ruby>达成一致，其中包括要使用的算法。在本例中，该套件是 <code>ECDHE-RSA-AES128-GCM-SHA256</code>。</p><p>现在值得关注的两个要素是 RSA 密钥对算法和 AES128 块密码，用于在握手成功的情况下对消息进行加密和解密。关于加密&#x2F;解密，这个过程有两种流派：<ruby>对称 <rt>symmetric</rt></ruby>和<ruby>非对称 <rt>asymmetric</rt></ruby>。在对称流派中，加密和解密使用的是<em>相同的</em>密钥，这首先就引出了<ruby>密钥分发问题 <rt>key distribution problem</rt></ruby>。如何将密钥安全地分发给双方？在非对称流派中，一个密钥用于加密（在这种情况下，是 RSA 公钥），但另一个密钥用于解密（在这种情况下，是来自同一对密钥的 RSA 私钥）。</p><p><code>client</code> 程序拥有来认证证书的 Google Web 服务器的公钥，而 Web 服务器拥有来自同一对密钥的私钥。因此，<code>client</code> 程序可以向 Web 服务器发送加密信息，而 Web 服务器可以单独对该通信进行解密。</p><p>在 TLS 的情况下，对称方式有两个显著的优势：</p><ul><li>在 <code>client</code> 程序与 Google Web 服务器之间的互动中，认证是单向的。Google Web 服务器向 <code>client</code> 程序发送三张证书，但 <code>client</code> 程序并没有向 Web 服务器发送证书，因此，Web 服务器没有来自客户端的公钥，无法加密发给客户端的消息。</li><li>使用 AES128 的对称加密&#x2F;解密比使用 RSA 密钥的非对称加密&#x2F;解密快了<strong>近千倍</strong>。</li></ul><p>TLS 握手将两种加密&#x2F;解密方式巧妙地结合在一起。在握手过程中，<code>client</code> 程序会生成随机位，即所谓的<ruby>预主密 <rt>pre-master secret</rt></ruby>（PMS）。然后，<code>client</code> 程序用服务器的公钥对 PMS 进行加密，并将加密后的 PMS 发送给服务器，服务器再用 RSA 密钥对的私钥对 PMS 信息进行解密：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">              +-------------------+ encrypted PMS  +--------------------+</span><br><span class="line">client PMS---&gt;|server’s public key|---------------&gt;|server’s private key|---&gt;server PMS</span><br><span class="line">              +-------------------+                +--------------------+</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在这个过程结束时，<code>client</code> 程序和 Google Web 服务器现在拥有相同的 PMS 位。每一方都使用这些位生成一个<ruby>主密码 <rt>master secret</rt></ruby>，并立即生成一个称为<ruby>会话密钥 <rt>session key</rt></ruby>的对称加密&#x2F;解密密钥。现在有两个不同但等价的会话密钥，连接的每一方都有一个。在 <code>client</code> 的例子中，会话密钥是 AES128 类的。一旦在 <code>client</code> 程序和 Google Web 服务器两边生成了会话密钥，每一边的会话密钥就会对双方的对话进行保密。如果任何一方（例如，<code>client</code> 程序）或另一方（在这种情况下，Google Web 服务器）要求重新开始握手，握手协议（如 Diffie-Hellman）允许整个 PMS 过程重复进行。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在命令行上说明的 OpenSSL 操作也可以通过底层库的 API 完成。这两篇文章重点使用了这个实用程序，以保持例子的简短，并专注于加密主题。如果你对安全问题感兴趣，OpenSSL 是一个很好的开始地方，并值得深入研究。</p><hr><p>via: <a target="_blank" rel="noopener" href="https://opensource.com/article/19/6/cryptography-basics-openssl-part-2">https://opensource.com/article/19/6/cryptography-basics-openssl-part-2</a></p><p>作者：<a target="_blank" rel="noopener" href="https://opensource.com/users/mkalindepauledu">Marty Kalin</a> 选题：<a target="_blank" rel="noopener" href="https://github.com/lujun9972">lujun9972</a> 译者：<a target="_blank" rel="noopener" href="https://github.com/wxy">wxy</a> 校对：<a target="_blank" rel="noopener" href="https://github.com/wxy">wxy</a></p><p>本文由 <a target="_blank" rel="noopener" href="https://github.com/LCTT/TranslateProject">LCTT</a> 原创编译，<a target="_blank" rel="noopener" href="https://linux.cn/">Linux中国</a> 荣誉推出</p></div></div></div><div class="footer"><p class="footer-copyright"><span>Powered by <a target="_blank" href="https://hexo.io">Hexo</a></span> <span>Theme <a target="_blank" href="https://github.com/tinkink-co/hexo-theme-terminal">Terminal</a></span><script type="text/javascript" src="https://cdn.staticfile.net/jquery/3.4.1/jquery.min.js"></script><script>getCDNinfo=function(){$.ajax({url:"/cdn-cgi/trace",success:function(a,n){let i="Antananarivo, Madagascar - (TNR);Cape Town, South Africa - (CPT);Casablanca, Morocco - (CMN);Dar Es Salaam, Tanzania - (DAR);Djibouti City, Djibouti - (JIB);Durban, South Africa - (DUR);Johannesburg, South Africa - (JNB);Kigali, Rwanda - (KGL);Lagos, Nigeria - (LOS);Luanda, Angola - (LAD);Maputo, MZ - (MPM);Mombasa, Kenya - (MBA);Port Louis, Mauritius - (MRU);Réunion, France - (RUN);Bangalore, India - (BLR);Bangkok, Thailand - (BKK);Bandar Seri Begawan, Brunei - (BWN);Cebu, Philippines - (CEB);Chengdu, China - (CTU);Chennai, India - (MAA);Chittagong, Bangladesh - (CGP);Chongqing, China - (CKG);Colombo, Sri Lanka - (CMB);Dhaka, Bangladesh - (DAC);Dongguan, China - (SZX);Foshan, China - (FUO);Fuzhou, China - (FOC);Guangzhou, China - (CAN);Hangzhou, China - (HGH);Hanoi, Vietnam - (HAN);Hengyang, China - (HNY);Ho Chi Minh City, Vietnam - (SGN);Hong Kong - (HKG);Hyderabad, India - (HYD);Islamabad, Pakistan - (ISB);Jakarta, Indonesia - (CGK);Jinan, China - (TNA);Karachi, Pakistan - (KHI);Kathmandu, Nepal - (KTM);Kolkata, India - (CCU);Kuala Lumpur, Malaysia - (KUL);Lahore, Pakistan - (LHE);Langfang, China - (NAY);Luoyang, China - (LYA);Macau - (MFM);Malé, Maldives - (MLE);Manila, Philippines - (MNL);Mumbai, India - (BOM);Nagpur, India - (NAG);Nanning, China - (NNG);New Delhi, India - (DEL);Osaka, Japan - (KIX);Phnom Penh, Cambodia - (PNH);Qingdao, China - (TAO);Seoul, South Korea - (ICN);Shanghai, China - (SHA);Shenyang, China - (SHE);Shijiazhuang, China - (SJW);Singapore, Singapore - (SIN);Suzhou, China - (SZV);Taipei - (TPE);Thimphu, Bhutan - (PBH);Tianjin, China - (TSN);Tokyo, Japan - (NRT);Ulaanbaatar, Mongolia - (ULN);Vientiane, Laos - (VTE);Wuhan, China - (WUH);Wuxi, China - (WUX);Xi'an, China - (XIY);Yerevan, Armenia - (EVN);Zhengzhou, China - (CGO);Zuzhou, China - (CSX);Amsterdam, Netherlands - (AMS);Athens, Greece - (ATH);Barcelona, Spain - (BCN);Belgrade, Serbia - (BEG);Berlin, Germany - (TXL);Brussels, Belgium - (BRU);Bucharest, Romania - (OTP);Budapest, Hungary - (BUD);Chișinău, Moldova - (KIV);Copenhagen, Denmark - (CPH);Cork, Ireland -  (ORK);Dublin, Ireland - (DUB);Düsseldorf, Germany - (DUS);Edinburgh, United Kingdom - (EDI);Frankfurt, Germany - (FRA);Geneva, Switzerland - (GVA);Gothenburg, Sweden - (GOT);Hamburg, Germany - (HAM);Helsinki, Finland - (HEL);Istanbul, Turkey - (IST);Kyiv, Ukraine - (KBP);Lisbon, Portugal - (LIS);London, United Kingdom - (LHR);Luxembourg City, Luxembourg - (LUX);Madrid, Spain - (MAD);Manchester, United Kingdom - (MAN);Marseille, France - (MRS);Milan, Italy - (MXP);Moscow, Russia - (DME);Munich, Germany - (MUC);Nicosia, Cyprus - (LCA);Oslo, Norway - (OSL);Paris, France - (CDG);Prague, Czech Republic - (PRG);Reykjavík, Iceland - (KEF);Riga, Latvia - (RIX);Rome, Italy - (FCO);Saint Petersburg, Russia - (LED);Sofia, Bulgaria - (SOF);Stockholm, Sweden - (ARN);Tallinn, Estonia - (TLL);Thessaloniki, Greece - (SKG);Vienna, Austria - (VIE);Vilnius, Lithuania - (VNO);Warsaw, Poland - (WAW);Zagreb, Croatia - (ZAG);Zürich, Switzerland - (ZRH);Arica, Chile - (ARI);Asunción, Paraguay - (ASU);Bogotá, Colombia - (BOG);Buenos Aires, Argentina - (EZE);Curitiba, Brazil - (CWB);Fortaleza, Brazil - (FOR);Guatemala City, Guatemala - (GUA);Lima, Peru - (LIM);Medellín, Colombia - (MDE);Panama City, Panama - (PTY);Porto Alegre, Brazil - (POA);Quito, Ecuador - (UIO);Rio de Janeiro, Brazil - (GIG);São Paulo, Brazil - (GRU);Santiago, Chile - (SCL);Willemstad, Curaçao - (CUR);St. George's, Grenada - (GND);Amman, Jordan - (AMM);Baghdad, Iraq - (BGW);Baku, Azerbaijan - (GYD);Beirut, Lebanon - (BEY);Doha, Qatar - (DOH);Dubai, United Arab Emirates - (DXB);Kuwait City, Kuwait - (KWI);Manama, Bahrain - (BAH);Muscat, Oman - (MCT);Ramallah - (ZDM);Riyadh, Saudi Arabia - (RUH);Tel Aviv, Israel - (TLV);Ashburn, VA, United States - (IAD);Atlanta, GA, United States - (ATL);Boston, MA, United States - (BOS);Buffalo, NY, United States - (BUF);Calgary, AB, Canada - (YYC);Charlotte, NC, United States - (CLT);Chicago, IL, United States - (ORD);Columbus, OH, United States - (CMH);Dallas, TX, United States - (DFW);Denver, CO, United States - (DEN);Detroit, MI, United States - (DTW);Honolulu, HI, United States - (HNL);Houston, TX, United States - (IAH);Indianapolis, IN, United States - (IND);Jacksonville, FL, United States - (JAX);Kansas City, MO, United States - (MCI);Las Vegas, NV, United States - (LAS);Los Angeles, CA, United States - (LAX);McAllen, TX, United States - (MFE);Memphis, TN, United States - (MEM);Mexico City, Mexico - (MEX);Miami, FL, United States - (MIA);Minneapolis, MN, United States - (MSP);Montgomery, AL, United States - (MGM);Montréal, QC, Canada - (YUL);Nashville, TN, United States - (BNA);Newark, NJ, United States - (EWR);Norfolk, VA, United States - (ORF);Omaha, NE, United States - (OMA);Philadelphia, United States - (PHL);Phoenix, AZ, United States - (PHX);Pittsburgh, PA, United States - (PIT);Port-Au-Prince, Haiti - (PAP);Portland, OR, United States - (PDX);Queretaro, MX, Mexico - (QRO);Richmond, Virginia - (RIC);Sacramento, CA, United States - (SMF);Salt Lake City, UT, United States - (SLC);San Diego, CA, United States - (SAN);San Jose, CA, United States - (SJC);Saskatoon, SK, Canada - (YXE);Seattle, WA, United States - (SEA);St. Louis, MO, United States - (STL);Tampa, FL, United States - (TPA);Toronto, ON, Canada - (YYZ);Vancouver, BC, Canada - (YVR);Tallahassee, FL, United States - (TLH);Winnipeg, MB, Canada - (YWG);Adelaide, SA, Australia - (ADL);Auckland, New Zealand - (AKL);Brisbane, QLD, Australia - (BNE);Melbourne, VIC, Australia - (MEL);Noumea, New caledonia - (NOU);Perth, WA, Australia - (PER);Sydney, NSW, Australia - (SYD)".split(";"),e=a.split("colo=")[1].split("\n")[0],t=(a.split("colo=")[1].split("\n")[0],a.split("tls=")[1].split("\n")[0]),o=a.split("http=")[1].split("\n")[0],s=a.split("sni=")[1].split("\n")[0],r=a.split("ip=")[1].split("\n")[0],l=a.split("uag=")[1].split("\n")[0];for(var d=0;d<i.length;d++)if(-1!=i[d].indexOf(e)){document.getElementById("cdn").innerHTML=i[d];break}document.getElementById("tls").innerHTML=t,document.getElementById("http").innerHTML=o,document.getElementById("sni").innerHTML=s,document.getElementById("ip").innerHTML=r,document.getElementById("useragent").innerHTML=l}})},$(document).ready((function(){getCDNinfo()}))</script></p><p style="text-align:center">感谢陪伴与布道，开源之火不灭。​</p><p style="text-align:center"><script>document.write("本次加载耗时: "+(performance.getEntriesByType("navigation").reduce((e,r)=>e+r.responseEnd-r.startTime,0)+performance.getEntriesByType("resource").reduce((e,r)=>e+r.responseEnd-r.startTime,0)).toFixed(0)+"ms")</script></p><p style="text-align:center">当前 SNI 状态： <span id="sni">正在统计！或可能被浏览器防追踪拦截！</span></p><p style="text-align:center">当前 TLS 版本： <span id="tls">正在统计！或可能被浏览器防追踪拦截！</span></p><p style="text-align:center">当前 HTTP 版本： <span id="http">正在统计！或可能被浏览器防追踪拦截！</span></p><p style="text-align:center">当前您的客户端 IP 是： <span id="ip">正在统计！或可能被浏览器防追踪拦截！</span></p><p style="text-align:center">当前分配的 CDN 节点是: <span id="cdn">正在统计！或可能被浏览器防追踪拦截！</span></p><p style="text-align:center">您的 UserAgent 信息是: <span id="useragent">正在统计！或可能被浏览器防追踪拦截！</span></p><p></p></div></div></body></html>