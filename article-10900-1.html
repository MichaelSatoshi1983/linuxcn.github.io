<!doctype html><html lang="en"><head><meta name="description" content="一个LinuxCN的镜像站"><meta name="msvalidate.01" content="D404690CEFCB54C7762AC84935B99171"><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?6618da70c90c8744eead2e9371fb5077";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><script type="text/javascript">!function(t,e,n,c,s,a,r){t[n]=t[n]||function(){(t[n].q=t[n].q||[]).push(arguments)},(a=e.createElement(c)).async=1,a.src="https://www.clarity.ms/tag/s5f3f0tojf",(r=e.getElementsByTagName(c)[0]).parentNode.insertBefore(a,r)}(window,document,"clarity","script")</script><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta http-equiv="X-UA-Compatible" content="ie=edge"><link rel="stylesheet" href="/styles/base.css"><link rel="stylesheet" href="/styles/theme.css"><link rel="shortcut icon" href="/favicon.png"><title>API 演进的正确方式 - 归墟星火集 又一个 LinuxCN 站点</title><meta name="generator" content="Hexo 7.3.0"></head><body><div class="header-title"><span class="header-light"></span> <span class="header-light"></span> <span class="header-light"></span> <span>归墟星火集 又一个 LinuxCN 站点 linuxcn.undefined.today<span></span></span></div><div class="container"><ul class="nav"><li><a href="/">首页</a></li><li><a target="_blank" rel="noopener" href="https://undefined.today/">Blog</a></li></ul><div class="content"><div class="post-container"><div class="post-header"><span class="ui-tips">标题：</span><h1 class="ui-keyword post-title">API 演进的正确方式</h1><span class="post-date">2019-05-26</span></div><div class="post-header"><span class="ui-tips">分类：</span> <a href="/categories/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/">软件开发</a></div><div class="post-header"><span class="ui-tips">标签：</span> <a href="/tags/Python/">Python</a> <a href="/tags/%E7%B1%BB%E5%BA%93/">类库</a></div><div class="post-content"><blockquote><p>负责任的库作者与其用户的十个约定。</p></blockquote><p><img src="https://linuxcn.img.undefined.today/data/attachment/album/201905/26/134131jnymeg7t7gmo6qcy.jpg"></p><p>想象一下你是一个造物主，为一个生物设计一个身体。出于仁慈，你希望它能随着时间进化：首先，因为它必须对环境的变化作出反应；其次，因为你的智慧在增长，你对这个小东西想到了更好的设计，它不应该永远保持一个样子。</p><p><img src="https://linuxcn.img.undefined.today/data/attachment/album/201905/26/134220rxfsxpef7pmk1wzy.jpg" alt="Serpents" title="Serpents"></p><p>然而，这个生物可能有赖于其目前解剖学的特征。你不能无所顾忌地添加翅膀或改变它的身材比例。它需要一个有序的过程来适应新的身体。作为一个负责任的设计者，你如何才能温柔地引导这种生物走向更大的进步呢？</p><p>对于负责任的库维护者也是如此。我们向依赖我们代码的人保证我们的承诺：我们会发布 bug 修复和有用的新特性。如果对库的未来有利，我们有时会删除某些特性。我们会不断创新，但我们不会破坏使用我们库的人的代码。我们怎样才能一次实现所有这些目标呢？</p><h3 id="添加有用的特性"><a href="#添加有用的特性" class="headerlink" title="添加有用的特性"></a>添加有用的特性</h3><p>你的库不应该永远保持不变：你应该添加一些特性，使你的库更适合用户。例如，如果你有一个爬行动物类，并且如果有个可以飞行的翅膀是有用的，那就去添加吧。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Reptile:</span><br><span class="line">    @property</span><br><span class="line">    def teeth(self):</span><br><span class="line">        return &#x27;sharp fangs&#x27;</span><br><span class="line"></span><br><span class="line">    # 如果 wings 是有用的，那就添加它!</span><br><span class="line">    @property</span><br><span class="line">    def wings(self):</span><br><span class="line">        return &#x27;majestic wings&#x27;</span><br></pre></td></tr></table></figure><p>但要注意，特性是有风险的。考虑 Python 标准库中以下功能，看看它出了什么问题。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bool(datetime.time(9, 30)) == True</span><br><span class="line">bool(datetime.time(0, 0)) == False</span><br></pre></td></tr></table></figure><p>这很奇怪：将任何时间对象转换为布尔值都会得到 True，但午夜时间除外。（更糟糕的是，时区感知时间的规则更加奇怪。）</p><p>我已经写了十多年的 Python 了，但直到上周才发现这条规则。这种奇怪的行为会在用户代码中引起什么样的 bug？</p><p>比如说一个日历应用程序，它带有一个创建事件的函数。如果一个事件有一个结束时间，那么函数也应该要求它有一个开始时间。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">def create_event(day,</span><br><span class="line">                 start_time=None,</span><br><span class="line">                 end_time=None):</span><br><span class="line">    if end_time and not start_time:</span><br><span class="line">        raise ValueError(&quot;Can&#x27;t pass end_time without start_time&quot;)</span><br><span class="line"></span><br><span class="line">    # 女巫集会从午夜一直开到凌晨 4 点</span><br><span class="line">create_event(datetime.date.today(),</span><br><span class="line">             datetime.time(0, 0),</span><br><span class="line">             datetime.time(4, 0))</span><br></pre></td></tr></table></figure><p>不幸的是，对于女巫来说，从午夜开始的事件无法通过校验。当然，一个了解午夜怪癖的细心程序员可以正确地编写这个函数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def create_event(day,</span><br><span class="line">                 start_time=None,</span><br><span class="line">                 end_time=None):</span><br><span class="line">    if end_time is not None and start_time is None:</span><br><span class="line">        raise ValueError(&quot;Can&#x27;t pass end_time without start_time&quot;)</span><br></pre></td></tr></table></figure><p>但这种微妙之处令人担忧。如果一个库作者想要创建一个伤害用户的 API，那么像午夜的布尔转换这样的“特性”很有效。</p><p><img src="https://linuxcn.img.undefined.today/data/attachment/album/201905/26/134226k5f1mglbupccp6px.jpg" alt="Man being chased by an alligator" title="Man being chased by an alligator"></p><p>但是，负责任的创建者的目标是使你的库易于正确使用。</p><p>这个功能是由 Tim Peters 在 2002 年首次编写 datetime 模块时造成的。即时是像 Tim 这样的奠基 Python 的高手也会犯错误。<a target="_blank" rel="noopener" href="https://bugs.python.org/issue13936">这个怪异之处后来被消除了</a>，现在所有时间的布尔值都是 True。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># Python 3.5 以后</span><br><span class="line"></span><br><span class="line">bool(datetime.time(9, 30)) == True</span><br><span class="line">bool(datetime.time(0, 0)) == True</span><br></pre></td></tr></table></figure><p>不知道午夜怪癖的古怪之处的程序员现在可以从这种晦涩的 bug 中解脱出来，但是一想到任何依赖于古怪的旧行为的代码现在没有注意变化，我就会感到紧张。如果从来没有实现这个糟糕的特性，情况会更好。这就引出了库维护者的第一个承诺：</p><h4 id="第一个约定：避免糟糕的特性"><a href="#第一个约定：避免糟糕的特性" class="headerlink" title="第一个约定：避免糟糕的特性"></a>第一个约定：避免糟糕的特性</h4><p>最痛苦的变化是你必须删除一个特性。一般来说，避免糟糕特性的一种方法是少添加特性！没有充分的理由，不要使用公共方法、类、功能或属性。因此：</p><h4 id="第二个约定：最小化特性"><a href="#第二个约定：最小化特性" class="headerlink" title="第二个约定：最小化特性"></a>第二个约定：最小化特性</h4><p>特性就像孩子：在充满激情的瞬间孕育，但是它们必须要支持多年（LCTT 译注：我怀疑作者在开车，可是我没有证据）。不要因为你能做傻事就去做傻事。不要画蛇添足！</p><p><img src="https://linuxcn.img.undefined.today/data/attachment/album/201905/26/134229yys47cug7acisiyy.jpg" alt="Serpents with and without feathers" title="Serpents with and without feathers"></p><p>但是，当然，在很多情况下，用户需要你的库中尚未提供的东西，你如何选择合适的功能给他们？以下另一个警示故事。</p><h3 id="一个来自-asyncio-的警示故事"><a href="#一个来自-asyncio-的警示故事" class="headerlink" title="一个来自 asyncio 的警示故事"></a>一个来自 asyncio 的警示故事</h3><p>你可能知道，当你调用一个协程函数，它会返回一个协程对象：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">async def my_coroutine():</span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line">print(my_coroutine())</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;coroutine object my_coroutine at 0x10bfcbac8&gt;</span><br></pre></td></tr></table></figure><p>你的代码必须 “<ruby>等待 <rt>await</rt></ruby>” 这个对象以此来运行协程。人们很容易忘记这一点，所以 asyncio 的开发人员想要一个“调试模式”来捕捉这个错误。当协程在没有等待的情况下被销毁时，调试模式将打印一个警告，并在其创建的行上进行回溯。</p><p>当 Yury Selivanov 实现调试模式时，他添加了一个“协程装饰器”的基础特性。装饰器是一个函数，它接收一个协程并返回任何内容。Yury 使用它在每个协程上接入警告逻辑，但是其他人可以使用它将协程转换为字符串 “hi!”。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import sys</span><br><span class="line"></span><br><span class="line">def my_wrapper(coro):</span><br><span class="line">    return &#x27;hi!&#x27;</span><br><span class="line"></span><br><span class="line">sys.set_coroutine_wrapper(my_wrapper)</span><br><span class="line"></span><br><span class="line">async def my_coroutine():</span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line">print(my_coroutine())</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hi!</span><br></pre></td></tr></table></figure><p>这是一个地狱般的定制。它改变了 “<ruby>异步 <rt>async</rt></ruby>“ 的含义。调用一次 <code>set_coroutine_wrapper</code> 将在全局永久改变所有的协程函数。正如 <a target="_blank" rel="noopener" href="https://bugs.python.org/issue32591">Nathaniel Smith 所说</a>：“一个有问题的 API” 很容易被误用，必须被删除。如果 asyncio 开发人员能够更好地按照其目标来设计该特性，他们就可以避免删除该特性的痛苦。负责任的创建者必须牢记这一点：</p><h4 id="第三个约定：保持特性单一"><a href="#第三个约定：保持特性单一" class="headerlink" title="第三个约定：保持特性单一"></a>第三个约定：保持特性单一</h4><p>幸运的是，Yury 有良好的判断力，他将该特性标记为临时，所以 asyncio 用户知道不能依赖它。Nathaniel 可以用更单一的功能替换 <code>set_coroutine_wrapper</code>，该特性只定制回溯深度。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import sys</span><br><span class="line"></span><br><span class="line">sys.set_coroutine_origin_tracking_depth(2)</span><br><span class="line"></span><br><span class="line">async def my_coroutine():</span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line">print(my_coroutine())</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;coroutine object my_coroutine at 0x10bfcbac8&gt;</span><br><span class="line"></span><br><span class="line">RuntimeWarning:&#x27;my_coroutine&#x27; was never awaited</span><br><span class="line"></span><br><span class="line">Coroutine created at (most recent call last)</span><br><span class="line">    File &quot;script.py&quot;, line 8, in &lt;module&gt;</span><br><span class="line">        print(my_coroutine())</span><br></pre></td></tr></table></figure><p>这样好多了。没有可以更改协程的类型的其他全局设置，因此 asyncio 用户无需编写防御代码。造物主应该像 Yury 一样有远见。</p><h4 id="第四个约定：标记实验特征“临时”"><a href="#第四个约定：标记实验特征“临时”" class="headerlink" title="第四个约定：标记实验特征“临时”"></a>第四个约定：标记实验特征“临时”</h4><p>如果你只是预感你的生物需要犄角和四叉舌，那就引入这些特性，但将它们标记为“临时”。</p><p><img src="https://linuxcn.img.undefined.today/data/attachment/album/201905/26/134230k6rhvv5o9aov9aw5.jpg" alt="Serpent with horns" title="Serpent with horns"></p><p>你可能会发现犄角是无关紧要的，但是四叉舌是有用的。在库的下一个版本中，你可以删除前者并标记后者为正式的。</p><h3 id="删除特性"><a href="#删除特性" class="headerlink" title="删除特性"></a>删除特性</h3><p>无论我们如何明智地指导我们的生物进化，总会有一天想要删除一个正式特征。例如，你可能已经创建了一只蜥蜴，现在你选择删除它的腿。也许你想把这个笨拙的家伙变成一条时尚而现代的蟒蛇。</p><p><img src="https://linuxcn.img.undefined.today/data/attachment/album/201905/26/134235hhu4kk9984kknk9k.jpg" alt="Lizard transformed to snake" title="Lizard transformed to snake"></p><p>删除特性主要有两个原因。首先，通过用户反馈或者你自己不断增长的智慧，你可能会发现某个特性是个坏主意。午夜怪癖的古怪行为就是这种情况。或者，最初该特性可能已经很好地适应了你的库环境，但现在生态环境发生了变化，也许另一个神发明了哺乳动物，你的生物想要挤进哺乳动物的小洞穴里，吃掉里面美味的哺乳动物，所以它不得不失去双腿。</p><p><img src="https://linuxcn.img.undefined.today/data/attachment/album/201905/26/134240iiixxm7p7pdp8xzw.jpg" alt="A mouse" title="A mouse"></p><p>同样，Python 标准库会根据语言本身的变化删除特性。考虑 asyncio 的 Lock 功能，在把 <code>await</code> 作为一个关键字添加进来之前，它一直在等待：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">lock = asyncio.Lock()</span><br><span class="line"></span><br><span class="line">async def critical_section():</span><br><span class="line">    await lock</span><br><span class="line">    try:</span><br><span class="line">        print(&#x27;holding lock&#x27;)</span><br><span class="line">    finally:</span><br><span class="line">        lock.release()</span><br></pre></td></tr></table></figure><p>但是现在，我们可以做“异步锁”：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">lock = asyncio.Lock()</span><br><span class="line"></span><br><span class="line">async def critical_section():</span><br><span class="line">    async with lock:</span><br><span class="line">        print(&#x27;holding lock&#x27;)</span><br></pre></td></tr></table></figure><p>新方法好多了！很短，并且在一个大函数中使用其他 try-except 块时不容易出错。因为“尽量找一种，最好是唯一一种明显的解决方案”，<a target="_blank" rel="noopener" href="https://bugs.python.org/issue32253">旧语法在 Python 3.7 中被弃用</a>，并且很快就会被禁止。</p><p>不可避免的是，生态变化会对你的代码产生影响，因此要学会温柔地删除特性。在此之前，请考虑删除它的成本或好处。负责任的维护者不会愿意让用户更改大量代码或逻辑。（还记得 Python 3 在重新添加会 <code>u</code> 字符串前缀之前删除它是多么痛苦吗？）如果代码删除是机械性的动作，就像一个简单的搜索和替换，或者如果该特性是危险的，那么它可能值得删除。</p><h4 id="是否删除特性"><a href="#是否删除特性" class="headerlink" title="是否删除特性"></a>是否删除特性</h4><p><img src="https://linuxcn.img.undefined.today/data/attachment/album/201905/26/134242nn31guu3bx4gqe4t.jpg" alt="Balance scales" title="Balance scales"></p><table><thead><tr><th>反对</th><th>支持</th></tr></thead><tbody><tr><td>代码必须改变</td><td>改变是机械性的</td></tr><tr><td>逻辑必须改变</td><td>特性是危险的</td></tr></tbody></table><p>就我们饥饿的蜥蜴而言，我们决定删除它的腿，这样它就可以滑进老鼠洞里吃掉它。我们该怎么做呢？我们可以删除 <code>walk</code> 方法，像下面一样修改代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class Reptile:</span><br><span class="line">    def walk(self):</span><br><span class="line">        print(&#x27;step step step&#x27;)</span><br></pre></td></tr></table></figure><p>变成这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class Reptile:</span><br><span class="line">    def slither(self):</span><br><span class="line">        print(&#x27;slide slide slide&#x27;)</span><br></pre></td></tr></table></figure><p>这不是一个好主意，这个生物习惯于走路！或者，就库而言，你的用户拥有依赖于现有方法的代码。当他们升级到最新库版本时，他们的代码将会崩溃。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 用户的代码，哦，不!</span><br><span class="line">Reptile.walk()</span><br></pre></td></tr></table></figure><p>因此，负责任的创建者承诺：</p><h4 id="第五条预定：温柔地删除"><a href="#第五条预定：温柔地删除" class="headerlink" title="第五条预定：温柔地删除"></a>第五条预定：温柔地删除</h4><p>温柔地删除一个特性需要几个步骤。从用腿走路的蜥蜴开始，首先添加新方法 <code>slither</code>。接下来，弃用旧方法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import warnings</span><br><span class="line"></span><br><span class="line">class Reptile:</span><br><span class="line">    def walk(self):</span><br><span class="line">        warnings.warn(</span><br><span class="line">                &quot;walk is deprecated, use slither&quot;,</span><br><span class="line">                 DeprecationWarning, stacklevel=2)</span><br><span class="line">        print(&#x27;step step step&#x27;)</span><br><span class="line"></span><br><span class="line">    def slither(self):</span><br><span class="line">        print(&#x27;slide slide slide&#x27;)</span><br></pre></td></tr></table></figure><p>Python 的 warnings 模块非常强大。默认情况下，它会将警告输出到 stderr，每个代码位置只显示一次，但你可以禁用警告或将其转换为异常，以及其它选项。</p><p>一旦将这个警告添加到库中，PyCharm 和其他 IDE 就会使用删除线呈现这个被弃用的方法。用户马上就知道该删除这个方法。</p><blockquote><p>Reptile().<del>walk()</del></p></blockquote><p>当他们使用升级后的库运行代码时会发生什么？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ python3 script.py</span><br><span class="line"></span><br><span class="line">DeprecationWarning: walk is deprecated, use slither</span><br><span class="line">    script.py:14: Reptile().walk()</span><br><span class="line"></span><br><span class="line">step step step</span><br></pre></td></tr></table></figure><p>默认情况下，他们会在 stderr 上看到警告，但脚本会成功并打印 “step step step”。警告的回溯显示必须修复用户代码的哪一行。（这就是 <code>stacklevel</code> 参数的作用：它显示了用户需要更改的调用，而不是库中生成警告的行。）请注意，错误消息有指导意义，它描述了库用户迁移到新版本必须做的事情。</p><p>你的用户可能会希望测试他们的代码，并证明他们没有调用弃用的库方法。仅警告不会使单元测试失败，但异常会失败。Python 有一个命令行选项，可以将弃用警告转换为异常。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; python3 -Werror::DeprecationWarning script.py</span><br><span class="line"></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">    File &quot;script.py&quot;, line 14, in &lt;module&gt;</span><br><span class="line">        Reptile().walk()</span><br><span class="line">    File &quot;script.py&quot;, line 8, in walk</span><br><span class="line">        DeprecationWarning, stacklevel=2)</span><br><span class="line">DeprecationWarning: walk is deprecated, use slither</span><br></pre></td></tr></table></figure><p>现在，“step step step” 没有输出出来，因为脚本以一个错误终止。</p><p>因此，一旦你发布了库的一个版本，该版本会警告已启用的 <code>walk</code> 方法，你就可以在下一个版本中安全地删除它。对吧？</p><p>考虑一下你的库用户在他们项目的 <code>requirements</code> 中可能有什么。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 用户的 requirements.txt 显示 reptile 包的依赖关系</span><br><span class="line">reptile</span><br></pre></td></tr></table></figure><p>下次他们部署代码时，他们将安装最新版本的库。如果他们尚未处理所有的弃用，那么他们的代码将会崩溃，因为代码仍然依赖 <code>walk</code>。你需要温柔一点，你必须向用户做出三个承诺：维护更改日志，选择版本化方案和编写升级指南。</p><h4 id="第六个约定：维护变更日志"><a href="#第六个约定：维护变更日志" class="headerlink" title="第六个约定：维护变更日志"></a>第六个约定：维护变更日志</h4><p>你的库必须有更改日志，其主要目的是宣布用户所依赖的功能何时被弃用或删除。</p><blockquote><p><strong>版本 1.1 中的更改</strong></p><p><strong>新特性</strong></p><ul><li>新功能 Reptile.slither()</li></ul><p><strong>弃用</strong></p><ul><li>Reptile.walk() 已弃用，将在 2.0 版本中删除，请使用 slither()</li></ul></blockquote><p>负责任的创建者会使用版本号来表示库发生了怎样的变化，以便用户能够对升级做出明智的决定。“版本化方案”是一种用于交流变化速度的语言。</p><h4 id="第七个约定：选择一个版本化方案"><a href="#第七个约定：选择一个版本化方案" class="headerlink" title="第七个约定：选择一个版本化方案"></a>第七个约定：选择一个版本化方案</h4><p>有两种广泛使用的方案，<a target="_blank" rel="noopener" href="https://semver.org/">语义版本控制</a>和基于时间的版本控制。我推荐任何库都进行语义版本控制。Python 的风格在 <a target="_blank" rel="noopener" href="https://www.python.org/dev/peps/pep-0440/">PEP 440</a> 中定义，像 <code>pip</code> 这样的工具可以理解语义版本号。</p><p>如果你为库选择语义版本控制，你可以使用版本号温柔地删除腿，例如：</p><blockquote><p>1.0: 第一个“稳定”版，带有 <code>walk()</code> 1.1: 添加 <code>slither()</code>，废弃 <code>walk()</code> 2.0: 删除 <code>walk()</code></p></blockquote><p>你的用户依赖于你的库的版本应该有一个范围，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 用户的 requirements.txt</span><br><span class="line">reptile&gt;=1,&lt;2</span><br></pre></td></tr></table></figure><p>这允许他们在主要版本中自动升级，接收错误修正并可能引发一些弃用警告，但不会升级到<strong>下</strong>个主要版本并冒着更改破坏其代码的风险。</p><p>如果你遵循基于时间的版本控制，则你的版本可能会编号：</p><blockquote><p>2017.06.0: 2017 年 6 月的版本 2018.11.0: 添加 <code>slither()</code>，废弃 <code>walk()</code> 2019.04.0: 删除 <code>walk()</code></p></blockquote><p>用户可以这样依赖于你的库：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 用户的 requirements.txt，基于时间控制的版本</span><br><span class="line">reptile==2018.11.*</span><br></pre></td></tr></table></figure><p>这非常棒，但你的用户如何知道你的版本方案，以及如何测试代码来进行弃用呢？你必须告诉他们如何升级。</p><h4 id="第八个约定：写一个升级指南"><a href="#第八个约定：写一个升级指南" class="headerlink" title="第八个约定：写一个升级指南"></a>第八个约定：写一个升级指南</h4><p>下面是一个负责任的库创建者如何指导用户：</p><blockquote><p><strong>升级到 2.0</strong></p><p><strong>从弃用的 API 迁移</strong></p><p>请参阅更改日志以了解已弃用的特性。</p><p><strong>启用弃用警告</strong></p><p>升级到 1.1 并使用以下代码测试代码：</p><p><code>python -Werror::DeprecationWarning</code></p><p>​​​​​​ 现在可以安全地升级了。</p></blockquote><p>你必须通过向用户显示命令行选项来教会用户如何处理弃用警告。并非所有 Python 程序员都知道这一点 —— 我自己就每次都得查找这个语法。注意，你必须<em>发布</em>一个版本，它输出来自每个弃用的 API 的警告，以便用户可以在再次升级之前使用该版本进行测试。在本例中，1.1 版本是小版本。它允许你的用户逐步重写代码，分别修复每个弃用警告，直到他们完全迁移到最新的 API。他们可以彼此独立地测试代码和库的更改，并隔离 bug 的原因。</p><p>如果你选择语义版本控制，则此过渡期将持续到下一个主要版本，从 1.x 到 2.0，或从 2.x 到 3.0 以此类推。删除生物腿部的温柔方法是至少给它一个版本来调整其生活方式。不要一次性把腿删掉！</p><p><img src="https://linuxcn.img.undefined.today/data/attachment/album/201905/26/134245ypfefay2pwy4hfly.jpg" alt="A skink" title="A skink"></p><p>版本号、弃用警告、更改日志和升级指南可以协同工作，在不违背与用户约定的情况下温柔地改进你的库。<a target="_blank" rel="noopener" href="https://twistedmatrix.com/documents/current/core/development/policy/compatibility-policy.html">Twisted 项目的兼容性政策</a> 解释的很漂亮：</p><blockquote><p>“先行者总是自由的”</p><p>运行的应用程序在没有任何警告的情况下都可以升级为 Twisted 的一个次要版本。</p><p>换句话说，任何运行其测试而不触发 Twisted 警告的应用程序应该能够将其 Twisted 版本升级至少一次，除了可能产生新警告之外没有任何不良影响。</p></blockquote><p>现在，我们的造物主已经获得了智慧和力量，可以通过添加方法来添加特性，并温柔地删除它们。我们还可以通过添加参数来添加特性，但这带来了新的难度。你准备好了吗？</p><h3 id="添加参数"><a href="#添加参数" class="headerlink" title="添加参数"></a>添加参数</h3><p>想象一下，你只是给了你的蛇形生物一对翅膀。现在你必须允许它选择是滑行还是飞行。目前它的 <code>move</code> 功能只接受一个参数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 你的库代码</span><br><span class="line">def move(direction):</span><br><span class="line">    print(f&#x27;slither &#123;direction&#125;&#x27;)</span><br><span class="line"></span><br><span class="line"># 用户的应用</span><br><span class="line">move(&#x27;north&#x27;)</span><br></pre></td></tr></table></figure><p>你想要添加一个 <code>mode</code> 参数，但如果用户升级库，这会破坏他们的代码，因为他们只传递了一个参数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 你的库代码</span><br><span class="line">def move(direction, mode):</span><br><span class="line">    assert mode in (&#x27;slither&#x27;, &#x27;fly&#x27;)</span><br><span class="line">    print(f&#x27;&#123;mode&#125; &#123;direction&#125;&#x27;)</span><br><span class="line"></span><br><span class="line"># 一个用户的代码，出现错误!</span><br><span class="line">move(&#x27;north&#x27;)</span><br></pre></td></tr></table></figure><p>一个真正聪明的创建者者会承诺不会以这种方式破坏用户的代码。</p><h4 id="第九条约定：兼容地添加参数"><a href="#第九条约定：兼容地添加参数" class="headerlink" title="第九条约定：兼容地添加参数"></a>第九条约定：兼容地添加参数</h4><p>要保持这个约定，请使用保留原始行为的默认值添加每个新参数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 你的库代码</span><br><span class="line">def move(direction, mode=&#x27;slither&#x27;):</span><br><span class="line">    assert mode in (&#x27;slither&#x27;, &#x27;fly&#x27;)</span><br><span class="line">    print(f&#x27;&#123;mode&#125; &#123;direction&#125;&#x27;)</span><br><span class="line"></span><br><span class="line"># 用户的应用</span><br><span class="line">move(&#x27;north&#x27;)</span><br></pre></td></tr></table></figure><p>随着时间推移，参数是函数演化的自然历史。它们首先列出最老的参数，每个都有默认值。库用户可以传递关键字参数以选择特定的新行为，并接受所有其他行为的默认值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 你的库代码</span><br><span class="line">def move(direction,</span><br><span class="line">         mode=&#x27;slither&#x27;,</span><br><span class="line">         turbo=False,</span><br><span class="line">         extra_sinuous=False,</span><br><span class="line">         hail_lyft=False):</span><br><span class="line">    # ...</span><br><span class="line"></span><br><span class="line"># 用户应用</span><br><span class="line">move(&#x27;north&#x27;, extra_sinuous=True)</span><br></pre></td></tr></table></figure><p>但是有一个危险，用户可能会编写如下代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 用户应用，简写</span><br><span class="line">move(&#x27;north&#x27;, &#x27;slither&#x27;, False, True)</span><br></pre></td></tr></table></figure><p>如果在你在库的下一个主要版本中去掉其中一个参数，例如 <code>turbo</code>，会发生什么？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 你的库代码，下一个主要版本中 &quot;turbo&quot; 被删除</span><br><span class="line">def move(direction,</span><br><span class="line">         mode=&#x27;slither&#x27;,</span><br><span class="line">         extra_sinuous=False,</span><br><span class="line">         hail_lyft=False):</span><br><span class="line">    # ...</span><br><span class="line"></span><br><span class="line"># 用户应用，简写</span><br><span class="line">move(&#x27;north&#x27;, &#x27;slither&#x27;, False, True)</span><br></pre></td></tr></table></figure><p>用户的代码仍然能编译，这是一件坏事。代码停止了曲折的移动并开始招呼 Lyft，这不是它的本意。我相信你可以预测我接下来要说的内容：删除参数需要几个步骤。当然，首先弃用 <code>trubo</code> 参数。我喜欢这种技术，它可以检测任何用户的代码是否依赖于这个参数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># 你的库代码</span><br><span class="line">_turbo_default = object()</span><br><span class="line"></span><br><span class="line">def move(direction,</span><br><span class="line">         mode=&#x27;slither&#x27;,</span><br><span class="line">         turbo=_turbo_default,</span><br><span class="line">         extra_sinuous=False,</span><br><span class="line">         hail_lyft=False):</span><br><span class="line">    if turbo is not _turbo_default:</span><br><span class="line">        warnings.warn(</span><br><span class="line">                &quot;&#x27;turbo&#x27; is deprecated&quot;,</span><br><span class="line">                DeprecationWarning,</span><br><span class="line">                stacklevel=2)</span><br><span class="line">    else:</span><br><span class="line">        # The old default.</span><br><span class="line">        turbo = False</span><br></pre></td></tr></table></figure><p>但是你的用户可能不会注意到警告。警告声音不是很大：它们可以在日志文件中被抑制或丢失。用户可能会漫不经心地升级到库的下一个主要版本——那个删除 <code>turbo</code> 的版本。他们的代码运行时将没有错误、默默做错误的事情！正如 Python 之禅所说：“错误绝不应该被默默 pass”。实际上，爬行动物的听力很差，所有当它们犯错误时，你必须非常大声地纠正它们。</p><p><img src="https://linuxcn.img.undefined.today/data/attachment/album/201905/26/134247pcaszfvmwcqmmwhh.jpg" alt="Woman riding an alligator" title="Woman riding an alligator"></p><p>保护用户的最佳方法是使用 Python 3 的星型语法，它要求调用者传递关键字参数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># 你的库代码</span><br><span class="line"># 所有 “*” 后的参数必须以关键字方式传输。</span><br><span class="line">def move(direction,</span><br><span class="line">         *,</span><br><span class="line">         mode=&#x27;slither&#x27;,</span><br><span class="line">         turbo=False,</span><br><span class="line">         extra_sinuous=False,</span><br><span class="line">         hail_lyft=False):</span><br><span class="line">    # ...</span><br><span class="line"></span><br><span class="line"># 用户代码，简写</span><br><span class="line"># 错误！不能使用位置参数，关键字参数是必须的</span><br><span class="line">move(&#x27;north&#x27;, &#x27;slither&#x27;, False, True)</span><br></pre></td></tr></table></figure><p>有了这个星，以下是唯一允许的语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 用户代码</span><br><span class="line">move(&#x27;north&#x27;, extra_sinuous=True)</span><br></pre></td></tr></table></figure><p>现在，当你删除 <code>turbo</code> 时，你可以确定任何依赖于它的用户代码都会明显地提示失败。如果你的库也支持 Python2，这没有什么大不了。你可以模拟星型语法（<a target="_blank" rel="noopener" href="http://www.informit.com/articles/article.aspx?p=2314818">归功于 Brett Slatkin</a>）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 你的库代码，兼容 Python 2</span><br><span class="line">def move(direction, **kwargs):</span><br><span class="line">    mode = kwargs.pop(&#x27;mode&#x27;, &#x27;slither&#x27;)</span><br><span class="line">    turbo = kwargs.pop(&#x27;turbo&#x27;, False)</span><br><span class="line">    sinuous = kwargs.pop(&#x27;extra_sinuous&#x27;, False)</span><br><span class="line">    lyft = kwargs.pop(&#x27;hail_lyft&#x27;, False)</span><br><span class="line"></span><br><span class="line">    if kwargs:</span><br><span class="line">        raise TypeError(&#x27;Unexpected kwargs: %r&#x27; </span><br><span class="line">                        % kwargs)</span><br><span class="line"></span><br><span class="line"># ...</span><br></pre></td></tr></table></figure><p>要求关键字参数是一个明智的选择，但它需要远见。如果允许按位置传递参数，则不能仅在以后的版本中将其转换为仅关键字。所以，现在加上星号。你可以在 asyncio API 中观察到，它在构造函数、方法和函数中普遍使用星号。尽管到目前为止，<code>Lock</code> 只接受一个可选参数，但 asyncio 开发人员立即添加了星号。这是幸运的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># In asyncio.</span><br><span class="line">class Lock:</span><br><span class="line">    def __init__(self, *, loop=None):</span><br><span class="line">        # ...</span><br></pre></td></tr></table></figure><p>现在，我们已经获得了改变方法和参数的智慧，同时保持与用户的约定。现在是时候尝试最具挑战性的进化了：在不改变方法或参数的情况下改变行为。</p><h3 id="改变行为"><a href="#改变行为" class="headerlink" title="改变行为"></a>改变行为</h3><p>假设你创造的生物是一条响尾蛇，你想教它一种新行为。</p><p><img src="https://linuxcn.img.undefined.today/data/attachment/album/201905/26/134255yhc6lxmz6m6jjkkz.jpg" alt="Rattlesnake" title="Rattlesnake"></p><p>横向移动！这个生物的身体看起来是一样的，但它的行为会发生变化。我们如何为这一进化步骤做好准备？</p><p><img src="https://linuxcn.img.undefined.today/data/attachment/album/201905/26/134313i7wd5lln5rdlciji.png"></p><p><em>Image by HCA [<a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-sa/4.0">CC BY-SA 4.0</a>], <a target="_blank" rel="noopener" href="https://commons.wikimedia.org/wiki/File:Neonate_sidewinder_sidewinding_with_tracks_unlabeled.jpg">via Wikimedia Commons</a>, 由 Opensource.com 修改</em></p><p>当行为在没有新函数或新参数的情况下发生更改时，负责任的创建者可以从 Python 标准库中学习。很久以前，os 模块引入了 <code>stat</code> 函数来获取文件统计信息，比如创建时间。起初，这个时间总是整数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; os.stat(&#x27;file.txt&#x27;).st_ctime</span><br><span class="line">1540817862</span><br></pre></td></tr></table></figure><p>有一天，核心开发人员决定在 <code>os.stat</code> 中使用浮点数来提供亚秒级精度。但他们担心现有的用户代码还没有做好准备更改。于是他们在 Python 2.3 中创建了一个设置 <code>stat_float_times</code>，默认情况下是 <code>False</code> 。用户可以将其设置为 True 来选择浮点时间戳。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; # Python 2.3.</span><br><span class="line">&gt;&gt;&gt; os.stat_float_times(True)</span><br><span class="line">&gt;&gt;&gt; os.stat(&#x27;file.txt&#x27;).st_ctime</span><br><span class="line">1540817862.598021</span><br></pre></td></tr></table></figure><p>从 Python 2.5 开始，浮点时间成为默认值，因此 2.5 及之后版本编写的任何新代码都可以忽略该设置并期望得到浮点数。当然，你可以将其设置为 <code>False</code> 以保持旧行为，或将其设置为 <code>True</code> 以确保所有 Python 版本都得到浮点数，并为删除 <code>stat_float_times</code> 的那一天准备代码。</p><p>多年过去了，在 Python 3.1 中，该设置已被弃用，以便为人们为遥远的未来做好准备，最后，经过数十年的旅程，<a target="_blank" rel="noopener" href="https://bugs.python.org/issue31827">这个设置被删除</a>。浮点时间现在是唯一的选择。这是一个漫长的过程，但负责任的神灵是有耐心的，因为我们知道这个渐进的过程很有可能于意外的行为变化拯救用户。</p><h4 id="第十个约定：逐渐改变行为"><a href="#第十个约定：逐渐改变行为" class="headerlink" title="第十个约定：逐渐改变行为"></a>第十个约定：逐渐改变行为</h4><p>以下是步骤：</p><ul><li>添加一个标志来选择新行为，默认为 <code>False</code>，如果为 <code>False</code> 则发出警告</li><li>将默认值更改为 <code>True</code>，表示完全弃用标记</li><li>删除该标志</li></ul><p>如果你遵循语义版本控制，版本可能如下：</p><table><thead><tr><th>库版本</th><th>库 API</th><th>用户代码</th></tr></thead><tbody><tr><td>1.0</td><td>没有标志</td><td>预期的旧行为</td></tr><tr><td>1.1</td><td>添加标志，默认为 <code>False</code>，如果是 <code>False</code>，则警告</td><td>设置标志为 <code>True</code>，处理新行为</td></tr><tr><td>2.0</td><td>改变默认为 <code>True</code>，完全弃用标志</td><td>处理新行为</td></tr><tr><td>3.0</td><td>移除标志</td><td>处理新行为</td></tr></tbody></table><p>你需要<strong>两</strong>个主要版本来完成该操作。如果你直接从“添加标志，默认为 <code>False</code>，如果是 <code>False</code> 则发出警告”变到“删除标志”，而没有中间版本，那么用户的代码将无法升级。为 1.1 正确编写的用户代码必须能够升级到下一个版本，除了新警告之外，没有任何不良影响，但如果在下一个版本中删除了该标志，那么该代码将崩溃。一个负责任的神明从不违反扭曲的政策：“先行者总是自由的”。</p><h3 id="负责任的创建者"><a href="#负责任的创建者" class="headerlink" title="负责任的创建者"></a>负责任的创建者</h3><p><img src="https://linuxcn.img.undefined.today/data/attachment/album/201905/26/134315sk08fu8tfh7t7007.jpg" alt="Demeter" title="Demeter"></p><p>我们的 10 个约定大致可以分为三类：</p><p><strong>谨慎发展</strong></p><ol><li>避免不良功能</li><li>最小化特性</li><li>保持功能单一</li><li>标记实验特征“临时”</li><li>温柔删除功能</li></ol><p><strong>严格记录历史</strong></p><ol><li>维护更改日志</li><li>选择版本方案</li><li>编写升级指南</li></ol><p><strong>缓慢而明显地改变</strong></p><ol><li>兼容添加参数</li><li>逐渐改变行为</li></ol><p>如果你对你所创造的物种保持这些约定，你将成为一个负责任的造物主。你的生物的身体可以随着时间的推移而进化，一直在改善和适应环境的变化，而不是在生物没有准备好就突然改变。如果你维护一个库，请向用户保留这些承诺，这样你就可以在不破坏依赖该库的代码的情况下对库进行更新。</p><hr><p>这篇文章最初是在 <a target="_blank" rel="noopener" href="https://emptysqua.re/blog/api-evolution-the-right-way/">A. Jesse Jiryu Davis 的博客上’</a>出现的，经允许转载。</p><p>插图参考：</p><ul><li><a target="_blank" rel="noopener" href="https://www.gutenberg.org/files/42224/42224-h/42224-h.htm">《世界进步》, Delphian Society, 1913</a></li><li><a target="_blank" rel="noopener" href="https://publicdomainreview.org/product-att/artist/charles-owen/">《走进蛇的历史》, Charles Owen, 1742</a></li><li><a target="_blank" rel="noopener" href="https://archive.org/details/onbatrachiarepti00cope/page/n3">关于哥斯达黎加的 batrachia 和爬行动物，关于尼加拉瓜和秘鲁的爬行动物和鱼类学的记录, Edward Drinker Cope, 1875</a></li><li><a target="_blank" rel="noopener" href="https://www.flickr.com/photos/internetarchivebookimages/20556001490">《自然史》, Richard Lydekker et. al., 1897</a></li><li><a target="_blank" rel="noopener" href="https://www.oldbookillustrations.com/illustrations/stationery/">Mes Prisons, Silvio Pellico, 1843</a></li><li><a target="_blank" rel="noopener" href="https://www.alamy.com/mediacomp/ImageDetails.aspx?ref=D7Y61W">Tierfotoagentur &#x2F; m.blue-shadow</a></li><li><a target="_blank" rel="noopener" href="https://www.vintag.es/2013/06/riding-alligator-c-1930s.html">洛杉矶公共图书馆, 1930</a></li></ul><hr><p>via: <a target="_blank" rel="noopener" href="https://opensource.com/article/19/5/api-evolution-right-way">https://opensource.com/article/19/5/api-evolution-right-way</a></p><p>作者：<a target="_blank" rel="noopener" href="https://opensource.com/users/emptysquare">A. Jesse</a> 选题：<a target="_blank" rel="noopener" href="https://github.com/lujun9972">lujun9972</a> 译者：<a target="_blank" rel="noopener" href="https://github.com/MjSeven">MjSeven</a> 校对：<a target="_blank" rel="noopener" href="https://github.com/wxy">wxy</a></p><p>本文由 <a target="_blank" rel="noopener" href="https://github.com/LCTT/TranslateProject">LCTT</a> 原创编译，<a target="_blank" rel="noopener" href="https://linux.cn/">Linux中国</a> 荣誉推出</p></div></div></div><div class="footer"><p class="footer-copyright"><span>Powered by <a target="_blank" href="https://hexo.io">Hexo</a></span> <span>Theme <a target="_blank" href="https://github.com/tinkink-co/hexo-theme-terminal">Terminal</a></span><script type="text/javascript" src="https://cdn.staticfile.net/jquery/3.4.1/jquery.min.js"></script><script>getCDNinfo=function(){$.ajax({url:"/cdn-cgi/trace",success:function(a,n){let i="Antananarivo, Madagascar - (TNR);Cape Town, South Africa - (CPT);Casablanca, Morocco - (CMN);Dar Es Salaam, Tanzania - (DAR);Djibouti City, Djibouti - (JIB);Durban, South Africa - (DUR);Johannesburg, South Africa - (JNB);Kigali, Rwanda - (KGL);Lagos, Nigeria - (LOS);Luanda, Angola - (LAD);Maputo, MZ - (MPM);Mombasa, Kenya - (MBA);Port Louis, Mauritius - (MRU);Réunion, France - (RUN);Bangalore, India - (BLR);Bangkok, Thailand - (BKK);Bandar Seri Begawan, Brunei - (BWN);Cebu, Philippines - (CEB);Chengdu, China - (CTU);Chennai, India - (MAA);Chittagong, Bangladesh - (CGP);Chongqing, China - (CKG);Colombo, Sri Lanka - (CMB);Dhaka, Bangladesh - (DAC);Dongguan, China - (SZX);Foshan, China - (FUO);Fuzhou, China - (FOC);Guangzhou, China - (CAN);Hangzhou, China - (HGH);Hanoi, Vietnam - (HAN);Hengyang, China - (HNY);Ho Chi Minh City, Vietnam - (SGN);Hong Kong - (HKG);Hyderabad, India - (HYD);Islamabad, Pakistan - (ISB);Jakarta, Indonesia - (CGK);Jinan, China - (TNA);Karachi, Pakistan - (KHI);Kathmandu, Nepal - (KTM);Kolkata, India - (CCU);Kuala Lumpur, Malaysia - (KUL);Lahore, Pakistan - (LHE);Langfang, China - (NAY);Luoyang, China - (LYA);Macau - (MFM);Malé, Maldives - (MLE);Manila, Philippines - (MNL);Mumbai, India - (BOM);Nagpur, India - (NAG);Nanning, China - (NNG);New Delhi, India - (DEL);Osaka, Japan - (KIX);Phnom Penh, Cambodia - (PNH);Qingdao, China - (TAO);Seoul, South Korea - (ICN);Shanghai, China - (SHA);Shenyang, China - (SHE);Shijiazhuang, China - (SJW);Singapore, Singapore - (SIN);Suzhou, China - (SZV);Taipei - (TPE);Thimphu, Bhutan - (PBH);Tianjin, China - (TSN);Tokyo, Japan - (NRT);Ulaanbaatar, Mongolia - (ULN);Vientiane, Laos - (VTE);Wuhan, China - (WUH);Wuxi, China - (WUX);Xi'an, China - (XIY);Yerevan, Armenia - (EVN);Zhengzhou, China - (CGO);Zuzhou, China - (CSX);Amsterdam, Netherlands - (AMS);Athens, Greece - (ATH);Barcelona, Spain - (BCN);Belgrade, Serbia - (BEG);Berlin, Germany - (TXL);Brussels, Belgium - (BRU);Bucharest, Romania - (OTP);Budapest, Hungary - (BUD);Chișinău, Moldova - (KIV);Copenhagen, Denmark - (CPH);Cork, Ireland -  (ORK);Dublin, Ireland - (DUB);Düsseldorf, Germany - (DUS);Edinburgh, United Kingdom - (EDI);Frankfurt, Germany - (FRA);Geneva, Switzerland - (GVA);Gothenburg, Sweden - (GOT);Hamburg, Germany - (HAM);Helsinki, Finland - (HEL);Istanbul, Turkey - (IST);Kyiv, Ukraine - (KBP);Lisbon, Portugal - (LIS);London, United Kingdom - (LHR);Luxembourg City, Luxembourg - (LUX);Madrid, Spain - (MAD);Manchester, United Kingdom - (MAN);Marseille, France - (MRS);Milan, Italy - (MXP);Moscow, Russia - (DME);Munich, Germany - (MUC);Nicosia, Cyprus - (LCA);Oslo, Norway - (OSL);Paris, France - (CDG);Prague, Czech Republic - (PRG);Reykjavík, Iceland - (KEF);Riga, Latvia - (RIX);Rome, Italy - (FCO);Saint Petersburg, Russia - (LED);Sofia, Bulgaria - (SOF);Stockholm, Sweden - (ARN);Tallinn, Estonia - (TLL);Thessaloniki, Greece - (SKG);Vienna, Austria - (VIE);Vilnius, Lithuania - (VNO);Warsaw, Poland - (WAW);Zagreb, Croatia - (ZAG);Zürich, Switzerland - (ZRH);Arica, Chile - (ARI);Asunción, Paraguay - (ASU);Bogotá, Colombia - (BOG);Buenos Aires, Argentina - (EZE);Curitiba, Brazil - (CWB);Fortaleza, Brazil - (FOR);Guatemala City, Guatemala - (GUA);Lima, Peru - (LIM);Medellín, Colombia - (MDE);Panama City, Panama - (PTY);Porto Alegre, Brazil - (POA);Quito, Ecuador - (UIO);Rio de Janeiro, Brazil - (GIG);São Paulo, Brazil - (GRU);Santiago, Chile - (SCL);Willemstad, Curaçao - (CUR);St. George's, Grenada - (GND);Amman, Jordan - (AMM);Baghdad, Iraq - (BGW);Baku, Azerbaijan - (GYD);Beirut, Lebanon - (BEY);Doha, Qatar - (DOH);Dubai, United Arab Emirates - (DXB);Kuwait City, Kuwait - (KWI);Manama, Bahrain - (BAH);Muscat, Oman - (MCT);Ramallah - (ZDM);Riyadh, Saudi Arabia - (RUH);Tel Aviv, Israel - (TLV);Ashburn, VA, United States - (IAD);Atlanta, GA, United States - (ATL);Boston, MA, United States - (BOS);Buffalo, NY, United States - (BUF);Calgary, AB, Canada - (YYC);Charlotte, NC, United States - (CLT);Chicago, IL, United States - (ORD);Columbus, OH, United States - (CMH);Dallas, TX, United States - (DFW);Denver, CO, United States - (DEN);Detroit, MI, United States - (DTW);Honolulu, HI, United States - (HNL);Houston, TX, United States - (IAH);Indianapolis, IN, United States - (IND);Jacksonville, FL, United States - (JAX);Kansas City, MO, United States - (MCI);Las Vegas, NV, United States - (LAS);Los Angeles, CA, United States - (LAX);McAllen, TX, United States - (MFE);Memphis, TN, United States - (MEM);Mexico City, Mexico - (MEX);Miami, FL, United States - (MIA);Minneapolis, MN, United States - (MSP);Montgomery, AL, United States - (MGM);Montréal, QC, Canada - (YUL);Nashville, TN, United States - (BNA);Newark, NJ, United States - (EWR);Norfolk, VA, United States - (ORF);Omaha, NE, United States - (OMA);Philadelphia, United States - (PHL);Phoenix, AZ, United States - (PHX);Pittsburgh, PA, United States - (PIT);Port-Au-Prince, Haiti - (PAP);Portland, OR, United States - (PDX);Queretaro, MX, Mexico - (QRO);Richmond, Virginia - (RIC);Sacramento, CA, United States - (SMF);Salt Lake City, UT, United States - (SLC);San Diego, CA, United States - (SAN);San Jose, CA, United States - (SJC);Saskatoon, SK, Canada - (YXE);Seattle, WA, United States - (SEA);St. Louis, MO, United States - (STL);Tampa, FL, United States - (TPA);Toronto, ON, Canada - (YYZ);Vancouver, BC, Canada - (YVR);Tallahassee, FL, United States - (TLH);Winnipeg, MB, Canada - (YWG);Adelaide, SA, Australia - (ADL);Auckland, New Zealand - (AKL);Brisbane, QLD, Australia - (BNE);Melbourne, VIC, Australia - (MEL);Noumea, New caledonia - (NOU);Perth, WA, Australia - (PER);Sydney, NSW, Australia - (SYD)".split(";"),e=a.split("colo=")[1].split("\n")[0],t=(a.split("colo=")[1].split("\n")[0],a.split("tls=")[1].split("\n")[0]),o=a.split("http=")[1].split("\n")[0],s=a.split("sni=")[1].split("\n")[0],r=a.split("ip=")[1].split("\n")[0],l=a.split("uag=")[1].split("\n")[0];for(var d=0;d<i.length;d++)if(-1!=i[d].indexOf(e)){document.getElementById("cdn").innerHTML=i[d];break}document.getElementById("tls").innerHTML=t,document.getElementById("http").innerHTML=o,document.getElementById("sni").innerHTML=s,document.getElementById("ip").innerHTML=r,document.getElementById("useragent").innerHTML=l}})},$(document).ready((function(){getCDNinfo()}))</script></p><p style="text-align:center">感谢陪伴与布道，开源之火不灭。​</p><p style="text-align:center"><script>document.write("本次加载耗时: "+(performance.getEntriesByType("navigation").reduce((e,r)=>e+r.responseEnd-r.startTime,0)+performance.getEntriesByType("resource").reduce((e,r)=>e+r.responseEnd-r.startTime,0)).toFixed(0)+"ms")</script></p><p style="text-align:center">当前 SNI 状态： <span id="sni">正在统计！或可能被浏览器防追踪拦截！</span></p><p style="text-align:center">当前 TLS 版本： <span id="tls">正在统计！或可能被浏览器防追踪拦截！</span></p><p style="text-align:center">当前 HTTP 版本： <span id="http">正在统计！或可能被浏览器防追踪拦截！</span></p><p style="text-align:center">当前您的客户端 IP 是： <span id="ip">正在统计！或可能被浏览器防追踪拦截！</span></p><p style="text-align:center">当前分配的 CDN 节点是: <span id="cdn">正在统计！或可能被浏览器防追踪拦截！</span></p><p style="text-align:center">您的 UserAgent 信息是: <span id="useragent">正在统计！或可能被浏览器防追踪拦截！</span></p><p></p><script defer src="https://pv.undefined.today/tracker.min.js" data-website-id="LinuxCNMirror-tracker"></script></div></div></body></html>