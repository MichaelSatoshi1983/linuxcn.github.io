<!doctype html><html lang="en"><head><meta name="description" content="一个LinuxCN的镜像站"><meta name="msvalidate.01" content="D404690CEFCB54C7762AC84935B99171"><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?6618da70c90c8744eead2e9371fb5077";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><script type="text/javascript">!function(t,e,n,c,s,a,r){t[n]=t[n]||function(){(t[n].q=t[n].q||[]).push(arguments)},(a=e.createElement(c)).async=1,a.src="https://www.clarity.ms/tag/s5f3f0tojf",(r=e.getElementsByTagName(c)[0]).parentNode.insertBefore(a,r)}(window,document,"clarity","script")</script><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta http-equiv="X-UA-Compatible" content="ie=edge"><link rel="stylesheet" href="/styles/base.css"><link rel="stylesheet" href="/styles/theme.css"><link rel="shortcut icon" href="/favicon.png"><title>全功能的二进制文件分析工具 Radare2 指南 - 归墟星火集 又一个 LinuxCN 站点</title><meta name="generator" content="Hexo 7.3.0"></head><body><div class="header-title"><span class="header-light"></span> <span class="header-light"></span> <span class="header-light"></span> <span>归墟星火集 又一个 LinuxCN 站点 linuxcn.undefined.today<span></span></span></div><div class="container"><ul class="nav"><li><a href="/">首页</a></li><li><a target="_blank" rel="noopener" href="https://undefined.today/">Blog</a></li></ul><div class="content"><div class="post-container"><div class="post-header"><span class="ui-tips">标题：</span><h1 class="ui-keyword post-title">全功能的二进制文件分析工具 Radare2 指南</h1><span class="post-date">2021-02-01</span></div><div class="post-header"><span class="ui-tips">分类：</span> <a href="/categories/%E6%8A%80%E6%9C%AF/">技术</a></div><div class="post-header"><span class="ui-tips">标签：</span> <a href="/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%88%86%E4%BA%AB/">二进制分享</a></div><div class="post-content"><blockquote><p>Radare2 是一个为二进制分析定制的开源工具。</p></blockquote><p><img src="https://linuxcn.img.undefined.today/data/attachment/album/202102/01/112611baw4gpqlch10ps1c.jpg" title="Binary code on a computer screen"></p><p>在《<a href="/article-12187-1.html">Linux 上分析二进制文件的 10 种方法</a>》中，我解释了如何使用 Linux 上丰富的原生工具集来分析二进制文件。但如果你想进一步探索你的二进制文件，你需要一个为二进制分析定制的工具。如果你是二进制分析的新手，并且大多使用的是脚本语言，这篇文章《<a href="/article-11441-1.html">GNU binutils 里的九种武器</a>》可以帮助你开始学习编译过程和什么是二进制。</p><h3 id="为什么我需要另一个工具？"><a href="#为什么我需要另一个工具？" class="headerlink" title="为什么我需要另一个工具？"></a>为什么我需要另一个工具？</h3><p>如果现有的 Linux 原生工具也能做类似的事情，你自然会问为什么需要另一个工具。嗯，这和你用手机做闹钟、做笔记、做相机、听音乐、上网、偶尔打电话和接电话的原因是一样的。以前，使用单独的设备和工具处理这些功能 —— 比如拍照的实体相机，记笔记的小记事本，起床的床头闹钟等等。对用户来说，有一个设备来做多件（但相关的）事情是<em>方便的</em>。另外，杀手锏就是独立功能之间的<em>互操作性</em>。</p><p>同样，即使许多 Linux 工具都有特定的用途，但在一个工具中捆绑类似（和更好）的功能是非常有用的。这就是为什么我认为 <a target="_blank" rel="noopener" href="https://rada.re/n/">Radare2</a> 应该是你需要处理二进制文件时的首选工具。</p><p>根据其 <a target="_blank" rel="noopener" href="https://github.com/radareorg/radare2">GitHub 简介</a>，Radare2（也称为 r2）是一个“类 Unix 系统上的逆向工程框架和命令行工具集”。它名字中的 “2” 是因为这个版本从头开始重写的，使其更加模块化。</p><h3 id="为什么选择-Radare2？"><a href="#为什么选择-Radare2？" class="headerlink" title="为什么选择 Radare2？"></a>为什么选择 Radare2？</h3><p>有大量（非原生的）Linux 工具可用于二进制分析，为什么要选择 Radare2 呢？我的理由很简单。</p><p>首先，它是一个开源项目，有一个活跃而健康的社区。如果你正在寻找新颖的功能或提供着 bug 修复的工具，这很重要。</p><p>其次，Radare2 可以在命令行上使用，而且它有一个功能丰富的图形用户界面（GUI）环境，叫做 Cutter，适合那些对 GUI 比较熟悉的人。作为一个长期使用 Linux 的用户，我对习惯于在 shell 上输入。虽然熟悉 Radare2 的命令稍微有一点学习曲线，但我会把它比作 <a target="_blank" rel="noopener" href="https://opensource.com/article/19/3/getting-started-vim">学习 Vim</a>。你可以先学习基本的东西，一旦你掌握了它们，你就可以继续学习更高级的东西。很快，它就变成了肌肉记忆。</p><p>第三，Radare2 通过插件可以很好的支持外部工具。例如，最近开源的 <a target="_blank" rel="noopener" href="https://ghidra-sre.org/">Ghidra</a> 二进制分析和<ruby>逆向工具 <rt>reversing tool</rt></ruby>很受欢迎，因为它的反编译器功能是逆向软件的关键要素。你可以直接从 Radare2 控制台安装 Ghidra 反编译器并使用，这很神奇，让你两全其美。</p><h3 id="开始使用-Radare2"><a href="#开始使用-Radare2" class="headerlink" title="开始使用 Radare2"></a>开始使用 Radare2</h3><p>要安装 Radare2，只需克隆其存储库并运行 <code>user.sh</code> 脚本。如果你的系统上还没有一些预备软件包，你可能需要安装它们。一旦安装完成，运行 <code>r2 -v</code> 命令来查看 Radare2 是否被正确安装：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ git clone https://github.com/radareorg/radare2.git</span><br><span class="line">$ cd radare2</span><br><span class="line">$ ./sys/user.sh</span><br><span class="line"></span><br><span class="line"># version</span><br><span class="line"></span><br><span class="line">$ r2 -v</span><br><span class="line">radare2 4.6.0-git 25266 @ linux-x86-64 git.4.4.0-930-g48047b317</span><br><span class="line">commit: 48047b3171e6ed0480a71a04c3693a0650d03543 build: 2020-11-17__09:31:03</span><br><span class="line">$</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="获取二进制测试样本"><a href="#获取二进制测试样本" class="headerlink" title="获取二进制测试样本"></a>获取二进制测试样本</h4><p>现在 <code>r2</code> 已经安装好了，你需要一个样本二进制程序来试用它。你可以使用任何系统二进制文件（<code>ls</code>、<code>bash</code> 等），但为了使本教程的内容简单，请编译以下 C 程序：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cat adder.c</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int adder(int num) &#123;</span><br><span class="line">        return num + 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">        int res, num1 = 100;</span><br><span class="line">        res = adder(num1);</span><br><span class="line">        printf(&quot;Number now is  : %d\n&quot;, res);</span><br><span class="line">        return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ gcc adder.c -o adder</span><br><span class="line">$ file adder</span><br><span class="line">adder: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 3.2.0, BuildID[sha1]=9d4366f7160e1ffb46b14466e8e0d70f10de2240, not stripped</span><br><span class="line">$ ./adder</span><br><span class="line">Number now is  : 101</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="加载二进制文件"><a href="#加载二进制文件" class="headerlink" title="加载二进制文件"></a>加载二进制文件</h4><p>要分析二进制文件，你必须在 Radare2 中加载它。通过提供文件名作为 <code>r2</code> 命令的一个命令行参数来加载它。你会进入一个独立的 Radare2 控制台，这与你的 shell 不同。要退出控制台，你可以输入 <code>Quit</code> 或 <code>Exit</code> 或按 <code>Ctrl+D</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ r2 ./adder</span><br><span class="line"> -- Learn pancake as if you were radare!</span><br><span class="line">[0x004004b0]&gt; quit</span><br><span class="line">$</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="分析二进制"><a href="#分析二进制" class="headerlink" title="分析二进制"></a>分析二进制</h4><p>在你探索二进制之前，你必须让 <code>r2</code> 为你分析它。你可以通过在 <code>r2</code> 控制台中运行 <code>aaa</code> 命令来实现：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ r2 ./adder</span><br><span class="line"> -- Sorry, radare2 has experienced an internal error.</span><br><span class="line">[0x004004b0]&gt;</span><br><span class="line">[0x004004b0]&gt;</span><br><span class="line">[0x004004b0]&gt; aaa</span><br><span class="line">[x] Analyze all flags starting with sym. and entry0 (aa)</span><br><span class="line">[x] Analyze function calls (aac)</span><br><span class="line">[x] Analyze len bytes of instructions for references (aar)</span><br><span class="line">[x] Check for vtables</span><br><span class="line">[x] Type matching analysis for all functions (aaft)</span><br><span class="line">[x] Propagate noreturn information</span><br><span class="line">[x] Use -AA or aaaa to perform additional experimental analysis.</span><br><span class="line">[0x004004b0]&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这意味着每次你选择一个二进制文件进行分析时，你必须在加载二进制文件后输入一个额外的命令 <code>aaa</code>。你可以绕过这一点，在命令后面跟上 <code>-A</code> 来调用 <code>r2</code>；这将告诉 <code>r2</code> 为你自动分析二进制：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ r2 -A ./adder</span><br><span class="line">[x] Analyze all flags starting with sym. and entry0 (aa)</span><br><span class="line">[x] Analyze function calls (aac)</span><br><span class="line">[x] Analyze len bytes of instructions for references (aar)</span><br><span class="line">[x] Check for vtables</span><br><span class="line">[x] Type matching analysis for all functions (aaft)</span><br><span class="line">[x] Propagate noreturn information</span><br><span class="line">[x] Use -AA or aaaa to perform additional experimental analysis.</span><br><span class="line"> -- Already up-to-date.</span><br><span class="line">[0x004004b0]&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="获取一些关于二进制的基本信息"><a href="#获取一些关于二进制的基本信息" class="headerlink" title="获取一些关于二进制的基本信息"></a>获取一些关于二进制的基本信息</h4><p>在开始分析一个二进制文件之前，你需要一些背景信息。在许多情况下，这可以是二进制文件的格式（ELF、PE 等）、二进制的架构（x86、AMD、ARM 等），以及二进制是 32 位还是 64 位。方便的 <code>r2</code> 的 <code>iI</code> 命令可以提供所需的信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">[0x004004b0]&gt; iI</span><br><span class="line">arch     x86</span><br><span class="line">baddr    0x400000</span><br><span class="line">binsz    14724</span><br><span class="line">bintype  elf</span><br><span class="line">bits     64</span><br><span class="line">canary   false</span><br><span class="line">class    ELF64</span><br><span class="line">compiler GCC: (GNU) 8.3.1 20190507 (Red Hat 8.3.1-4)</span><br><span class="line">crypto   false</span><br><span class="line">endian   little</span><br><span class="line">havecode true</span><br><span class="line">intrp    /lib64/ld-linux-x86-64.so.2</span><br><span class="line">laddr    0x0</span><br><span class="line">lang     c</span><br><span class="line">linenum  true</span><br><span class="line">lsyms    true</span><br><span class="line">machine  AMD x86-64 architecture</span><br><span class="line">maxopsz  16</span><br><span class="line">minopsz  1</span><br><span class="line">nx       true</span><br><span class="line">os       linux</span><br><span class="line">pcalign  0</span><br><span class="line">pic      false</span><br><span class="line">relocs   true</span><br><span class="line">relro    partial</span><br><span class="line">rpath    NONE</span><br><span class="line">sanitiz  false</span><br><span class="line">static   false</span><br><span class="line">stripped false</span><br><span class="line">subsys   linux</span><br><span class="line">va       true</span><br><span class="line"></span><br><span class="line">[0x004004b0]&gt;</span><br><span class="line">[0x004004b0]&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="导入和导出"><a href="#导入和导出" class="headerlink" title="导入和导出"></a>导入和导出</h3><p>通常情况下，当你知道你要处理的是什么样的文件后，你就想知道二进制程序使用了什么样的标准库函数，或者了解程序的潜在功能。在本教程中的示例 C 程序中，唯一的库函数是 <code>printf</code>，用来打印信息。你可以通过运行 <code>ii</code> 命令看到这一点，它显示了该二进制所有导入的库：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[0x004004b0]&gt; ii</span><br><span class="line">[Imports]</span><br><span class="line">nth vaddr      bind   type   lib name</span><br><span class="line">―――――――――――――――――――――――――――――――――――――</span><br><span class="line">1   0x00000000 WEAK   NOTYPE     _ITM_deregisterTMCloneTable</span><br><span class="line">2   0x004004a0 GLOBAL FUNC       printf</span><br><span class="line">3   0x00000000 GLOBAL FUNC       __libc_start_main</span><br><span class="line">4   0x00000000 WEAK   NOTYPE     __gmon_start__</span><br><span class="line">5   0x00000000 WEAK   NOTYPE     _ITM_registerTMCloneTable</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>该二进制也可以有自己的符号、函数或数据。这些函数通常显示在 <code>Exports</code> 下。这个测试的二进制导出了两个函数：<code>main</code> 和 <code>adder</code>。其余的函数是在编译阶段，当二进制文件被构建时添加的。加载器需要这些函数来加载二进制文件（现在不用太关心它们）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">[0x004004b0]&gt;</span><br><span class="line">[0x004004b0]&gt; iE</span><br><span class="line">[Exports]</span><br><span class="line"></span><br><span class="line">nth paddr       vaddr      bind   type   size lib name</span><br><span class="line">――――――――――――――――――――――――――――――――――――――――――――――――――――――</span><br><span class="line">82   0x00000650 0x00400650 GLOBAL FUNC   5        __libc_csu_fini</span><br><span class="line">85   ---------- 0x00601024 GLOBAL NOTYPE 0        _edata</span><br><span class="line">86   0x00000658 0x00400658 GLOBAL FUNC   0        _fini</span><br><span class="line">89   0x00001020 0x00601020 GLOBAL NOTYPE 0        __data_start</span><br><span class="line">90   0x00000596 0x00400596 GLOBAL FUNC   15       adder</span><br><span class="line">92   0x00000670 0x00400670 GLOBAL OBJ    0        __dso_handle</span><br><span class="line">93   0x00000668 0x00400668 GLOBAL OBJ    4        _IO_stdin_used</span><br><span class="line">94   0x000005e0 0x004005e0 GLOBAL FUNC   101      __libc_csu_init</span><br><span class="line">95   ---------- 0x00601028 GLOBAL NOTYPE 0        _end</span><br><span class="line">96   0x000004e0 0x004004e0 GLOBAL FUNC   5        _dl_relocate_static_pie</span><br><span class="line">97   0x000004b0 0x004004b0 GLOBAL FUNC   47       _start</span><br><span class="line">98   ---------- 0x00601024 GLOBAL NOTYPE 0        __bss_start</span><br><span class="line">99   0x000005a5 0x004005a5 GLOBAL FUNC   55       main</span><br><span class="line">100  ---------- 0x00601028 GLOBAL OBJ    0        __TMC_END__</span><br><span class="line">102  0x00000468 0x00400468 GLOBAL FUNC   0        _init</span><br><span class="line"></span><br><span class="line">[0x004004b0]&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="哈希信息"><a href="#哈希信息" class="headerlink" title="哈希信息"></a>哈希信息</h3><p>如何知道两个二进制文件是否相似？你不能只是打开一个二进制文件并查看里面的源代码。在大多数情况下，二进制文件的哈希值（md5sum、sha1、sha256）是用来唯一识别它的。你可以使用 <code>it</code> 命令找到二进制的哈希值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[0x004004b0]&gt; it</span><br><span class="line">md5 7e6732f2b11dec4a0c7612852cede670</span><br><span class="line">sha1 d5fa848c4b53021f6570dd9b18d115595a2290ae</span><br><span class="line">sha256 13dd5a492219dac1443a816ef5f91db8d149e8edbf26f24539c220861769e1c2</span><br><span class="line">[0x004004b0]&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>代码按函数分组；要列出二进制中存在的函数，请运行 <code>afl</code> 命令。下面的列表显示了 <code>main</code> 函数和 <code>adder</code> 函数。通常，以 <code>sym.imp</code> 开头的函数是从标准库（这里是 glibc）中导入的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[0x004004b0]&gt; afl</span><br><span class="line">0x004004b0    1 46           entry0</span><br><span class="line">0x004004f0    4 41   -&gt; 34   sym.deregister_tm_clones</span><br><span class="line">0x00400520    4 57   -&gt; 51   sym.register_tm_clones</span><br><span class="line">0x00400560    3 33   -&gt; 32   sym.__do_global_dtors_aux</span><br><span class="line">0x00400590    1 6            entry.init0</span><br><span class="line">0x00400650    1 5            sym.__libc_csu_fini</span><br><span class="line">0x00400658    1 13           sym._fini</span><br><span class="line">0x00400596    1 15           sym.adder</span><br><span class="line">0x004005e0    4 101          loc..annobin_elf_init.c</span><br><span class="line">0x004004e0    1 5            loc..annobin_static_reloc.c</span><br><span class="line">0x004005a5    1 55           main</span><br><span class="line">0x004004a0    1 6            sym.imp.printf</span><br><span class="line">0x00400468    3 27           sym._init</span><br><span class="line">[0x004004b0]&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="交叉引用"><a href="#交叉引用" class="headerlink" title="交叉引用"></a>交叉引用</h3><p>在 C 语言中，<code>main</code> 函数是一个程序开始执行的地方。理想情况下，其他函数都是从 <code>main</code> 函数调用的，在退出程序时，<code>main</code> 函数会向操作系统返回一个退出状态。这在源代码中是很明显的，然而，二进制程序呢？如何判断 <code>adder</code> 函数的调用位置呢？</p><p>你可以使用 <code>axt</code> 命令，后面加上函数名，看看 <code>adder</code> 函数是在哪里调用的；如下图所示，它是从 <code>main</code> 函数中调用的。这就是所谓的<ruby>交叉引用 <rt>cross-referencing</rt></ruby>。但什么调用 <code>main</code> 函数本身呢？从下面的 <code>axt main</code> 可以看出，它是由 <code>entry0</code> 调用的（关于 <code>entry0</code> 的学习我就不说了，留待读者练习）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[0x004004b0]&gt; axt sym.adder</span><br><span class="line">main 0x4005b9 [CALL] call sym.adder</span><br><span class="line">[0x004004b0]&gt;</span><br><span class="line">[0x004004b0]&gt; axt main</span><br><span class="line">entry0 0x4004d1 [DATA] mov rdi, main</span><br><span class="line">[0x004004b0]&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="寻找定位"><a href="#寻找定位" class="headerlink" title="寻找定位"></a>寻找定位</h3><p>在处理文本文件时，你经常通过引用行号和行或列号在文件内移动；在二进制文件中，你需要使用地址。这些是以 <code>0x</code> 开头的十六进制数字，后面跟着一个地址。要找到你在二进制中的位置，运行 <code>s</code> 命令。要移动到不同的位置，使用 <code>s</code> 命令，后面跟上地址。</p><p>函数名就像标签一样，内部用地址表示。如果函数名在二进制中（未剥离的），可以使用函数名后面的 <code>s</code> 命令跳转到一个特定的函数地址。同样，如果你想跳转到二进制的开始，输入 <code>s 0</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">[0x004004b0]&gt; s</span><br><span class="line">0x4004b0</span><br><span class="line">[0x004004b0]&gt;</span><br><span class="line">[0x004004b0]&gt; s main</span><br><span class="line">[0x004005a5]&gt;</span><br><span class="line">[0x004005a5]&gt; s</span><br><span class="line">0x4005a5</span><br><span class="line">[0x004005a5]&gt;</span><br><span class="line">[0x004005a5]&gt; s sym.adder</span><br><span class="line">[0x00400596]&gt;</span><br><span class="line">[0x00400596]&gt; s</span><br><span class="line">0x400596</span><br><span class="line">[0x00400596]&gt;</span><br><span class="line">[0x00400596]&gt; s 0</span><br><span class="line">[0x00000000]&gt;</span><br><span class="line">[0x00000000]&gt; s</span><br><span class="line">0x0</span><br><span class="line">[0x00000000]&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="十六进制视图"><a href="#十六进制视图" class="headerlink" title="十六进制视图"></a>十六进制视图</h3><p>通常情况下，原始二进制没有意义。在十六进制模式下查看二进制及其等效的 ASCII 表示法会有帮助：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">[0x004004b0]&gt; s main</span><br><span class="line">[0x004005a5]&gt;</span><br><span class="line">[0x004005a5]&gt; px</span><br><span class="line">- offset -   0 1  2 3  4 5  6 7  8 9  A B  C D  E F  0123456789ABCDEF</span><br><span class="line">0x004005a5  5548 89e5 4883 ec10 c745 fc64 0000 008b  UH..H....E.d....</span><br><span class="line">0x004005b5  45fc 89c7 e8d8 ffff ff89 45f8 8b45 f889  E.........E..E..</span><br><span class="line">0x004005c5  c6bf 7806 4000 b800 0000 00e8 cbfe ffff  ..x.@...........</span><br><span class="line">0x004005d5  b800 0000 00c9 c30f 1f40 00f3 0f1e fa41  .........@.....A</span><br><span class="line">0x004005e5  5749 89d7 4156 4989 f641 5541 89fd 4154  WI..AVI..AUA..AT</span><br><span class="line">0x004005f5  4c8d 2504 0820 0055 488d 2d04 0820 0053  L.%.. .UH.-.. .S</span><br><span class="line">0x00400605  4c29 e548 83ec 08e8 57fe ffff 48c1 fd03  L).H....W...H...</span><br><span class="line">0x00400615  741f 31db 0f1f 8000 0000 004c 89fa 4c89  t.1........L..L.</span><br><span class="line">0x00400625  f644 89ef 41ff 14dc 4883 c301 4839 dd75  .D..A...H...H9.u</span><br><span class="line">0x00400635  ea48 83c4 085b 5d41 5c41 5d41 5e41 5fc3  .H...[]A\A]A^A_.</span><br><span class="line">0x00400645  9066 2e0f 1f84 0000 0000 00f3 0f1e fac3  .f..............</span><br><span class="line">0x00400655  0000 00f3 0f1e fa48 83ec 0848 83c4 08c3  .......H...H....</span><br><span class="line">0x00400665  0000 0001 0002 0000 0000 0000 0000 0000  ................</span><br><span class="line">0x00400675  0000 004e 756d 6265 7220 6e6f 7720 6973  ...Number now is</span><br><span class="line">0x00400685  2020 3a20 2564 0a00 0000 0001 1b03 3b44    : %d........;D</span><br><span class="line">0x00400695  0000 0007 0000 0000 feff ff88 0000 0020  ...............</span><br><span class="line">[0x004005a5]&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="反汇编"><a href="#反汇编" class="headerlink" title="反汇编"></a>反汇编</h3><p>如果你使用的是编译后的二进制文件，则无法查看源代码。编译器将源代码转译成 CPU 可以理解和执行的机器语言指令；其结果就是二进制或可执行文件。然而，你可以查看汇编指令（的助记词）来理解程序正在做什么。例如，如果你想查看 <code>main</code> 函数在做什么，你可以使用 <code>s main</code> 寻找 <code>main</code> 函数的地址，然后运行 <code>pdf</code> 命令来查看反汇编的指令。</p><p>要理解汇编指令，你需要参考体系结构手册（这里是 x86），它的应用二进制接口（ABI，或调用惯例），并对堆栈的工作原理有基本的了解：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">[0x004004b0]&gt; s main</span><br><span class="line">[0x004005a5]&gt;</span><br><span class="line">[0x004005a5]&gt; s</span><br><span class="line">0x4005a5</span><br><span class="line">[0x004005a5]&gt;</span><br><span class="line">[0x004005a5]&gt; pdf</span><br><span class="line">            ; DATA XREF from entry0 @ 0x4004d1</span><br><span class="line">┌ 55: int main (int argc, char **argv, char **envp);</span><br><span class="line">│           ; var int64_t var_8h @ rbp-0x8</span><br><span class="line">│           ; var int64_t var_4h @ rbp-0x4</span><br><span class="line">│           0x004005a5      55             push rbp</span><br><span class="line">│           0x004005a6      4889e5         mov rbp, rsp</span><br><span class="line">│           0x004005a9      4883ec10       sub rsp, 0x10</span><br><span class="line">│           0x004005ad      c745fc640000.  mov dword [var_4h], 0x64    ; &#x27;d&#x27; ; 100</span><br><span class="line">│           0x004005b4      8b45fc         mov eax, dword [var_4h]</span><br><span class="line">│           0x004005b7      89c7           mov edi, eax</span><br><span class="line">│           0x004005b9      e8d8ffffff     call sym.adder</span><br><span class="line">│           0x004005be      8945f8         mov dword [var_8h], eax</span><br><span class="line">│           0x004005c1      8b45f8         mov eax, dword [var_8h]</span><br><span class="line">│           0x004005c4      89c6           mov esi, eax</span><br><span class="line">│           0x004005c6      bf78064000     mov edi, str.Number_now_is__:__d ; 0x400678 ; &quot;Number now is  : %d\n&quot; ; const char *format</span><br><span class="line">│           0x004005cb      b800000000     mov eax, 0</span><br><span class="line">│           0x004005d0      e8cbfeffff     call sym.imp.printf         ; int printf(const char *format)</span><br><span class="line">│           0x004005d5      b800000000     mov eax, 0</span><br><span class="line">│           0x004005da      c9             leave</span><br><span class="line">└           0x004005db      c3             ret</span><br><span class="line">[0x004005a5]&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这是 <code>adder</code> 函数的反汇编结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">[0x004005a5]&gt; s sym.adder</span><br><span class="line">[0x00400596]&gt;</span><br><span class="line">[0x00400596]&gt; s</span><br><span class="line">0x400596</span><br><span class="line">[0x00400596]&gt;</span><br><span class="line">[0x00400596]&gt; pdf</span><br><span class="line">            ; CALL XREF from main @ 0x4005b9</span><br><span class="line">┌ 15: sym.adder (int64_t arg1);</span><br><span class="line">│           ; var int64_t var_4h @ rbp-0x4</span><br><span class="line">│           ; arg int64_t arg1 @ rdi</span><br><span class="line">│           0x00400596      55             push rbp</span><br><span class="line">│           0x00400597      4889e5         mov rbp, rsp</span><br><span class="line">│           0x0040059a      897dfc         mov dword [var_4h], edi     ; arg1</span><br><span class="line">│           0x0040059d      8b45fc         mov eax, dword [var_4h]</span><br><span class="line">│           0x004005a0      83c001         add eax, 1</span><br><span class="line">│           0x004005a3      5d             pop rbp</span><br><span class="line">└           0x004005a4      c3             ret</span><br><span class="line">[0x00400596]&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>查看二进制中存在哪些字符串可以作为二进制分析的起点。字符串是硬编码到二进制中的，通常会提供重要的提示，可以让你将重点转移到分析某些区域。在二进制中运行 <code>iz</code> 命令来列出所有的字符串。这个测试二进制中只有一个硬编码的字符串：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[0x004004b0]&gt; iz</span><br><span class="line">[Strings]</span><br><span class="line">nth paddr      vaddr      len size section type  string</span><br><span class="line">―――――――――――――――――――――――――――――――――――――――――――――――――――――――</span><br><span class="line">0   0x00000678 0x00400678 20  21   .rodata ascii Number now is  : %d\n</span><br><span class="line"></span><br><span class="line">[0x004004b0]&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="交叉引用字符串"><a href="#交叉引用字符串" class="headerlink" title="交叉引用字符串"></a>交叉引用字符串</h3><p>和函数一样，你可以交叉引用字符串，看看它们是从哪里被打印出来的，并理解它们周围的代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[0x004004b0]&gt; ps @ 0x400678</span><br><span class="line">Number now is  : %d</span><br><span class="line"></span><br><span class="line">[0x004004b0]&gt;</span><br><span class="line">[0x004004b0]&gt; axt 0x400678</span><br><span class="line">main 0x4005c6 [DATA] mov edi, str.Number_now_is__:__d</span><br><span class="line">[0x004004b0]&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="可视模式"><a href="#可视模式" class="headerlink" title="可视模式"></a>可视模式</h3><p>当你的代码很复杂，有多个函数被调用时，很容易迷失方向。如果能以图形或可视化的方式查看哪些函数被调用，根据某些条件采取了哪些路径等，会很有帮助。在移动到感兴趣的函数后，可以通过 <code>VV</code> 命令来探索 <code>r2</code> 的可视化模式。例如，对于 <code>adder</code> 函数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[0x004004b0]&gt; s sym.adder</span><br><span class="line">[0x00400596]&gt;</span><br><span class="line">[0x00400596]&gt; VV</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://linuxcn.img.undefined.today/data/attachment/album/202102/01/112635hqi5513d1e5bx8d8.png" alt="Radare2 Visual mode" title="Radare2 Visual mode"></p><p><em>(Gaurav Kamathe, <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-sa/4.0/">CC BY-SA 4.0</a>)</em></p><h3 id="调试器"><a href="#调试器" class="headerlink" title="调试器"></a>调试器</h3><p>到目前为止，你一直在做的是静态分析 —— 你只是在看二进制文件中的东西，而没有运行它，有时你需要执行二进制文件，并在运行时分析内存中的各种信息。<code>r2</code> 的内部调试器允许你运行二进制文件、设置断点、分析变量的值、或者转储寄存器的内容。</p><p>用 <code>-d</code> 标志启动调试器，并在加载二进制时添加 <code>-A</code> 标志进行分析。你可以通过使用 <code>db &lt;function-name&gt;</code> 命令在不同的地方设置断点，比如函数或内存地址。要查看现有的断点，使用 <code>dbi</code> 命令。一旦你放置了断点，使用 <code>dc</code> 命令开始运行二进制文件。你可以使用 <code>dbt</code> 命令查看堆栈，它可以显示函数调用。最后，你可以使用 <code>drr</code> 命令转储寄存器的内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">$ r2 -d -A ./adder</span><br><span class="line">Process with PID 17453 started...</span><br><span class="line">= attach 17453 17453</span><br><span class="line">bin.baddr 0x00400000</span><br><span class="line">Using 0x400000</span><br><span class="line">asm.bits 64</span><br><span class="line">[x] Analyze all flags starting with sym. and entry0 (aa)</span><br><span class="line">[x] Analyze function calls (aac)</span><br><span class="line">[x] Analyze len bytes of instructions for references (aar)</span><br><span class="line">[x] Check for vtables</span><br><span class="line">[x] Type matching analysis for all functions (aaft)</span><br><span class="line">[x] Propagate noreturn information</span><br><span class="line">[x] Use -AA or aaaa to perform additional experimental analysis.</span><br><span class="line"> -- git checkout hamster</span><br><span class="line">[0x7f77b0a28030]&gt;</span><br><span class="line">[0x7f77b0a28030]&gt; db main</span><br><span class="line">[0x7f77b0a28030]&gt;</span><br><span class="line">[0x7f77b0a28030]&gt; db sym.adder</span><br><span class="line">[0x7f77b0a28030]&gt;</span><br><span class="line">[0x7f77b0a28030]&gt; dbi</span><br><span class="line">0 0x004005a5 E:1 T:0</span><br><span class="line">1 0x00400596 E:1 T:0</span><br><span class="line">[0x7f77b0a28030]&gt;</span><br><span class="line">[0x7f77b0a28030]&gt; afl | grep main</span><br><span class="line">0x004005a5    1 55           main</span><br><span class="line">[0x7f77b0a28030]&gt;</span><br><span class="line">[0x7f77b0a28030]&gt; afl | grep sym.adder</span><br><span class="line">0x00400596    1 15           sym.adder</span><br><span class="line">[0x7f77b0a28030]&gt;</span><br><span class="line">[0x7f77b0a28030]&gt; dc</span><br><span class="line">hit breakpoint at: 0x4005a5</span><br><span class="line">[0x004005a5]&gt;</span><br><span class="line">[0x004005a5]&gt; dbt</span><br><span class="line">0  0x4005a5           sp: 0x0                 0    [main]  main sym.adder+15</span><br><span class="line">1  0x7f77b0687873     sp: 0x7ffe35ff6858      0    [??]  section..gnu.build.attributes-1345820597</span><br><span class="line">2  0x7f77b0a36e0a     sp: 0x7ffe35ff68e8      144  [??]  map.usr_lib64_ld_2.28.so.r_x+65034</span><br><span class="line">[0x004005a5]&gt; dc</span><br><span class="line">hit breakpoint at: 0x400596</span><br><span class="line">[0x00400596]&gt; dbt</span><br><span class="line">0  0x400596           sp: 0x0                 0    [sym.adder]  rip entry.init0+6</span><br><span class="line">1  0x4005be           sp: 0x7ffe35ff6838      0    [main]  main+25</span><br><span class="line">2  0x7f77b0687873     sp: 0x7ffe35ff6858      32   [??]  section..gnu.build.attributes-1345820597</span><br><span class="line">3  0x7f77b0a36e0a     sp: 0x7ffe35ff68e8      144  [??]  map.usr_lib64_ld_2.28.so.r_x+65034</span><br><span class="line">[0x00400596]&gt;</span><br><span class="line">[0x00400596]&gt;</span><br><span class="line">[0x00400596]&gt; dr</span><br><span class="line">rax = 0x00000064</span><br><span class="line">rbx = 0x00000000</span><br><span class="line">rcx = 0x7f77b0a21738</span><br><span class="line">rdx = 0x7ffe35ff6948</span><br><span class="line">r8 = 0x7f77b0a22da0</span><br><span class="line">r9 = 0x7f77b0a22da0</span><br><span class="line">r10 = 0x0000000f</span><br><span class="line">r11 = 0x00000002</span><br><span class="line">r12 = 0x004004b0</span><br><span class="line">r13 = 0x7ffe35ff6930</span><br><span class="line">r14 = 0x00000000</span><br><span class="line">r15 = 0x00000000</span><br><span class="line">rsi = 0x7ffe35ff6938</span><br><span class="line">rdi = 0x00000064</span><br><span class="line">rsp = 0x7ffe35ff6838</span><br><span class="line">rbp = 0x7ffe35ff6850</span><br><span class="line">rip = 0x00400596</span><br><span class="line">rflags = 0x00000202</span><br><span class="line">orax = 0xffffffffffffffff</span><br><span class="line">[0x00400596]&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="反编译器"><a href="#反编译器" class="headerlink" title="反编译器"></a>反编译器</h3><p>能够理解汇编是二进制分析的前提。汇编语言总是与二进制建立和预期运行的架构相关。一行源代码和汇编代码之间从来没有 1:1 的映射。通常，一行 C 源代码会产生多行汇编代码。所以，逐行读取汇编代码并不是最佳的选择。</p><p>这就是反编译器的作用。它们试图根据汇编指令重建可能的源代码。这与用于创建二进制的源代码绝不完全相同，它是基于汇编的源代码的近似表示。另外，要考虑到编译器进行的优化，它会生成不同的汇编代码以加快速度，减小二进制的大小等，会使反编译器的工作更加困难。另外，恶意软件作者经常故意混淆代码，让恶意软件的分析人员望而却步。</p><p>Radare2 通过插件提供反编译器。你可以安装任何 Radare2 支持的反编译器。使用 <code>r2pm -l</code> 命令可以查看当前插件。使用 <code>r2pm install</code> 命令来安装一个示例的反编译器 <code>r2dec</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">$ r2pm  -l</span><br><span class="line">$</span><br><span class="line">$ r2pm install r2dec</span><br><span class="line">Cloning into &#x27;r2dec&#x27;...</span><br><span class="line">remote: Enumerating objects: 100, done.</span><br><span class="line">remote: Counting objects: 100% (100/100), done.</span><br><span class="line">remote: Compressing objects: 100% (97/97), done.</span><br><span class="line">remote: Total 100 (delta 18), reused 27 (delta 1), pack-reused 0</span><br><span class="line">Receiving objects: 100% (100/100), 1.01 MiB | 1.31 MiB/s, done.</span><br><span class="line">Resolving deltas: 100% (18/18), done.</span><br><span class="line">Install Done For r2dec</span><br><span class="line">gmake: Entering directory &#x27;/root/.local/share/radare2/r2pm/git/r2dec/p&#x27;</span><br><span class="line">[CC] duktape/duktape.o</span><br><span class="line">[CC] duktape/duk_console.o</span><br><span class="line">[CC] core_pdd.o</span><br><span class="line">[CC] core_pdd.so</span><br><span class="line">gmake: Leaving directory &#x27;/root/.local/share/radare2/r2pm/git/r2dec/p&#x27;</span><br><span class="line">$</span><br><span class="line">$ r2pm  -l</span><br><span class="line">r2dec</span><br><span class="line">$</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="反编译器视图"><a href="#反编译器视图" class="headerlink" title="反编译器视图"></a>反编译器视图</h3><p>要反编译一个二进制文件，在 <code>r2</code> 中加载二进制文件并自动分析它。在本例中，使用 <code>s sym.adder</code> 命令移动到感兴趣的 <code>adder</code> 函数，然后使用 <code>pdda</code> 命令并排查看汇编和反编译后的源代码。阅读这个反编译后的源代码往往比逐行阅读汇编更容易：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">$ r2 -A ./adder</span><br><span class="line">[x] Analyze all flags starting with sym. and entry0 (aa)</span><br><span class="line">[x] Analyze function calls (aac)</span><br><span class="line">[x] Analyze len bytes of instructions for references (aar)</span><br><span class="line">[x] Check for vtables</span><br><span class="line">[x] Type matching analysis for all functions (aaft)</span><br><span class="line">[x] Propagate noreturn information</span><br><span class="line">[x] Use -AA or aaaa to perform additional experimental analysis.</span><br><span class="line"> -- What do you want to debug today?</span><br><span class="line">[0x004004b0]&gt;</span><br><span class="line">[0x004004b0]&gt; s sym.adder</span><br><span class="line">[0x00400596]&gt;</span><br><span class="line">[0x00400596]&gt; s</span><br><span class="line">0x400596</span><br><span class="line">[0x00400596]&gt;</span><br><span class="line">[0x00400596]&gt; pdda</span><br><span class="line">    ; assembly                               | /* r2dec pseudo code output */</span><br><span class="line">                                             | /* ./adder @ 0x400596 */</span><br><span class="line">                                             | #include &amp;lt;stdint.h&gt;</span><br><span class="line">                                             |  </span><br><span class="line">    ; (fcn) sym.adder ()                     | int32_t adder (int64_t arg1) &#123;</span><br><span class="line">                                             |     int64_t var_4h;</span><br><span class="line">                                             |     rdi = arg1;</span><br><span class="line">    0x00400596 push rbp                      |    </span><br><span class="line">    0x00400597 mov rbp, rsp                  |    </span><br><span class="line">    0x0040059a mov dword [rbp - 4], edi      |     *((rbp - 4)) = edi;</span><br><span class="line">    0x0040059d mov eax, dword [rbp - 4]      |     eax = *((rbp - 4));</span><br><span class="line">    0x004005a0 add eax, 1                    |     eax++;</span><br><span class="line">    0x004005a3 pop rbp                       |    </span><br><span class="line">    0x004005a4 ret                           |     return eax;</span><br><span class="line">                                             | &#125;</span><br><span class="line">[0x00400596]&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="配置设置"><a href="#配置设置" class="headerlink" title="配置设置"></a>配置设置</h3><p>随着你对 Radare2 的使用越来越熟悉，你会想改变它的配置，以适应你的工作方式。你可以使用 <code>e</code> 命令查看 <code>r2</code> 的默认配置。要设置一个特定的配置，在 <code>e</code> 命令后面添加 <code>config = value</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[0x004005a5]&gt; e | wc -l</span><br><span class="line">593</span><br><span class="line">[0x004005a5]&gt; e | grep syntax</span><br><span class="line">asm.syntax = intel</span><br><span class="line">[0x004005a5]&gt;</span><br><span class="line">[0x004005a5]&gt; e asm.syntax = att</span><br><span class="line">[0x004005a5]&gt;</span><br><span class="line">[0x004005a5]&gt; e | grep syntax</span><br><span class="line">asm.syntax = att</span><br><span class="line">[0x004005a5]&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>要使配置更改永久化，请将它们放在 <code>r2</code> 启动时读取的名为 <code>.radare2rc</code> 的启动文件中。这个文件通常在你的主目录下，如果没有，你可以创建一个。一些示例配置选项包括：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ cat ~/.radare2rc</span><br><span class="line">e asm.syntax = att</span><br><span class="line">e scr.utf8 = true</span><br><span class="line">eco solarized</span><br><span class="line">e cmd.stack = true</span><br><span class="line">e stack.size = 256</span><br><span class="line">$</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="探索更多"><a href="#探索更多" class="headerlink" title="探索更多"></a>探索更多</h3><p>你已经看到了足够多的 Radare2 功能，对这个工具有了一定的了解。因为 Radare2 遵循 Unix 哲学，即使你可以从它的主控台做各种事情，它也会在下面使用一套独立的二进制来完成它的任务。</p><p>探索下面列出的独立二进制文件，看看它们是如何工作的。例如，用 <code>iI</code> 命令在控制台看到的二进制信息也可以用 <code>rabin2 &lt;binary&gt;</code> 命令找到：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ cd bin/</span><br><span class="line">$</span><br><span class="line">$ ls</span><br><span class="line">prefix  r2agent    r2pm  rabin2   radiff2  ragg2    rarun2   rasm2</span><br><span class="line">r2      r2-indent  r2r   radare2  rafind2  rahash2  rasign2  rax2</span><br><span class="line">$</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>你觉得 Radare2 怎么样？请在评论中分享你的反馈。</p><hr><p>via: <a target="_blank" rel="noopener" href="https://opensource.com/article/21/1/linux-radare2">https://opensource.com/article/21/1/linux-radare2</a></p><p>作者：<a target="_blank" rel="noopener" href="https://opensource.com/users/gkamathe">Gaurav Kamathe</a> 选题：<a target="_blank" rel="noopener" href="https://github.com/lujun9972">lujun9972</a> 译者：<a target="_blank" rel="noopener" href="https://github.com/wxy">wxy</a> 校对：<a target="_blank" rel="noopener" href="https://github.com/wxy">wxy</a></p><p>本文由 <a target="_blank" rel="noopener" href="https://github.com/LCTT/TranslateProject">LCTT</a> 原创编译，<a target="_blank" rel="noopener" href="https://linux.cn/">Linux中国</a> 荣誉推出</p></div></div></div><div class="footer"><p class="footer-copyright"><span>Powered by <a target="_blank" href="https://hexo.io">Hexo</a></span> <span>Theme <a target="_blank" href="https://github.com/tinkink-co/hexo-theme-terminal">Terminal</a></span><script type="text/javascript" src="https://cdn.staticfile.net/jquery/3.4.1/jquery.min.js"></script><script>getCDNinfo=function(){$.ajax({url:"/cdn-cgi/trace",success:function(a,n){let i="Antananarivo, Madagascar - (TNR);Cape Town, South Africa - (CPT);Casablanca, Morocco - (CMN);Dar Es Salaam, Tanzania - (DAR);Djibouti City, Djibouti - (JIB);Durban, South Africa - (DUR);Johannesburg, South Africa - (JNB);Kigali, Rwanda - (KGL);Lagos, Nigeria - (LOS);Luanda, Angola - (LAD);Maputo, MZ - (MPM);Mombasa, Kenya - (MBA);Port Louis, Mauritius - (MRU);Réunion, France - (RUN);Bangalore, India - (BLR);Bangkok, Thailand - (BKK);Bandar Seri Begawan, Brunei - (BWN);Cebu, Philippines - (CEB);Chengdu, China - (CTU);Chennai, India - (MAA);Chittagong, Bangladesh - (CGP);Chongqing, China - (CKG);Colombo, Sri Lanka - (CMB);Dhaka, Bangladesh - (DAC);Dongguan, China - (SZX);Foshan, China - (FUO);Fuzhou, China - (FOC);Guangzhou, China - (CAN);Hangzhou, China - (HGH);Hanoi, Vietnam - (HAN);Hengyang, China - (HNY);Ho Chi Minh City, Vietnam - (SGN);Hong Kong - (HKG);Hyderabad, India - (HYD);Islamabad, Pakistan - (ISB);Jakarta, Indonesia - (CGK);Jinan, China - (TNA);Karachi, Pakistan - (KHI);Kathmandu, Nepal - (KTM);Kolkata, India - (CCU);Kuala Lumpur, Malaysia - (KUL);Lahore, Pakistan - (LHE);Langfang, China - (NAY);Luoyang, China - (LYA);Macau - (MFM);Malé, Maldives - (MLE);Manila, Philippines - (MNL);Mumbai, India - (BOM);Nagpur, India - (NAG);Nanning, China - (NNG);New Delhi, India - (DEL);Osaka, Japan - (KIX);Phnom Penh, Cambodia - (PNH);Qingdao, China - (TAO);Seoul, South Korea - (ICN);Shanghai, China - (SHA);Shenyang, China - (SHE);Shijiazhuang, China - (SJW);Singapore, Singapore - (SIN);Suzhou, China - (SZV);Taipei - (TPE);Thimphu, Bhutan - (PBH);Tianjin, China - (TSN);Tokyo, Japan - (NRT);Ulaanbaatar, Mongolia - (ULN);Vientiane, Laos - (VTE);Wuhan, China - (WUH);Wuxi, China - (WUX);Xi'an, China - (XIY);Yerevan, Armenia - (EVN);Zhengzhou, China - (CGO);Zuzhou, China - (CSX);Amsterdam, Netherlands - (AMS);Athens, Greece - (ATH);Barcelona, Spain - (BCN);Belgrade, Serbia - (BEG);Berlin, Germany - (TXL);Brussels, Belgium - (BRU);Bucharest, Romania - (OTP);Budapest, Hungary - (BUD);Chișinău, Moldova - (KIV);Copenhagen, Denmark - (CPH);Cork, Ireland -  (ORK);Dublin, Ireland - (DUB);Düsseldorf, Germany - (DUS);Edinburgh, United Kingdom - (EDI);Frankfurt, Germany - (FRA);Geneva, Switzerland - (GVA);Gothenburg, Sweden - (GOT);Hamburg, Germany - (HAM);Helsinki, Finland - (HEL);Istanbul, Turkey - (IST);Kyiv, Ukraine - (KBP);Lisbon, Portugal - (LIS);London, United Kingdom - (LHR);Luxembourg City, Luxembourg - (LUX);Madrid, Spain - (MAD);Manchester, United Kingdom - (MAN);Marseille, France - (MRS);Milan, Italy - (MXP);Moscow, Russia - (DME);Munich, Germany - (MUC);Nicosia, Cyprus - (LCA);Oslo, Norway - (OSL);Paris, France - (CDG);Prague, Czech Republic - (PRG);Reykjavík, Iceland - (KEF);Riga, Latvia - (RIX);Rome, Italy - (FCO);Saint Petersburg, Russia - (LED);Sofia, Bulgaria - (SOF);Stockholm, Sweden - (ARN);Tallinn, Estonia - (TLL);Thessaloniki, Greece - (SKG);Vienna, Austria - (VIE);Vilnius, Lithuania - (VNO);Warsaw, Poland - (WAW);Zagreb, Croatia - (ZAG);Zürich, Switzerland - (ZRH);Arica, Chile - (ARI);Asunción, Paraguay - (ASU);Bogotá, Colombia - (BOG);Buenos Aires, Argentina - (EZE);Curitiba, Brazil - (CWB);Fortaleza, Brazil - (FOR);Guatemala City, Guatemala - (GUA);Lima, Peru - (LIM);Medellín, Colombia - (MDE);Panama City, Panama - (PTY);Porto Alegre, Brazil - (POA);Quito, Ecuador - (UIO);Rio de Janeiro, Brazil - (GIG);São Paulo, Brazil - (GRU);Santiago, Chile - (SCL);Willemstad, Curaçao - (CUR);St. George's, Grenada - (GND);Amman, Jordan - (AMM);Baghdad, Iraq - (BGW);Baku, Azerbaijan - (GYD);Beirut, Lebanon - (BEY);Doha, Qatar - (DOH);Dubai, United Arab Emirates - (DXB);Kuwait City, Kuwait - (KWI);Manama, Bahrain - (BAH);Muscat, Oman - (MCT);Ramallah - (ZDM);Riyadh, Saudi Arabia - (RUH);Tel Aviv, Israel - (TLV);Ashburn, VA, United States - (IAD);Atlanta, GA, United States - (ATL);Boston, MA, United States - (BOS);Buffalo, NY, United States - (BUF);Calgary, AB, Canada - (YYC);Charlotte, NC, United States - (CLT);Chicago, IL, United States - (ORD);Columbus, OH, United States - (CMH);Dallas, TX, United States - (DFW);Denver, CO, United States - (DEN);Detroit, MI, United States - (DTW);Honolulu, HI, United States - (HNL);Houston, TX, United States - (IAH);Indianapolis, IN, United States - (IND);Jacksonville, FL, United States - (JAX);Kansas City, MO, United States - (MCI);Las Vegas, NV, United States - (LAS);Los Angeles, CA, United States - (LAX);McAllen, TX, United States - (MFE);Memphis, TN, United States - (MEM);Mexico City, Mexico - (MEX);Miami, FL, United States - (MIA);Minneapolis, MN, United States - (MSP);Montgomery, AL, United States - (MGM);Montréal, QC, Canada - (YUL);Nashville, TN, United States - (BNA);Newark, NJ, United States - (EWR);Norfolk, VA, United States - (ORF);Omaha, NE, United States - (OMA);Philadelphia, United States - (PHL);Phoenix, AZ, United States - (PHX);Pittsburgh, PA, United States - (PIT);Port-Au-Prince, Haiti - (PAP);Portland, OR, United States - (PDX);Queretaro, MX, Mexico - (QRO);Richmond, Virginia - (RIC);Sacramento, CA, United States - (SMF);Salt Lake City, UT, United States - (SLC);San Diego, CA, United States - (SAN);San Jose, CA, United States - (SJC);Saskatoon, SK, Canada - (YXE);Seattle, WA, United States - (SEA);St. Louis, MO, United States - (STL);Tampa, FL, United States - (TPA);Toronto, ON, Canada - (YYZ);Vancouver, BC, Canada - (YVR);Tallahassee, FL, United States - (TLH);Winnipeg, MB, Canada - (YWG);Adelaide, SA, Australia - (ADL);Auckland, New Zealand - (AKL);Brisbane, QLD, Australia - (BNE);Melbourne, VIC, Australia - (MEL);Noumea, New caledonia - (NOU);Perth, WA, Australia - (PER);Sydney, NSW, Australia - (SYD)".split(";"),e=a.split("colo=")[1].split("\n")[0],t=(a.split("colo=")[1].split("\n")[0],a.split("tls=")[1].split("\n")[0]),o=a.split("http=")[1].split("\n")[0],s=a.split("sni=")[1].split("\n")[0],r=a.split("ip=")[1].split("\n")[0],l=a.split("uag=")[1].split("\n")[0];for(var d=0;d<i.length;d++)if(-1!=i[d].indexOf(e)){document.getElementById("cdn").innerHTML=i[d];break}document.getElementById("tls").innerHTML=t,document.getElementById("http").innerHTML=o,document.getElementById("sni").innerHTML=s,document.getElementById("ip").innerHTML=r,document.getElementById("useragent").innerHTML=l}})},$(document).ready((function(){getCDNinfo()}))</script></p><p style="text-align:center">感谢陪伴与布道，开源之火不灭。​</p><p style="text-align:center"><script>document.write("本次加载耗时: "+(performance.getEntriesByType("navigation").reduce((e,r)=>e+r.responseEnd-r.startTime,0)+performance.getEntriesByType("resource").reduce((e,r)=>e+r.responseEnd-r.startTime,0)).toFixed(0)+"ms")</script></p><p style="text-align:center">当前 SNI 状态： <span id="sni">正在统计！或可能被浏览器防追踪拦截！</span></p><p style="text-align:center">当前 TLS 版本： <span id="tls">正在统计！或可能被浏览器防追踪拦截！</span></p><p style="text-align:center">当前 HTTP 版本： <span id="http">正在统计！或可能被浏览器防追踪拦截！</span></p><p style="text-align:center">当前您的客户端 IP 是： <span id="ip">正在统计！或可能被浏览器防追踪拦截！</span></p><p style="text-align:center">当前分配的 CDN 节点是: <span id="cdn">正在统计！或可能被浏览器防追踪拦截！</span></p><p style="text-align:center">您的 UserAgent 信息是: <span id="useragent">正在统计！或可能被浏览器防追踪拦截！</span></p><p></p><script defer src="https://pv.undefined.today/tracker.min.js" data-website-id="LinuxCNMirror-tracker"></script></div></div></body></html>