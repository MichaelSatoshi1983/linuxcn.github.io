<!doctype html><html lang="en"><head><meta name="msvalidate.01" content="D404690CEFCB54C7762AC84935B99171"><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?6618da70c90c8744eead2e9371fb5077";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><script type="text/javascript">!function(t,e,n,c,s,a,r){t[n]=t[n]||function(){(t[n].q=t[n].q||[]).push(arguments)},(a=e.createElement(c)).async=1,a.src="https://www.clarity.ms/tag/s5f3f0tojf",(r=e.getElementsByTagName(c)[0]).parentNode.insertBefore(a,r)}(window,document,"clarity","script")</script><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta http-equiv="X-UA-Compatible" content="ie=edge"><link rel="stylesheet" href="/styles/base.css"><link rel="stylesheet" href="/styles/theme.css"><link rel="shortcut icon" href="/favicon.png"><title>使用 gosec 检查 Go 代码中的安全问题 - 归墟星火集 又一个 LinuxCN 站点</title><meta name="generator" content="Hexo 7.3.0"></head><body><div class="header-title"><span class="header-light"></span> <span class="header-light"></span> <span class="header-light"></span> <span>归墟星火集 又一个 LinuxCN 站点 linuxcn.undefined.today<span></span></span></div><div class="container"><ul class="nav"><li><a href="/">首页</a></li><li><a target="_blank" rel="noopener" href="https://undefined.today/">Blog</a></li></ul><div class="content"><div class="post-container"><div class="post-header"><span class="ui-tips">标题：</span><h1 class="ui-keyword post-title">使用 gosec 检查 Go 代码中的安全问题</h1><span class="post-date">2020-10-04</span></div><div class="post-header"><span class="ui-tips">分类：</span> <a href="/categories/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/">软件开发</a></div><div class="post-header"><span class="ui-tips">标签：</span> <a href="/tags/%E5%AE%89%E5%85%A8/">安全</a> <a href="/tags/Golang/">Golang</a></div><div class="post-content"><blockquote><p>来学习下 Go 语言的安全检查工具 gosec。</p></blockquote><p><img src="https://linuxcn.img.undefined.today/data/attachment/album/202010/04/125129bh4qxxsyqpvqjtx4.jpg"></p><p><a target="_blank" rel="noopener" href="https://golang.org/">Go 语言</a>写的代码越来越常见，尤其是在容器、Kubernetes 或云生态相关的开发中。Docker 是最早采用 Golang 的项目之一，随后是 Kubernetes，之后大量的新项目在众多编程语言中选择了 Go。</p><p>像其他语言一样，Go 也有它的长处和短处（如安全缺陷）。这些缺陷可能会因为语言本身的缺陷加上程序员编码不当而产生，例如，C 代码中的内存安全问题。</p><p>无论它们出现的原因是什么，安全问题都应该在开发过程的早期修复，以免在封装好的软件中出现。幸运的是，静态分析工具可以帮你以更可重复的方式处理这些问题。静态分析工具通过解析用某种编程语言写的代码来找到问题。</p><p>这类工具中很多被称为 linter。传统意义上，linter 更注重的是检查代码中编码问题、bug、代码风格之类的问题，它们可能不会发现代码中的安全问题。例如，<a target="_blank" rel="noopener" href="https://www.synopsys.com/software-integrity/security-testing/static-analysis-sast.html">Coverity</a> 是一个很流行的工具，它可以帮助寻找 C&#x2F;C++ 代码中的问题。然而，也有一些工具专门用来检查源码中的安全问题。例如，<a target="_blank" rel="noopener" href="https://pypi.org/project/bandit/">Bandit</a> 可以检查 Python 代码中的安全缺陷。而 <a target="_blank" rel="noopener" href="https://github.com/securego/gosec">gosec</a> 则用来搜寻 Go 源码中的安全缺陷。<code>gosec</code> 通过扫描 Go 的 AST（<ruby>抽象语法树 <rt>abstract syntax tree</rt></ruby>）来检查源码中的安全问题。</p><h3 id="开始使用-gosec"><a href="#开始使用-gosec" class="headerlink" title="开始使用 gosec"></a>开始使用 gosec</h3><p>在开始学习和使用 <code>gosec</code> 之前，你需要准备一个 Go 语言写的项目。有这么多开源软件，我相信这不是问题。你可以在 GitHub 的 <a target="_blank" rel="noopener" href="https://github.com/trending/go">热门 Golang 仓库</a>中找一个。</p><p>本文中，我随机选了 <a target="_blank" rel="noopener" href="https://github.com/docker/docker-ce">Docker CE</a> 项目，但你可以选择任意的 Go 项目。</p><h4 id="安装-Go-和-gosec"><a href="#安装-Go-和-gosec" class="headerlink" title="安装 Go 和 gosec"></a>安装 Go 和 gosec</h4><p>如果你还没安装 Go，你可以先从仓库中拉取下来。如果你用的是 Fedora 或其他基于 RPM 的 Linux 发行版本：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ dnf install golang.x86_64</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如果你用的是其他操作系统，请参照 <a target="_blank" rel="noopener" href="https://golang.org/doc/install">Golang 安装</a>页面。</p><p>使用 <code>version</code> 参数来验证 Go 是否安装成功：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ go version</span><br><span class="line">go version go1.14.6 linux/amd64</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>运行 <code>go get</code> 命令就可以轻松地安装 <code>gosec</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ go get github.com/securego/gosec/cmd/gosec</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上面这行命令会从 GitHub 下载 <code>gosec</code> 的源码，编译并安装到指定位置。在仓库的 <code>README</code> 中你还可以看到<a target="_blank" rel="noopener" href="https://github.com/securego/gosec#install">安装该工具的其他方法</a>。</p><p><code>gosec</code> 的源码会被下载到 <code>$GOPATH</code> 的位置，编译出的二进制文件会被安装到你系统上设置的 <code>bin</code> 目录下。你可以运行下面的命令来查看 <code>$GOPATH</code> 和 <code>$GOBIN</code> 目录：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ go env | grep GOBIN</span><br><span class="line">GOBIN=&quot;/root/go/gobin&quot;</span><br><span class="line">$ go env | grep GOPATH</span><br><span class="line">GOPATH=&quot;/root/go&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如果 <code>go get</code> 命令执行成功，那么 <code>gosec</code> 二进制应该就可以使用了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ ls -l ~/go/bin/</span><br><span class="line">total 9260</span><br><span class="line">-rwxr-xr-x. 1 root root 9482175 Aug 20 04:17 gosec</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>你可以把 <code>$GOPATH</code> 下的 <code>bin</code> 目录添加到 <code>$PATH</code> 中。这样你就可以像使用系统上的其他命令一样来使用 <code>gosec</code> 命令行工具（CLI）了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ which gosec</span><br><span class="line">/root/go/bin/gosec</span><br><span class="line">$</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>使用 <code>gosec</code> 命令行工具的 <code>-help</code> 选项来看看运行是否符合预期：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ gosec -help</span><br><span class="line"></span><br><span class="line">gosec - Golang security checker</span><br><span class="line"></span><br><span class="line">gosec analyzes Go source code to look for common programming mistakes that</span><br><span class="line">can lead to security problems.</span><br><span class="line"></span><br><span class="line">VERSION: dev</span><br><span class="line">GIT TAG:</span><br><span class="line">BUILD DATE:</span><br><span class="line"></span><br><span class="line">USAGE:</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>之后，创建一个目录，把源码下载到这个目录作为实例项目（本例中，我用的是 Docker CE）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir gosec-demo</span><br><span class="line">$ cd gosec-demo/</span><br><span class="line">$ pwd</span><br><span class="line">/root/gosec-demo</span><br><span class="line">$ git clone https://github.com/docker/docker-ce.git</span><br><span class="line">Cloning into &#x27;docker-ce&#x27;...</span><br><span class="line">remote: Enumerating objects: 1271, done.</span><br><span class="line">remote: Counting objects: 100% (1271/1271), done.</span><br><span class="line">remote: Compressing objects: 100% (722/722), done.</span><br><span class="line">remote: Total 431003 (delta 384), reused 981 (delta 318), pack-reused 429732</span><br><span class="line">Receiving objects: 100% (431003/431003), 166.84 MiB | 28.94 MiB/s, done.</span><br><span class="line">Resolving deltas: 100% (221338/221338), done.</span><br><span class="line">Updating files: 100% (10861/10861), done.</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>代码统计工具（本例中用的是 <code>cloc</code>）显示这个项目大部分是用 Go 写的，恰好迎合了 <code>gosec</code> 的功能。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ ./cloc /root/gosec-demo/docker-ce/</span><br><span class="line">   10771 text files.</span><br><span class="line">    8724 unique files.                                          </span><br><span class="line">    2560 files ignored.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-----------------------------------------------------------------------------------</span><br><span class="line">Language                         files          blank        comment           code</span><br><span class="line">-----------------------------------------------------------------------------------</span><br><span class="line">Go                                7222         190785         230478        1574580</span><br><span class="line">YAML                                37           4831            817         156762</span><br><span class="line">Markdown                           529          21422              0          67893</span><br><span class="line">Protocol Buffers                   149           5014          16562          10071</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="使用默认选项运行-gosec"><a href="#使用默认选项运行-gosec" class="headerlink" title="使用默认选项运行 gosec"></a>使用默认选项运行 gosec</h3><p>在 Docker CE 项目中使用默认选项运行 <code>gosec</code>，执行 <code>gosec ./...</code> 命令。屏幕上会有很多输出内容。在末尾你会看到一个简短的 “Summary”，列出了浏览的文件数、所有文件的总行数，以及源码中发现的问题数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">$ pwd</span><br><span class="line">/root/gosec-demo/docker-ce</span><br><span class="line">$ time gosec ./...</span><br><span class="line">[gosec] 2020/08/20 04:44:15 Including rules: default</span><br><span class="line">[gosec] 2020/08/20 04:44:15 Excluding rules: default</span><br><span class="line">[gosec] 2020/08/20 04:44:15 Import directory: /root/gosec-demo/docker-ce/components/engine/opts</span><br><span class="line">[gosec] 2020/08/20 04:44:17 Checking package: opts</span><br><span class="line">[gosec] 2020/08/20 04:44:17 Checking file: /root/gosec-demo/docker-ce/components/engine/opts/address_pools.go</span><br><span class="line">[gosec] 2020/08/20 04:44:17 Checking file: /root/gosec-demo/docker-ce/components/engine/opts/env.go</span><br><span class="line">[gosec] 2020/08/20 04:44:17 Checking file: /root/gosec-demo/docker-ce/components/engine/opts/hosts.go</span><br><span class="line"></span><br><span class="line"># End of gosec run</span><br><span class="line"></span><br><span class="line">Summary:</span><br><span class="line">   Files: 1278</span><br><span class="line">   Lines: 173979</span><br><span class="line">   Nosec: 4</span><br><span class="line">  Issues: 644</span><br><span class="line"></span><br><span class="line">real    0m52.019s</span><br><span class="line">user    0m37.284s</span><br><span class="line">sys     0m12.734s</span><br><span class="line">$</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>滚动屏幕你会看到不同颜色高亮的行：红色表示需要尽快查看的高优先级问题，黄色表示中优先级的问题。</p><h4 id="关于误判"><a href="#关于误判" class="headerlink" title="关于误判"></a>关于误判</h4><p>在开始检查代码之前，我想先分享几条基本原则。默认情况下，静态检查工具会基于一系列的规则对测试代码进行分析，并报告出它们发现的<em>所有</em>问题。这是否意味着工具报出来的每一个问题都需要修复？非也。这个问题最好的解答者是设计和开发这个软件的人。他们最熟悉代码，更重要的是，他们了解软件会在什么环境下部署以及会被怎样使用。</p><p>这个知识点对于判定工具标记出来的某段代码到底是不是安全缺陷至关重要。随着工作时间和经验的积累，你会慢慢学会怎样让静态分析工具忽略非安全缺陷，使报告内容的可执行性更高。因此，要判定 <code>gosec</code> 报出来的某个问题是否需要修复，让一名有经验的开发者对源码做人工审计会是比较好的办法。</p><h4 id="高优先级问题"><a href="#高优先级问题" class="headerlink" title="高优先级问题"></a>高优先级问题</h4><p>从输出内容看，<code>gosec</code> 发现了 Docker CE 的一个高优先级问题，它使用的是低版本的 TLS（<ruby>传输层安全 <rt>Transport Layer Security</rt> <rt></rt></ruby>）。无论什么时候，使用软件和库的最新版本都是确保它更新及时、没有安全问题的最好的方法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[/root/gosec-demo/docker-ce/components/engine/daemon/logger/splunk/splunk.go:173] - G402 (CWE-295): TLS MinVersion too low. (Confidence: HIGH, Severity: HIGH)</span><br><span class="line">    172:</span><br><span class="line">  &gt; 173:        tlsConfig := &amp;tls.Config&#123;&#125;</span><br><span class="line">    174:</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>它还发现了一个弱随机数生成器。它是不是一个安全缺陷，取决于生成的随机数的使用方式。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[/root/gosec-demo/docker-ce/components/engine/pkg/namesgenerator/names-generator.go:843] - G404 (CWE-338): Use of weak random number generator (math/rand instead of crypto/rand) (Confidence: MEDIUM, Severity: HIGH)</span><br><span class="line">    842: begin:</span><br><span class="line">  &gt; 843:        name := fmt.Sprintf(&quot;%s_%s&quot;, left[rand.Intn(len(left))], right[rand.Intn(len(right))])</span><br><span class="line">    844:        if name == &quot;boring_wozniak&quot; /* Steve Wozniak is not boring */ &#123;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="中优先级问题"><a href="#中优先级问题" class="headerlink" title="中优先级问题"></a>中优先级问题</h4><p>这个工具还发现了一些中优先级问题。它标记了一个通过与 <code>tar</code> 相关的解压炸弹这种方式实现的潜在的 DoS 威胁，这种方式可能会被恶意的攻击者利用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[/root/gosec-demo/docker-ce/components/engine/pkg/archive/copy.go:357] - G110 (CWE-409): Potential DoS vulnerability via decompression bomb (Confidence: MEDIUM, Severity: MEDIUM)</span><br><span class="line">    356:</span><br><span class="line">  &gt; 357:                        if _, err = io.Copy(rebasedTar, srcTar); err != nil &#123;</span><br><span class="line">    358:                                w.CloseWithError(err)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>它还发现了一个通过变量访问文件的问题。如果恶意使用者能访问这个变量，那么他们就可以改变变量的值去读其他文件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[/root/gosec-demo/docker-ce/components/cli/cli/context/tlsdata.go:80] - G304 (CWE-22): Potential file inclusion via variable (Confidence: HIGH, Severity: MEDIUM)</span><br><span class="line">    79:         if caPath != &quot;&quot; &#123;</span><br><span class="line">  &gt; 80:                 if ca, err = ioutil.ReadFile(caPath); err != nil &#123;</span><br><span class="line">    81:                         return nil, err</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>文件和目录通常是操作系统安全的最基础的元素。这里，<code>gosec</code> 报出了一个可能需要你检查目录的权限是否安全的问题。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[/root/gosec-demo/docker-ce/components/engine/contrib/apparmor/main.go:41] - G301 (CWE-276): Expect directory permissions to be 0750 or less (Confidence: HIGH, Severity: MEDIUM)</span><br><span class="line">    40:         // make sure /etc/apparmor.d exists</span><br><span class="line">  &gt; 41:         if err := os.MkdirAll(path.Dir(apparmorProfilePath), 0755); err != nil &#123;</span><br><span class="line">    42:                 log.Fatal(err)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>你经常需要在源码中启动命令行工具。Go 使用内建的 exec 库来实现。仔细地分析用来调用这些工具的变量，就能发现安全缺陷。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[/root/gosec-demo/docker-ce/components/engine/testutil/fakestorage/fixtures.go:59] - G204 (CWE-78): Subprocess launched with variable (Confidence: HIGH, Severity: MEDIUM)</span><br><span class="line">    58:</span><br><span class="line">  &gt; 59:              cmd := exec.Command(goCmd, &quot;build&quot;, &quot;-o&quot;, filepath.Join(tmp, &quot;httpserver&quot;), &quot;github.com/docker/docker/contrib/httpserver&quot;)</span><br><span class="line">    60:                 cmd.Env = append(os.Environ(), []string&#123;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="低优先级问题"><a href="#低优先级问题" class="headerlink" title="低优先级问题"></a>低优先级问题</h4><p>在这个输出中，gosec 报出了一个 <code>unsafe</code> 调用相关的低优先级问题，这个调用会绕开 Go 提供的内存保护。再仔细分析下你调用 <code>unsafe</code> 的方式，看看是否有被别人利用的可能性。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[/root/gosec-demo/docker-ce/components/engine/pkg/archive/changes_linux.go:264] - G103 (CWE-242): Use of unsafe calls should be audited (Confidence: HIGH, Severity: LOW)</span><br><span class="line">    263:        for len(buf) &gt; 0 &#123;</span><br><span class="line">  &gt; 264:                dirent := (*unix.Dirent)(unsafe.Pointer(&amp;buf[0]))</span><br><span class="line">    265:                buf = buf[dirent.Reclen:]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[/root/gosec-demo/docker-ce/components/engine/pkg/devicemapper/devmapper_wrapper.go:88] - G103 (CWE-242): Use of unsafe calls should be audited (Confidence: HIGH, Severity: LOW)</span><br><span class="line">    87: func free(p *C.char) &#123;</span><br><span class="line">  &gt; 88:         C.free(unsafe.Pointer(p))</span><br><span class="line">    89: &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>它还标记了源码中未处理的错误。源码中出现的错误你都应该处理。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[/root/gosec-demo/docker-ce/components/cli/cli/command/image/build/context.go:172] - G104 (CWE-703): Errors unhandled. (Confidence: HIGH, Severity: LOW)</span><br><span class="line">    171:                err := tar.Close()</span><br><span class="line">  &gt; 172:                os.RemoveAll(dockerfileDir)</span><br><span class="line">    173:                return err</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="自定义-gosec-扫描"><a href="#自定义-gosec-扫描" class="headerlink" title="自定义 gosec 扫描"></a>自定义 gosec 扫描</h3><p>使用 <code>gosec</code> 的默认选项会带来很多的问题。然而，经过人工审计，随着时间推移你会掌握哪些问题是不需要标记的。你可以自己指定排除和包含哪些测试。</p><p>我上面提到过，<code>gosec</code> 是基于一系列的规则从 Go 源码中查找问题的。下面是它使用的完整的<a target="_blank" rel="noopener" href="https://github.com/securego/gosec#available-rules">规则</a>列表：</p><ul><li>G101：查找硬编码凭证</li><li>G102：绑定到所有接口</li><li>G103：审计 <code>unsafe</code> 块的使用</li><li>G104：审计未检查的错误</li><li>G106：审计 <code>ssh.InsecureIgnoreHostKey</code> 的使用</li><li>G107: 提供给 HTTP 请求的 url 作为污点输入</li><li>G108: <code>/debug/pprof</code> 上自动暴露的剖析端点</li><li>G109: <code>strconv.Atoi</code> 转换到 int16 或 int32 时潜在的整数溢出</li><li>G110: 潜在的通过解压炸弹实现的 DoS</li><li>G201：SQL 查询构造使用格式字符串</li><li>G202：SQL 查询构造使用字符串连接</li><li>G203：在 HTML 模板中使用未转义的数据</li><li>G204：审计命令执行情况</li><li>G301：创建目录时文件权限分配不合理</li><li>G302：使用 <code>chmod</code> 时文件权限分配不合理</li><li>G303：使用可预测的路径创建临时文件</li><li>G304：通过污点输入提供的文件路径</li><li>G305：提取 zip&#x2F;tar 文档时遍历文件</li><li>G306: 写到新文件时文件权限分配不合理</li><li>G307: 把返回错误的函数放到 <code>defer</code> 内</li><li>G401：检测 DES、RC4、MD5 或 SHA1 的使用</li><li>G402：查找错误的 TLS 连接设置</li><li>G403：确保最小 RSA 密钥长度为 2048 位</li><li>G404：不安全的随机数源（<code>rand</code>）</li><li>G501：导入黑名单列表：crypto&#x2F;md5</li><li>G502：导入黑名单列表：crypto&#x2F;des</li><li>G503：导入黑名单列表：crypto&#x2F;rc4</li><li>G504：导入黑名单列表：net&#x2F;http&#x2F;cgi</li><li>G505：导入黑名单列表：crypto&#x2F;sha1</li><li>G601: 在 <code>range</code> 语句中使用隐式的元素别名</li></ul><h4 id="排除指定的测试"><a href="#排除指定的测试" class="headerlink" title="排除指定的测试"></a>排除指定的测试</h4><p>你可以自定义 <code>gosec</code> 来避免对已知为安全的问题进行扫描和报告。你可以使用 <code>-exclude</code> 选项和上面的规则编号来忽略指定的问题。</p><p>例如，如果你不想让 <code>gosec</code> 检查源码中硬编码凭证相关的未处理的错误，那么你可以运行下面的命令来忽略这些错误：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ gosec -exclude=G104 ./...</span><br><span class="line">$ gosec -exclude=G104,G101 ./...</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>有时候你知道某段代码是安全的，但是 <code>gosec</code> 还是会报出问题。然而，你又不想完全排除掉整个检查，因为你想让 <code>gosec</code> 检查新增的代码。通过在你已知为安全的代码块添加 <code>#nosec</code> 标记可以避免 <code>gosec</code> 扫描。这样 <code>gosec</code> 会继续扫描新增代码，而忽略掉 <code>#nosec</code> 标记的代码块。</p><h4 id="运行指定的检查"><a href="#运行指定的检查" class="headerlink" title="运行指定的检查"></a>运行指定的检查</h4><p>另一方面，如果你只想检查指定的问题，你可以通过 <code>-include</code> 选项和规则编号来告诉 <code>gosec</code> 运行哪些检查：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ gosec -include=G201,G202 ./...</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="扫描测试文件"><a href="#扫描测试文件" class="headerlink" title="扫描测试文件"></a>扫描测试文件</h4><p>Go 语言自带对测试的支持，通过单元测试来检验一个元素是否符合预期。在默认模式下，<code>gosec</code> 会忽略测试文件，你可以使用 <code>-tests</code> 选项把它们包含进来：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gosec -tests ./...</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="修改输出的格式"><a href="#修改输出的格式" class="headerlink" title="修改输出的格式"></a>修改输出的格式</h4><p>找出问题只是它的一半功能；另一半功能是把它检查到的问题以用户友好同时又方便工具处理的方式报告出来。幸运的是，<code>gosec</code> 可以用不同的方式输出。例如，如果你想看 JSON 格式的报告，那么就使用 <code>-fmt</code> 选项指定 JSON 格式并把结果保存到 <code>results.json</code> 文件中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">$ gosec -fmt=json -out=results.json ./...</span><br><span class="line"></span><br><span class="line">$ ls -l results.json</span><br><span class="line">-rw-r--r--. 1 root root 748098 Aug 20 05:06 results.json</span><br><span class="line">$</span><br><span class="line"></span><br><span class="line">         &#123;</span><br><span class="line">             &quot;severity&quot;: &quot;LOW&quot;,</span><br><span class="line">             &quot;confidence&quot;: &quot;HIGH&quot;,</span><br><span class="line">             &quot;cwe&quot;: &#123;</span><br><span class="line">                 &quot;ID&quot;: &quot;242&quot;,</span><br><span class="line">                 &quot;URL&quot;: &quot;https://cwe.mitre.org/data/definitions/242.html&quot;</span><br><span class="line">             &#125;,</span><br><span class="line">             &quot;rule_id&quot;: &quot;G103&quot;,</span><br><span class="line">             &quot;details&quot;: &quot;Use of unsafe calls should be audited&quot;,</span><br><span class="line">             &quot;file&quot;: &quot;/root/gosec-demo/docker-ce/components/engine/daemon/graphdriver/graphtest/graphtest_unix.go&quot;,</span><br><span class="line">             &quot;code&quot;: &quot;304: \t// Cast to []byte\n305: \theader := *(*reflect.SliceHeader)(unsafe.Pointer(\u0026buf))\n306: \theader.      Len *= 8\n&quot;,</span><br><span class="line">             &quot;line&quot;: &quot;305&quot;,</span><br><span class="line">             &quot;column&quot;: &quot;36&quot;</span><br><span class="line">         &#125;,</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="用-gosec-检查容易被发现的问题"><a href="#用-gosec-检查容易被发现的问题" class="headerlink" title="用 gosec 检查容易被发现的问题"></a>用 gosec 检查容易被发现的问题</h3><p>静态检查工具不能完全代替人工代码审计。然而，当代码量变大、有众多开发者时，这样的工具往往有助于以可重复的方式找出容易被发现的问题。它对于帮助新开发者识别和在编码时避免引入这些安全缺陷很有用。</p><hr><p>via: <a target="_blank" rel="noopener" href="https://opensource.com/article/20/9/gosec">https://opensource.com/article/20/9/gosec</a></p><p>作者：<a target="_blank" rel="noopener" href="https://opensource.com/users/gkamathe">Gaurav Kamathe</a> 选题：<a target="_blank" rel="noopener" href="https://github.com/lujun9972">lujun9972</a> 译者：<a target="_blank" rel="noopener" href="https://github.com/lxbwolf">lxbowlf</a> 校对：<a target="_blank" rel="noopener" href="https://github.com/wxy">wxy</a></p><p>本文由 <a target="_blank" rel="noopener" href="https://github.com/LCTT/TranslateProject">LCTT</a> 原创编译，<a target="_blank" rel="noopener" href="https://linux.cn/">Linux中国</a> 荣誉推出</p></div></div></div><div class="footer"><p class="footer-copyright"><span>Powered by <a target="_blank" href="https://hexo.io">Hexo</a></span> <span>Theme <a target="_blank" href="https://github.com/tinkink-co/hexo-theme-terminal">Terminal</a></span><script type="text/javascript" src="https://cdn.staticfile.net/jquery/3.4.1/jquery.min.js"></script><script>getCDNinfo=function(){$.ajax({url:"/cdn-cgi/trace",success:function(a,n){let i="Antananarivo, Madagascar - (TNR);Cape Town, South Africa - (CPT);Casablanca, Morocco - (CMN);Dar Es Salaam, Tanzania - (DAR);Djibouti City, Djibouti - (JIB);Durban, South Africa - (DUR);Johannesburg, South Africa - (JNB);Kigali, Rwanda - (KGL);Lagos, Nigeria - (LOS);Luanda, Angola - (LAD);Maputo, MZ - (MPM);Mombasa, Kenya - (MBA);Port Louis, Mauritius - (MRU);Réunion, France - (RUN);Bangalore, India - (BLR);Bangkok, Thailand - (BKK);Bandar Seri Begawan, Brunei - (BWN);Cebu, Philippines - (CEB);Chengdu, China - (CTU);Chennai, India - (MAA);Chittagong, Bangladesh - (CGP);Chongqing, China - (CKG);Colombo, Sri Lanka - (CMB);Dhaka, Bangladesh - (DAC);Dongguan, China - (SZX);Foshan, China - (FUO);Fuzhou, China - (FOC);Guangzhou, China - (CAN);Hangzhou, China - (HGH);Hanoi, Vietnam - (HAN);Hengyang, China - (HNY);Ho Chi Minh City, Vietnam - (SGN);Hong Kong - (HKG);Hyderabad, India - (HYD);Islamabad, Pakistan - (ISB);Jakarta, Indonesia - (CGK);Jinan, China - (TNA);Karachi, Pakistan - (KHI);Kathmandu, Nepal - (KTM);Kolkata, India - (CCU);Kuala Lumpur, Malaysia - (KUL);Lahore, Pakistan - (LHE);Langfang, China - (NAY);Luoyang, China - (LYA);Macau - (MFM);Malé, Maldives - (MLE);Manila, Philippines - (MNL);Mumbai, India - (BOM);Nagpur, India - (NAG);Nanning, China - (NNG);New Delhi, India - (DEL);Osaka, Japan - (KIX);Phnom Penh, Cambodia - (PNH);Qingdao, China - (TAO);Seoul, South Korea - (ICN);Shanghai, China - (SHA);Shenyang, China - (SHE);Shijiazhuang, China - (SJW);Singapore, Singapore - (SIN);Suzhou, China - (SZV);Taipei - (TPE);Thimphu, Bhutan - (PBH);Tianjin, China - (TSN);Tokyo, Japan - (NRT);Ulaanbaatar, Mongolia - (ULN);Vientiane, Laos - (VTE);Wuhan, China - (WUH);Wuxi, China - (WUX);Xi'an, China - (XIY);Yerevan, Armenia - (EVN);Zhengzhou, China - (CGO);Zuzhou, China - (CSX);Amsterdam, Netherlands - (AMS);Athens, Greece - (ATH);Barcelona, Spain - (BCN);Belgrade, Serbia - (BEG);Berlin, Germany - (TXL);Brussels, Belgium - (BRU);Bucharest, Romania - (OTP);Budapest, Hungary - (BUD);Chișinău, Moldova - (KIV);Copenhagen, Denmark - (CPH);Cork, Ireland -  (ORK);Dublin, Ireland - (DUB);Düsseldorf, Germany - (DUS);Edinburgh, United Kingdom - (EDI);Frankfurt, Germany - (FRA);Geneva, Switzerland - (GVA);Gothenburg, Sweden - (GOT);Hamburg, Germany - (HAM);Helsinki, Finland - (HEL);Istanbul, Turkey - (IST);Kyiv, Ukraine - (KBP);Lisbon, Portugal - (LIS);London, United Kingdom - (LHR);Luxembourg City, Luxembourg - (LUX);Madrid, Spain - (MAD);Manchester, United Kingdom - (MAN);Marseille, France - (MRS);Milan, Italy - (MXP);Moscow, Russia - (DME);Munich, Germany - (MUC);Nicosia, Cyprus - (LCA);Oslo, Norway - (OSL);Paris, France - (CDG);Prague, Czech Republic - (PRG);Reykjavík, Iceland - (KEF);Riga, Latvia - (RIX);Rome, Italy - (FCO);Saint Petersburg, Russia - (LED);Sofia, Bulgaria - (SOF);Stockholm, Sweden - (ARN);Tallinn, Estonia - (TLL);Thessaloniki, Greece - (SKG);Vienna, Austria - (VIE);Vilnius, Lithuania - (VNO);Warsaw, Poland - (WAW);Zagreb, Croatia - (ZAG);Zürich, Switzerland - (ZRH);Arica, Chile - (ARI);Asunción, Paraguay - (ASU);Bogotá, Colombia - (BOG);Buenos Aires, Argentina - (EZE);Curitiba, Brazil - (CWB);Fortaleza, Brazil - (FOR);Guatemala City, Guatemala - (GUA);Lima, Peru - (LIM);Medellín, Colombia - (MDE);Panama City, Panama - (PTY);Porto Alegre, Brazil - (POA);Quito, Ecuador - (UIO);Rio de Janeiro, Brazil - (GIG);São Paulo, Brazil - (GRU);Santiago, Chile - (SCL);Willemstad, Curaçao - (CUR);St. George's, Grenada - (GND);Amman, Jordan - (AMM);Baghdad, Iraq - (BGW);Baku, Azerbaijan - (GYD);Beirut, Lebanon - (BEY);Doha, Qatar - (DOH);Dubai, United Arab Emirates - (DXB);Kuwait City, Kuwait - (KWI);Manama, Bahrain - (BAH);Muscat, Oman - (MCT);Ramallah - (ZDM);Riyadh, Saudi Arabia - (RUH);Tel Aviv, Israel - (TLV);Ashburn, VA, United States - (IAD);Atlanta, GA, United States - (ATL);Boston, MA, United States - (BOS);Buffalo, NY, United States - (BUF);Calgary, AB, Canada - (YYC);Charlotte, NC, United States - (CLT);Chicago, IL, United States - (ORD);Columbus, OH, United States - (CMH);Dallas, TX, United States - (DFW);Denver, CO, United States - (DEN);Detroit, MI, United States - (DTW);Honolulu, HI, United States - (HNL);Houston, TX, United States - (IAH);Indianapolis, IN, United States - (IND);Jacksonville, FL, United States - (JAX);Kansas City, MO, United States - (MCI);Las Vegas, NV, United States - (LAS);Los Angeles, CA, United States - (LAX);McAllen, TX, United States - (MFE);Memphis, TN, United States - (MEM);Mexico City, Mexico - (MEX);Miami, FL, United States - (MIA);Minneapolis, MN, United States - (MSP);Montgomery, AL, United States - (MGM);Montréal, QC, Canada - (YUL);Nashville, TN, United States - (BNA);Newark, NJ, United States - (EWR);Norfolk, VA, United States - (ORF);Omaha, NE, United States - (OMA);Philadelphia, United States - (PHL);Phoenix, AZ, United States - (PHX);Pittsburgh, PA, United States - (PIT);Port-Au-Prince, Haiti - (PAP);Portland, OR, United States - (PDX);Queretaro, MX, Mexico - (QRO);Richmond, Virginia - (RIC);Sacramento, CA, United States - (SMF);Salt Lake City, UT, United States - (SLC);San Diego, CA, United States - (SAN);San Jose, CA, United States - (SJC);Saskatoon, SK, Canada - (YXE);Seattle, WA, United States - (SEA);St. Louis, MO, United States - (STL);Tampa, FL, United States - (TPA);Toronto, ON, Canada - (YYZ);Vancouver, BC, Canada - (YVR);Tallahassee, FL, United States - (TLH);Winnipeg, MB, Canada - (YWG);Adelaide, SA, Australia - (ADL);Auckland, New Zealand - (AKL);Brisbane, QLD, Australia - (BNE);Melbourne, VIC, Australia - (MEL);Noumea, New caledonia - (NOU);Perth, WA, Australia - (PER);Sydney, NSW, Australia - (SYD)".split(";"),e=a.split("colo=")[1].split("\n")[0],t=(a.split("colo=")[1].split("\n")[0],a.split("tls=")[1].split("\n")[0]),o=a.split("http=")[1].split("\n")[0],s=a.split("sni=")[1].split("\n")[0],r=a.split("ip=")[1].split("\n")[0],l=a.split("uag=")[1].split("\n")[0];for(var d=0;d<i.length;d++)if(-1!=i[d].indexOf(e)){document.getElementById("cdn").innerHTML=i[d];break}document.getElementById("tls").innerHTML=t,document.getElementById("http").innerHTML=o,document.getElementById("sni").innerHTML=s,document.getElementById("ip").innerHTML=r,document.getElementById("useragent").innerHTML=l}})},$(document).ready((function(){getCDNinfo()}))</script></p><p style="text-align:center">感谢陪伴与布道，开源之火不灭。​</p><p style="text-align:center"><script>document.write("本次加载耗时: "+(performance.getEntriesByType("navigation").reduce((e,r)=>e+r.responseEnd-r.startTime,0)+performance.getEntriesByType("resource").reduce((e,r)=>e+r.responseEnd-r.startTime,0)).toFixed(0)+"ms")</script></p><p style="text-align:center">当前 SNI 状态： <span id="sni">正在统计！或可能被浏览器防追踪拦截！</span></p><p style="text-align:center">当前 TLS 版本： <span id="tls">正在统计！或可能被浏览器防追踪拦截！</span></p><p style="text-align:center">当前 HTTP 版本： <span id="http">正在统计！或可能被浏览器防追踪拦截！</span></p><p style="text-align:center">当前您的客户端 IP 是： <span id="ip">正在统计！或可能被浏览器防追踪拦截！</span></p><p style="text-align:center">当前分配的 CDN 节点是: <span id="cdn">正在统计！或可能被浏览器防追踪拦截！</span></p><p style="text-align:center">您的 UserAgent 信息是: <span id="useragent">正在统计！或可能被浏览器防追踪拦截！</span></p><p></p></div></div></body></html>