<!doctype html><html lang="en"><head><meta name="description" content="一个LinuxCN的镜像站"><meta name="msvalidate.01" content="D404690CEFCB54C7762AC84935B99171"><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?6618da70c90c8744eead2e9371fb5077";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><script type="text/javascript">!function(t,e,n,c,s,a,r){t[n]=t[n]||function(){(t[n].q=t[n].q||[]).push(arguments)},(a=e.createElement(c)).async=1,a.src="https://www.clarity.ms/tag/s5f3f0tojf",(r=e.getElementsByTagName(c)[0]).parentNode.insertBefore(a,r)}(window,document,"clarity","script")</script><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta http-equiv="X-UA-Compatible" content="ie=edge"><link rel="stylesheet" href="/styles/base.css"><link rel="stylesheet" href="/styles/theme.css"><link rel="shortcut icon" href="/favicon.png"><title>全面教程：在 RxJS 中创建流 - 归墟星火集 又一个 LinuxCN 站点</title><meta name="generator" content="Hexo 7.3.0"></head><body><div class="header-title"><span class="header-light"></span> <span class="header-light"></span> <span class="header-light"></span> <span>归墟星火集 又一个 LinuxCN 站点 linuxcn.undefined.today<span></span></span></div><div class="container"><ul class="nav"><li><a href="/">首页</a></li><li><a target="_blank" rel="noopener" href="https://undefined.today/">Blog</a></li></ul><div class="content"><div class="post-container"><div class="post-header"><span class="ui-tips">标题：</span><h1 class="ui-keyword post-title">全面教程：在 RxJS 中创建流</h1><span class="post-date">2018-09-01</span></div><div class="post-header"><span class="ui-tips">分类：</span> <a href="/categories/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/">软件开发</a></div><div class="post-header"><span class="ui-tips">标签：</span> <a href="/tags/stream/">stream</a> <a href="/tags/RxJS/">RxJS</a></div><div class="post-content"><p><img src="https://linuxcn.img.undefined.today/data/attachment/album/201809/01/225906f2vnvoglzjzmn37l.jpg"></p><p>对大多数开发者来说，与 RxJS 的初次接触是通过库的形式，就像 Angular。一些函数会返回<ruby>流 <rt>stream</rt></ruby>，要使用它们就得把注意力放在操作符上。</p><p>有些时候，混用响应式和非响应式代码似乎很有用。然后大家就开始热衷流的创造。不论是在编写异步代码或者是数据处理时，流都是一个不错的方案。</p><p>RxJS 提供很多方式来创建流。不管你遇到的是什么情况，都会有一个完美的创建流的方式。你可能根本用不上它们，但了解它们可以节省你的时间，让你少码一些代码。</p><p>我把所有可能的方法，按它们的主要目的，放在四个分类当中：</p><ul><li>流式化现有数据</li><li>生成数据</li><li>使用现有 API 进行交互</li><li>选择现有的流，并结合起来</li></ul><p>注意：示例用的是 RxJS 6，可能会以前的版本有所不同。已知的区别是你导入函数的方式不同了。</p><p>RxJS 6</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import &#123;of, from&#125; from &#x27;rxjs&#x27;;</span><br><span class="line"></span><br><span class="line">of(...);</span><br><span class="line">from(...);</span><br></pre></td></tr></table></figure><p>RxJS &lt; 6</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">import &#123; Observable &#125; from &#x27;rxjs/Observable&#x27;;</span><br><span class="line">import &#x27;rxjs/add/observable/of&#x27;;</span><br><span class="line">import &#x27;rxjs/add/observable/from&#x27;;</span><br><span class="line"></span><br><span class="line">Observable.of(...);</span><br><span class="line">Observable.from(...);</span><br><span class="line"></span><br><span class="line">//或</span><br><span class="line"></span><br><span class="line">import &#123; of &#125; from &#x27;rxjs/observable/of&#x27;;</span><br><span class="line">import &#123; from &#125; from &#x27;rxjs/observable/from&#x27;;</span><br><span class="line"></span><br><span class="line">of(...);</span><br><span class="line">from(...);</span><br></pre></td></tr></table></figure><p>流的图示中的标记：</p><ul><li><code>|</code> 表示流结束了</li><li><code>X</code> 表示流出现错误并被终结</li><li><code>...</code> 表示流的走向不定</li></ul><h3 id="流式化已有数据"><a href="#流式化已有数据" class="headerlink" title="流式化已有数据"></a>流式化已有数据</h3><p>你有一些数据，想把它们放到流中。有三种方式，并且都允许你把调度器当作最后一个参数传入（你如果想深入了解调度器，可以看看我的 <a target="_blank" rel="noopener" href="https://itnext.io/concurrency-and-asynchronous-behavior-with-rxjs-11b0c4b22597">上一篇文章</a>）。这些生成的流都是静态的。</p><h4 id="of"><a href="#of" class="headerlink" title="of"></a>of</h4><p>如果只有一个或者一些不同的元素，使用 <code>of</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">of(1,2,3)</span><br><span class="line">  .subscribe();</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 结果</span><br><span class="line">// 1 2 3 |</span><br></pre></td></tr></table></figure><h4 id="from"><a href="#from" class="headerlink" title="from"></a>from</h4><p>如果有一个数组或者 <em>可迭代的对象</em> ，而且你想要其中的所有元素发送到流中，使用 <code>from</code>。你也可以用它来把一个 promise 对象变成可观测的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const foo = [1,2,3];</span><br><span class="line"></span><br><span class="line">from(foo)</span><br><span class="line">  .subscribe();</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 结果</span><br><span class="line">// 1 2 3 |</span><br></pre></td></tr></table></figure><h4 id="pairs"><a href="#pairs" class="headerlink" title="pairs"></a>pairs</h4><p>流式化一个对象的键&#x2F;值对。用这个对象表示字典时特别有用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const foo = &#123; a: 1, b: 2&#125;;</span><br><span class="line"></span><br><span class="line">pairs(foo)</span><br><span class="line">  .subscribe();</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 结果</span><br><span class="line">// [a,1] [b,2] |</span><br></pre></td></tr></table></figure><h4 id="那么其他的数据结构呢？"><a href="#那么其他的数据结构呢？" class="headerlink" title="那么其他的数据结构呢？"></a>那么其他的数据结构呢？</h4><p>也许你的数据存储在自定义的结构中，而它又没有实现 <em>可迭代的对象</em> 接口，又或者说你的结构是递归的、树状的。也许下面某种选择适合这些情况：</p><ol><li>先将数据提取到数组里</li><li>使用下一节将会讲到的 <code>generate</code> 函数，遍历所有数据</li><li>创建一个自定义流（见下一节）</li><li>创建一个迭代器</li></ol><p>稍后会讲到选项 2 和 3 ，因此这里的重点是创建一个迭代器。我们可以对一个 <em>可迭代的对象</em> 调用 <code>from</code> 创建一个流。 <em>可迭代的对象</em> 是一个对象，可以产生一个迭代器（如果你对细节感兴趣，参考 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols">这篇 mdn 文章</a>）。</p><p>创建一个迭代器的简单方式是 <ruby><a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function*">生成函数 </a><rt>generator function</rt></ruby>。当你调用一个生成函数时，它返回一个对象，该对象同时遵循 <em>可迭代的对象</em> 接口和 <em>迭代器</em> 接口。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// 自定义的数据结构</span><br><span class="line">class List &#123;</span><br><span class="line">  add(element) ...</span><br><span class="line">  get(index) ...</span><br><span class="line">  get size() ...</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function* listIterator(list) &#123;</span><br><span class="line">  for (let i = 0; i&lt;list.size; i++) &#123;</span><br><span class="line">    yield list.get(i);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const myList = new List();</span><br><span class="line">myList.add(1);</span><br><span class="line">myList.add(3);</span><br><span class="line"></span><br><span class="line">from(listIterator(myList))</span><br><span class="line">  .subscribe(console.log);</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 结果</span><br><span class="line">// 1 3 |    </span><br></pre></td></tr></table></figure><p>调用 <code>listIterator</code> 函数时，返回值是一个 <em>可迭代的对象</em> &#x2F; <em>迭代器</em> 。函数里面的代码在调用 <code>subscribe</code> 前不会执行。</p><h3 id="生成数据"><a href="#生成数据" class="headerlink" title="生成数据"></a>生成数据</h3><p>你知道要发送哪些数据，但想（或者必须）动态生成它。所有函数的最后一个参数都可以用来接收一个调度器。他们产生静态的流。</p><h4 id="范围（range）"><a href="#范围（range）" class="headerlink" title="范围（range）"></a>范围（<code>range</code>）</h4><p>从初始值开始，发送一系列数字，直到完成了指定次数的迭代。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">range(10, 2)  // 从 10 开始，发送两个值</span><br><span class="line">  .subscribe();</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 结果</span><br><span class="line">// 10 11 |</span><br></pre></td></tr></table></figure><h4 id="间隔（interval）-定时器（timer）"><a href="#间隔（interval）-定时器（timer）" class="headerlink" title="间隔（interval） &#x2F; 定时器（timer）"></a>间隔（<code>interval</code>） &#x2F; 定时器（<code>timer</code>）</h4><p>有点像范围，但定时器是周期性的发送累加的数字（就是说，不是立即发送）。两者的区别在于在于定时器允许你为第一个元素设定一个延迟。也可以只产生一个值，只要不指定周期。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">interval(1000) // 每 1000ms = 1 秒 发送数据</span><br><span class="line">  .subscribe()</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 结果</span><br><span class="line">// 0  1  2  3  4 ...</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">delay(5000, 1000) // 和上面相同，在开始前先等待 5000ms</span><br><span class="line"></span><br><span class="line">delay(5000)</span><br><span class="line">.subscribe(i =&gt; console.log(&quot;foo&quot;);</span><br><span class="line">// 5 秒后打印 foo</span><br></pre></td></tr></table></figure><p>大多数定时器将会用来周期性的处理数据：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">interval(10000).pipe(</span><br><span class="line">  flatMap(i =&gt; fetch(&quot;https://server/stockTicker&quot;)</span><br><span class="line">).subscribe(updateChart)</span><br></pre></td></tr></table></figure><p>这段代码每 10 秒获取一次数据，更新屏幕。</p><h4 id="生成（generate）"><a href="#生成（generate）" class="headerlink" title="生成（generate）"></a>生成（<code>generate</code>）</h4><p>这是个更加复杂的函数，允许你发送一系列任意类型的对象。它有一些重载，这里你看到的是最有意思的部分：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">generate(</span><br><span class="line">  0,           // 从这个值开始</span><br><span class="line">  x =&gt; x &lt; 10, // 条件：只要值小于 10，就一直发送</span><br><span class="line">  x =&gt; x*2     // 迭代：前一个值加倍</span><br><span class="line">).subscribe();</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 结果</span><br><span class="line">// 1 2 4 8 |</span><br></pre></td></tr></table></figure><p>你也可以用它来迭代值，如果一个结构没有实现 <em>可迭代的对象</em> 接口。我们用前面的列表例子来进行演示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const myList = new List();</span><br><span class="line">myList.add(1);</span><br><span class="line">myList.add(3);</span><br><span class="line"></span><br><span class="line">generate(</span><br><span class="line">  0,                  // 从这个值开始</span><br><span class="line">  i =&gt; i &lt; list.size, // 条件：发送数据，直到遍历完整个列表</span><br><span class="line">  i =&gt; ++i,           // 迭代：获取下一个索引</span><br><span class="line">  i =&gt; list.get(i)    // 选择器：从列表中取值</span><br><span class="line">).subscribe();</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 结果</span><br><span class="line">// 1 3 |</span><br></pre></td></tr></table></figure><p>如你所见，我添加了另一个参数：选择器。它和 <code>map</code> 操作符作用类似，将生成的值转换为更有用的东西。</p><h3 id="空的流"><a href="#空的流" class="headerlink" title="空的流"></a>空的流</h3><p>有时候你要传递或返回一个不用发送任何数据的流。有三个函数分别用于不同的情况。你可以给这三个函数传递调度器。<code>empty</code> 和 <code>throwError</code> 接收一个调度器参数。</p><h4 id="empty"><a href="#empty" class="headerlink" title="empty"></a><code>empty</code></h4><p>创建一个空的流，一个值也不发送。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">empty()</span><br><span class="line">  .subscribe();</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 结果</span><br><span class="line">// |</span><br></pre></td></tr></table></figure><h4 id="never"><a href="#never" class="headerlink" title="never"></a><code>never</code></h4><p>创建一个永远不会结束的流，仍然不发送值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">never()</span><br><span class="line">  .subscribe();</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 结果</span><br><span class="line">// ...</span><br></pre></td></tr></table></figure><h4 id="throwError"><a href="#throwError" class="headerlink" title="throwError"></a><code>throwError</code></h4><p>创建一个流，流出现错误，不发送数据。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">throwError(&#x27;error&#x27;)</span><br><span class="line">  .subscribe();</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 结果</span><br><span class="line">// X</span><br></pre></td></tr></table></figure><h3 id="挂钩已有的-API"><a href="#挂钩已有的-API" class="headerlink" title="挂钩已有的 API"></a>挂钩已有的 API</h3><p>不是所有的库和所有你之前写的代码使用或者支持流。幸运的是 RxJS 提供函数用来桥接非响应式和响应式代码。这一节仅仅讨论 RxJS 为桥接代码提供的模版。</p><p>你可能还对这篇出自 <a target="_blank" rel="noopener" href="https://medium.com/@benlesh">Ben Lesh</a> 的 <a target="_blank" rel="noopener" href="https://medium.com/@benlesh/rxjs-observable-interop-with-promises-and-async-await-bebb05306875">全面的文章</a> 感兴趣，这篇文章讲了几乎所有能与 promises 交互操作的方式。</p><h4 id="from-1"><a href="#from-1" class="headerlink" title="from"></a><code>from</code></h4><p>我们已经用过它，把它列在这里是因为，它可以封装一个含有 observable 对象的 promise 对象。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">from(new Promise(resolve =&gt; resolve(1)))</span><br><span class="line">  .subscribe();</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 结果</span><br><span class="line">// 1 |</span><br></pre></td></tr></table></figure><h4 id="fromEvent"><a href="#fromEvent" class="headerlink" title="fromEvent"></a>fromEvent</h4><p>fromEvent 为 DOM 元素添加一个事件监听器，我确定你知道这个。但你可能不知道的是，也可以通过其它类型来添加事件监听器，例如，一个 jQuery 对象。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const element = $(&#x27;#fooButton&#x27;); // 从 DOM 元素中创建一个 jQuery 对象</span><br><span class="line"></span><br><span class="line">from(element, &#x27;click&#x27;)</span><br><span class="line">  .subscribe();</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 结果</span><br><span class="line">// clickEvent ...</span><br></pre></td></tr></table></figure><h4 id="fromEventPattern"><a href="#fromEventPattern" class="headerlink" title="fromEventPattern"></a>fromEventPattern</h4><p>要理解为什么有 fromEvent 了还需要 fromEventPattern，我们得先理解 fromEvent 是如何工作的。看这段代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">from(document, &#x27;click&#x27;)</span><br><span class="line">  .subscribe();</span><br></pre></td></tr></table></figure><p>这告诉 RxJS 我们想要监听 document 中的点击事件。在提交过程中，RxJS 发现 document 是一个 <em>EventTarget</em> 类型，因此它可以调用它的 <code>addEventListener</code> 方法。如果我们传入的是一个 jQuery 对象而非 document，那么 RxJs 知道它得调用 <em>on</em> 方法。</p><p>这个例子用的是 <em>fromEventPattern</em> ，和 <em>fromEvent</em> 的工作基本上一样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function addClickHandler(handler) &#123;</span><br><span class="line">  document.addEventListener(&#x27;click&#x27;, handler);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function removeClickHandler(handler) &#123;</span><br><span class="line">  document.removeEventListener(&#x27;click&#x27;, handler);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fromEventPattern(</span><br><span class="line">  addClickHandler,</span><br><span class="line">  removeClickHandler,</span><br><span class="line">)</span><br><span class="line">.subscribe(console.log);</span><br><span class="line"></span><br><span class="line">// 等效于</span><br><span class="line">fromEvent(document, &#x27;click&#x27;)</span><br></pre></td></tr></table></figure><p>RxJS 自动创建实际的监听器（ <em>handler</em> ）你的工作是添加或者移除监听器。<em>fromEventPattern</em> 的目的基本上是告诉 RxJS 如何注册和移除事件监听器。</p><p>现在想象一下你使用了一个库，你可以调用一个叫做 <em>registerListener</em> 的方法。我们不能再用 <em>fromEvent</em>，因为它并不知道该怎么处理这个对象。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">const listeners = [];</span><br><span class="line"></span><br><span class="line">class Foo &#123;</span><br><span class="line">  registerListener(listener) &#123;</span><br><span class="line">    listeners.push(listener);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  emit(value) &#123;</span><br><span class="line">    listeners.forEach(listener =&gt; listener(value));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const foo = new Foo();</span><br><span class="line"></span><br><span class="line">fromEventPattern(listener =&gt; foo.registerListener(listener))</span><br><span class="line">  .subscribe();</span><br><span class="line"></span><br><span class="line">foo.emit(1);</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 结果</span><br><span class="line">// 1 ...</span><br></pre></td></tr></table></figure><p>当我们调用 <code>foo.emit(1)</code> 时，RxJS 中的监听器将被调用，然后它就能把值发送到流中。</p><p>你也可以用它来监听多个事件类型，或者结合所有可以通过回调进行通讯的 API，例如，WebWorker API:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const myWorker = new Worker(&#x27;worker.js&#x27;);</span><br><span class="line"></span><br><span class="line">fromEventPattern(</span><br><span class="line">  handler =&gt; &#123; myWorker.onmessage = handler &#125;,</span><br><span class="line">  handler =&gt; &#123; myWorker.onmessage = undefined &#125;</span><br><span class="line">)</span><br><span class="line">.subscribe();</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 结果</span><br><span class="line">// workerMessage ...</span><br></pre></td></tr></table></figure><h4 id="bindCallback"><a href="#bindCallback" class="headerlink" title="bindCallback"></a>bindCallback</h4><p>它和 fromEventPattern 相似，但它能用于单个值。就在回调函数被调用时，流就结束了。用法当然也不一样 —— 你可以用 bindCallBack 封装函数，然后它就会在调用时魔术般的返回一个流：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function foo(value, callback) &#123;</span><br><span class="line">  callback(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 没有流</span><br><span class="line">foo(1, console.log); //prints 1 in the console</span><br><span class="line"></span><br><span class="line">// 有流</span><br><span class="line">const reactiveFoo = bindCallback(foo); </span><br><span class="line">// 当我们调用 reactiveFoo 时，它返回一个 observable 对象</span><br><span class="line"></span><br><span class="line">reactiveFoo(1)</span><br><span class="line">  .subscribe(console.log); // 在控制台打印 1</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 结果</span><br><span class="line">// 1 |</span><br></pre></td></tr></table></figure><h4 id="websocket"><a href="#websocket" class="headerlink" title="websocket"></a>websocket</h4><p>是的，你完全可以创建一个 websocket 连接然后把它暴露给流：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import &#123; webSocket &#125; from &#x27;rxjs/webSocket&#x27;; </span><br><span class="line"></span><br><span class="line">let socket$ = webSocket(&#x27;ws://localhost:8081&#x27;);</span><br><span class="line"></span><br><span class="line">// 接收消息</span><br><span class="line">socket$.subscribe(</span><br><span class="line">  (msg) =&gt; console.log(&#x27;message received: &#x27; + msg),</span><br><span class="line">  (err) =&gt; console.log(err),</span><br><span class="line">  () =&gt; console.log(&#x27;complete&#x27;) * );</span><br><span class="line"></span><br><span class="line">// 发送消息</span><br><span class="line">socket$.next(JSON.stringify(&#123; op: &#x27;hello&#x27; &#125;));</span><br></pre></td></tr></table></figure><p>把 websocket 功能添加到你的应用中真的很简单。<em>websocket</em> 创建一个 subject。这意味着你可以订阅它，通过调用 <code>next</code> 来获得消息和发送消息。</p><h4 id="ajax"><a href="#ajax" class="headerlink" title="ajax"></a>ajax</h4><p>如你所知：类似于 websocket，提供 AJAX 查询的功能。你可能用了一个带有 AJAX 功能的库或者框架。或者你没有用，那么我建议使用 fetch（或者必要的话用 polyfill），把返回的 promise 封装到一个 observable 对象中（参考稍后会讲到的 <code>defer</code> 函数）。</p><h3 id="定制流"><a href="#定制流" class="headerlink" title="定制流"></a>定制流</h3><p>有时候已有的函数用起来并不是足够灵活。或者你需要对订阅有更强的控制。</p><h4 id="主题（Subject）"><a href="#主题（Subject）" class="headerlink" title="主题（Subject）"></a>主题（<code>Subject</code>）</h4><p><code>Subject</code> 是一个特殊的对象，它使得你的能够把数据发送到流中，并且能够控制数据。<code>Subject</code> 本身就是一个可观察对象，但如果你想要把流暴露给其它代码，建议你使用 <code>asObservable</code> 方法。这样你就不能意外调用原始方法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const subject = new Subject();</span><br><span class="line">const observable = subject.asObservable();</span><br><span class="line"></span><br><span class="line">observable.subscribe();</span><br><span class="line"></span><br><span class="line">subject.next(1);</span><br><span class="line">subject.next(2);</span><br><span class="line">subject.complete();</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 结果</span><br><span class="line">// 1 2 |</span><br></pre></td></tr></table></figure><p>注意在订阅前发送的值将会“丢失”：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const subject = new Subject();</span><br><span class="line">const observable = subject.asObservable();</span><br><span class="line"></span><br><span class="line">subject.next(1);</span><br><span class="line"></span><br><span class="line">observable.subscribe(console.log);</span><br><span class="line"></span><br><span class="line">subject.next(2);</span><br><span class="line">subject.complete();</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 结果</span><br><span class="line">// 2</span><br></pre></td></tr></table></figure><p>除了常规的 <code>Subject</code>，RxJS 还提供了三种特殊的版本。</p><p><code>AsyncSubject</code> 在结束后只发送最后的一个值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const subject = new AsyncSubject();</span><br><span class="line">const observable = subject.asObservable();</span><br><span class="line"></span><br><span class="line">observable.subscribe(console.log);</span><br><span class="line"></span><br><span class="line">subject.next(1);</span><br><span class="line">subject.next(2);</span><br><span class="line">subject.complete();</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 输出</span><br><span class="line">// 2</span><br></pre></td></tr></table></figure><p><code>BehaviorSubject</code> 使得你能够提供一个（默认的）值，如果当前没有其它值发送的话，这个值会被发送给每个订阅者。否则订阅者收到最后一个发送的值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const subject = new BehaviorSubject(1);</span><br><span class="line">const observable = subject.asObservable();</span><br><span class="line"></span><br><span class="line">const subscription1 = observable.subscribe(console.log);</span><br><span class="line"></span><br><span class="line">subject.next(2);</span><br><span class="line">subscription1.unsubscribe();</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 输出</span><br><span class="line">// 1</span><br><span class="line">// 2</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const subscription2 = observable.subscribe(console.log);</span><br><span class="line"></span><br><span class="line">// 输出</span><br><span class="line">// 2</span><br></pre></td></tr></table></figure><p><code>ReplaySubject</code> 存储一定数量、或一定时间或所有的发送过的值。所有新的订阅者将会获得所有存储了的值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const subject = new ReplaySubject();</span><br><span class="line">const observable = subject.asObservable();</span><br><span class="line"></span><br><span class="line">subject.next(1);</span><br><span class="line"></span><br><span class="line">observable.subscribe(console.log);</span><br><span class="line"></span><br><span class="line">subject.next(2);</span><br><span class="line">subject.complete();</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 输出</span><br><span class="line">// 1</span><br><span class="line">// 2</span><br></pre></td></tr></table></figure><p>你可以在 <a target="_blank" rel="noopener" href="http://reactivex.io/documentation/subject.html">ReactiveX 文档</a>（它提供了一些其它的连接） 里面找到更多关于 <code>Subject</code> 的信息。<a target="_blank" rel="noopener" href="https://medium.com/@benlesh">Ben Lesh</a> 在 <a target="_blank" rel="noopener" href="https://medium.com/@benlesh/on-the-subject-of-subjects-in-rxjs-2b08b7198b93">On The Subject Of Subjects</a> 上面提供了一些关于 <code>Subject</code> 的理解，<a target="_blank" rel="noopener" href="https://medium.com/@cartant">Nicholas Jamieson</a> 在 <a target="_blank" rel="noopener" href="https://blog.angularindepth.com/rxjs-understanding-subjects-5c585188c3e1">in RxJS: Understanding Subjects</a> 上也提供了一些理解。</p><h4 id="可观察对象"><a href="#可观察对象" class="headerlink" title="可观察对象"></a>可观察对象</h4><p>你可以简单地用 new 操作符创建一个可观察对象。通过你传入的函数，你可以控制流，只要有人订阅了或者它接收到一个可以当成 <code>Subject</code> 使用的观察者，这个函数就会被调用，比如，调用 <code>next</code>、<code>complet</code> 和 <code>error</code>。</p><p>让我们回顾一下列表示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">const myList = new List();</span><br><span class="line">myList.add(1);</span><br><span class="line">myList.add(3);</span><br><span class="line"></span><br><span class="line">new Observable(observer =&gt; &#123;</span><br><span class="line">  for (let i = 0; i&lt;list.size; i++) &#123;</span><br><span class="line">    observer.next(list.get(i));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  observer.complete();</span><br><span class="line">&#125;)</span><br><span class="line">.subscribe();</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 结果</span><br><span class="line">// 1 3 |</span><br></pre></td></tr></table></figure><p>这个函数可以返回一个 <code>unsubcribe</code> 函数，当有订阅者取消订阅时这个函数就会被调用。你可以用它来清楚或者执行一些收尾操作。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">new Observable(observer =&gt; &#123;</span><br><span class="line">  // 流式化</span><br><span class="line"></span><br><span class="line">  return () =&gt; &#123;</span><br><span class="line">                 //clean up</span><br><span class="line">               &#125;;</span><br><span class="line">&#125;)</span><br><span class="line">.subscribe();</span><br></pre></td></tr></table></figure><h4 id="继承可观察对象"><a href="#继承可观察对象" class="headerlink" title="继承可观察对象"></a>继承可观察对象</h4><p>在有可用的操作符前，这是一种实现自定义操作符的方式。RxJS 在内部扩展了 <em>可观察对象</em> 。<code>Subject</code> 就是一个例子，另一个是 <code>publisher</code> 操作符。它返回一个 <code>ConnectableObservable</code> 对象，该对象提供额外的方法 <code>connect</code>。</p><h4 id="实现-Subscribable-接口"><a href="#实现-Subscribable-接口" class="headerlink" title="实现 Subscribable 接口"></a>实现 <code>Subscribable</code> 接口</h4><p>有时候你已经用一个对象来保存状态，并且能够发送值。如果你实现了 <code>Subscribable</code> 接口，你可以把它转换成一个可观察对象。<code>Subscribable</code> 接口中只有一个 <code>subscribe</code> 方法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">interface Subscribable&lt;T&gt; &#123;  subscribe(observerOrNext?: PartialObserver&lt;T&gt; | ((value: T) =&gt; void), error?: (error: any) =&gt; void, complete?: () =&gt; void): Unsubscribable&#125;</span><br></pre></td></tr></table></figure><h3 id="结合和选择现有的流"><a href="#结合和选择现有的流" class="headerlink" title="结合和选择现有的流"></a>结合和选择现有的流</h3><p>知道怎么创建一个独立的流还不够。有时候你有好几个流但其实只需要一个。有些函数也可作为操作符，所以我不打算在这里深入展开。推荐看看 <a target="_blank" rel="noopener" href="https://medium.com/@maximus.koretskyi">Max NgWizard K</a> 所写的一篇 <a target="_blank" rel="noopener" href="https://blog.angularindepth.com/learn-to-combine-rxjs-sequences-with-super-intuitive-interactive-diagrams-20fce8e6511">文章</a>，它还包含一些有趣的动画。</p><p>还有一个建议：你可以通过拖拽元素的方式交互式的使用结合操作，参考 <a target="_blank" rel="noopener" href="http://rxmarbles.com/#merge">RxMarbles</a>。</p><h4 id="ObservableInput-类型"><a href="#ObservableInput-类型" class="headerlink" title="ObservableInput 类型"></a>ObservableInput 类型</h4><p>期望接收流的操作符和函数通常不单独和可观察对象一起工作。相反，它们实际上期望的参数类型是 ObservableInput，定义如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type ObservableInput&lt;T&gt; = SubscribableOrPromise&lt;T&gt; | ArrayLike&lt;T&gt; | Iterable&lt;T&gt;;</span><br></pre></td></tr></table></figure><p>这意味着你可以传递一个 promises 或者数组却不需要事先把他们转换成可观察对象。</p><h4 id="defer"><a href="#defer" class="headerlink" title="defer"></a>defer</h4><p>主要的目的是把一个 observable 对象的创建延迟（<code>defer</code>）到有人想要订阅的时间。在以下情况，这很有用：</p><ul><li>创建可观察对象的开销较大</li><li>你想要给每个订阅者新的可观察对象</li><li>你想要在订阅时候选择不同的可观察对象</li><li>有些代码必须在订阅之后执行</li></ul><p>最后一点包含了一个并不起眼的用例：Promises（<code>defer</code> 也可以返回一个 promise 对象）。看看这个用到了 fetch API 的例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function getUser(id) &#123;</span><br><span class="line">  console.log(&quot;fetching data&quot;);</span><br><span class="line">  return fetch(`https://server/user/$&#123;id&#125;`);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const userPromise = getUser(1);</span><br><span class="line">console.log(&quot;I don&#x27;t want that request now&quot;);</span><br><span class="line"></span><br><span class="line">// 其它地方</span><br><span class="line">userPromise.then(response =&gt; console.log(&quot;done&quot;);</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 输出</span><br><span class="line">// fetching data</span><br><span class="line">// I don&#x27;t want that request now</span><br><span class="line">// done</span><br></pre></td></tr></table></figure><p>只要流在你订阅的时候执行了，promise 就会立即执行。我们调用 <code>getUser</code> 的瞬间，就发送了一个请求，哪怕我们这个时候不想发送请求。当然，我们可以使用 <code>from</code> 来把一个 promise 对象转换成可观察对象，但我们传递的 promise 对象已经创建或执行了。<code>defer</code> 让我们能够等到订阅才发送这个请求：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const user$ = defer(() =&gt; getUser(1));</span><br><span class="line"></span><br><span class="line">console.log(&quot;I don&#x27;t want that request now&quot;);</span><br><span class="line"></span><br><span class="line">// 其它地方</span><br><span class="line">user$.subscribe(response =&gt; console.log(&quot;done&quot;);</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 输出</span><br><span class="line">// I don&#x27;t want that request now</span><br><span class="line">// fetching data</span><br><span class="line">// done</span><br></pre></td></tr></table></figure><h4 id="iif"><a href="#iif" class="headerlink" title="iif"></a>iif</h4><p><code>iif</code> 包含了一个关于 <code>defer</code> 的特殊用例：在订阅时选择两个流中的一个：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">iif(</span><br><span class="line">  () =&gt; new Date().getHours() &lt; 12,</span><br><span class="line">  of(&quot;AM&quot;),</span><br><span class="line">  of(&quot;PM&quot;)</span><br><span class="line">)</span><br><span class="line">.subscribe();</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 结果</span><br><span class="line">// AM before noon, PM afterwards</span><br></pre></td></tr></table></figure><p>引用该文档：</p><blockquote><p>实际上 <a target="_blank" rel="noopener" href="https://rxjs-dev.firebaseapp.com/api/index/iif">iif</a> 能够轻松地用 <a target="_blank" rel="noopener" href="https://rxjs-dev.firebaseapp.com/api/index/defer">defer</a> 实现，它仅仅是出于方便和可读性的目的。</p></blockquote><h4 id="onErrorResumeNext"><a href="#onErrorResumeNext" class="headerlink" title="onErrorResumeNext"></a>onErrorResumeNext</h4><p>开启第一个流并且在失败的时候继续进行下一个流。错误被忽略掉。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const stream1$ = of(1, 2).pipe(</span><br><span class="line">  tap(i =&gt; &#123; if(i&gt;1) throw &#x27;error&#x27;&#125;) //fail after first element</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">const stream2$ = of(3,4);</span><br><span class="line"></span><br><span class="line">onErrorResumeNext(stream1$, stream2$)</span><br><span class="line">  .subscribe(console.log);</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 结果</span><br><span class="line">// 1 3 4 |</span><br></pre></td></tr></table></figure><p>如果你有多个 web 服务，这就很有用了。万一主服务器开启失败，那么备份的服务就能自动调用。</p><h4 id="forkJoin"><a href="#forkJoin" class="headerlink" title="forkJoin"></a>forkJoin</h4><p>它让流并行运行，当流结束时发送存在数组中的最后的值。由于每个流只有最后一个值被发送，它一般用在只发送一个元素的流的情况，就像 HTTP 请求。你让请求并行运行，在所有流收到响应时执行某些任务。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function handleResponses([user, account]) &#123;</span><br><span class="line">  // 执行某些任务</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">forkJoin(</span><br><span class="line">  fetch(&quot;https://server/user/1&quot;),</span><br><span class="line">  fetch(&quot;https://server/account/1&quot;)</span><br><span class="line">)</span><br><span class="line">.subscribe(handleResponses);</span><br></pre></td></tr></table></figure><h4 id="merge-concat"><a href="#merge-concat" class="headerlink" title="merge &#x2F; concat"></a>merge &#x2F; concat</h4><p>发送每一个从可观察对象源中发出的值。</p><p><code>merge</code> 接收一个参数，让你定义有多少流能被同时订阅。默认是无限制的。设为 1 就意味着监听一个源流，在它结束的时候订阅下一个。由于这是一个常见的场景，RxJS 为你提供了一个显示的函数：<code>concat</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">merge(</span><br><span class="line">  interval(1000).pipe(mapTo(&quot;Stream 1&quot;), take(2)),</span><br><span class="line">  interval(1200).pipe(mapTo(&quot;Stream 2&quot;), take(2)),</span><br><span class="line">  timer(0, 1000).pipe(mapTo(&quot;Stream 3&quot;), take(2)),</span><br><span class="line">  2 //two concurrent streams</span><br><span class="line">)</span><br><span class="line">.subscribe();</span><br><span class="line"></span><br><span class="line">// 只订阅流 1 和流 2</span><br><span class="line"></span><br><span class="line">// 输出</span><br><span class="line">// Stream 1 -&gt; after 1000ms</span><br><span class="line">// Stream 2 -&gt; after 1200ms</span><br><span class="line">// Stream 1 -&gt; after 2000ms</span><br><span class="line"></span><br><span class="line">// 流 1 结束后，开始订阅流 3</span><br><span class="line"></span><br><span class="line">// 输出</span><br><span class="line">// Stream 3 -&gt; after 0 ms</span><br><span class="line">// Stream 2 -&gt; after 400 ms (2400ms from beginning)</span><br><span class="line">// Stream 3 -&gt; after 1000ms</span><br><span class="line"></span><br><span class="line">merge(</span><br><span class="line">  interval(1000).pipe(mapTo(&quot;Stream 1&quot;), take(2)),</span><br><span class="line">  interval(1200).pipe(mapTo(&quot;Stream 2&quot;), take(2))</span><br><span class="line">  1</span><br><span class="line">)</span><br><span class="line">// 等效于</span><br><span class="line">concat(</span><br><span class="line">  interval(1000).pipe(mapTo(&quot;Stream 1&quot;), take(2)),</span><br><span class="line">  interval(1200).pipe(mapTo(&quot;Stream 2&quot;), take(2))</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// 输出</span><br><span class="line">// Stream 1 -&gt; after 1000ms</span><br><span class="line">// Stream 1 -&gt; after 2000ms</span><br><span class="line">// Stream 2 -&gt; after 3200ms</span><br><span class="line">// Stream 2 -&gt; after 4400ms</span><br></pre></td></tr></table></figure><h4 id="zip-combineLatest"><a href="#zip-combineLatest" class="headerlink" title="zip &#x2F; combineLatest"></a>zip &#x2F; combineLatest</h4><p><code>merge</code> 和 <code>concat</code> 一个接一个的发送所有从源流中读到的值，而 <code>zip</code> 和 <code>combineLatest</code> 是把每个流中的一个值结合起来一起发送。<code>zip</code> 结合所有源流中发送的第一个值。如果流的内容相关联，那么这就很有用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">zip(</span><br><span class="line">  interval(1000),</span><br><span class="line">  interval(1200),</span><br><span class="line">)</span><br><span class="line">.subscribe();</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 结果</span><br><span class="line">// [0, 0] [1, 1] [2, 2] ...</span><br></pre></td></tr></table></figure><p><code>combineLatest</code> 与之类似，但结合的是源流中发送的最后一个值。直到所有源流至少发送一个值之后才会触发事件。这之后每次源流发送一个值，它都会把这个值与其他流发送的最后一个值结合起来。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">combineLatest(</span><br><span class="line">  interval(1000),</span><br><span class="line">  interval(1200),</span><br><span class="line">)</span><br><span class="line">.subscribe();</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 结果</span><br><span class="line">// [0, 0] [1, 0] [1, 1] [2, 1] ...</span><br></pre></td></tr></table></figure><p>两个函数都让允许传递一个选择器函数，把元素结合成其它对象而不是数组：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">zip(</span><br><span class="line">  interval(1000),</span><br><span class="line">  interval(1200),</span><br><span class="line">  (e1, e2) -&gt; e1 + e2</span><br><span class="line">)</span><br><span class="line">.subscribe();</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 结果</span><br><span class="line">// 0 2 4 6 ...</span><br></pre></td></tr></table></figure><h4 id="race"><a href="#race" class="headerlink" title="race"></a>race</h4><p>选择第一个发送数据的流。产生的流基本是最快的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">race(</span><br><span class="line">  interval(1000),</span><br><span class="line">  of(&quot;foo&quot;)</span><br><span class="line">)</span><br><span class="line">.subscribe();</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 结果</span><br><span class="line">// foo |</span><br></pre></td></tr></table></figure><p>由于 <code>of</code> 立即产生一个值，因此它是最快的流，然而这个流就被选中了。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>已经有很多创建可观察对象的方式了。如果你想要创造响应式的 API 或者想用响应式的 API 结合传统 API，那么了解这些方法很重要。</p><p>我已经向你展示了所有可用的方法，但它们其实还有很多内容可以讲。如果你想更加深入地了解，我极力推荐你查阅 <a target="_blank" rel="noopener" href="http://reactivex.io/documentation/operators.html#creating">文档</a> 或者阅读相关文章。</p><p><a target="_blank" rel="noopener" href="https://rxviz.com/">RxViz</a> 是另一种值得了解的有意思的方式。你编写 RxJS 代码，产生的流可以用图形或动画进行显示。</p><hr><p>via: <a target="_blank" rel="noopener" href="https://blog.angularindepth.com/the-extensive-guide-to-creating-streams-in-rxjs-aaa02baaff9a">https://blog.angularindepth.com/the-extensive-guide-to-creating-streams-in-rxjs-aaa02baaff9a</a></p><p>作者：<a target="_blank" rel="noopener" href="https://blog.angularindepth.com/@abetteroliver">Oliver Flaggl</a> 译者：<a target="_blank" rel="noopener" href="https://github.com/BriFuture">BriFuture</a> 校对：<a target="_blank" rel="noopener" href="https://github.com/wxy">wxy</a></p><p>本文由 <a target="_blank" rel="noopener" href="https://github.com/LCTT/TranslateProject">LCTT</a> 原创编译，<a target="_blank" rel="noopener" href="https://linux.cn/">Linux中国</a> 荣誉推出</p></div></div></div><div class="footer"><p class="footer-copyright"><span>Powered by <a target="_blank" href="https://hexo.io">Hexo</a></span> <span>Theme <a target="_blank" href="https://github.com/tinkink-co/hexo-theme-terminal">Terminal</a></span><script type="text/javascript" src="https://cdn.staticfile.net/jquery/3.4.1/jquery.min.js"></script><script>getCDNinfo=function(){$.ajax({url:"/cdn-cgi/trace",success:function(a,n){let i="Antananarivo, Madagascar - (TNR);Cape Town, South Africa - (CPT);Casablanca, Morocco - (CMN);Dar Es Salaam, Tanzania - (DAR);Djibouti City, Djibouti - (JIB);Durban, South Africa - (DUR);Johannesburg, South Africa - (JNB);Kigali, Rwanda - (KGL);Lagos, Nigeria - (LOS);Luanda, Angola - (LAD);Maputo, MZ - (MPM);Mombasa, Kenya - (MBA);Port Louis, Mauritius - (MRU);Réunion, France - (RUN);Bangalore, India - (BLR);Bangkok, Thailand - (BKK);Bandar Seri Begawan, Brunei - (BWN);Cebu, Philippines - (CEB);Chengdu, China - (CTU);Chennai, India - (MAA);Chittagong, Bangladesh - (CGP);Chongqing, China - (CKG);Colombo, Sri Lanka - (CMB);Dhaka, Bangladesh - (DAC);Dongguan, China - (SZX);Foshan, China - (FUO);Fuzhou, China - (FOC);Guangzhou, China - (CAN);Hangzhou, China - (HGH);Hanoi, Vietnam - (HAN);Hengyang, China - (HNY);Ho Chi Minh City, Vietnam - (SGN);Hong Kong - (HKG);Hyderabad, India - (HYD);Islamabad, Pakistan - (ISB);Jakarta, Indonesia - (CGK);Jinan, China - (TNA);Karachi, Pakistan - (KHI);Kathmandu, Nepal - (KTM);Kolkata, India - (CCU);Kuala Lumpur, Malaysia - (KUL);Lahore, Pakistan - (LHE);Langfang, China - (NAY);Luoyang, China - (LYA);Macau - (MFM);Malé, Maldives - (MLE);Manila, Philippines - (MNL);Mumbai, India - (BOM);Nagpur, India - (NAG);Nanning, China - (NNG);New Delhi, India - (DEL);Osaka, Japan - (KIX);Phnom Penh, Cambodia - (PNH);Qingdao, China - (TAO);Seoul, South Korea - (ICN);Shanghai, China - (SHA);Shenyang, China - (SHE);Shijiazhuang, China - (SJW);Singapore, Singapore - (SIN);Suzhou, China - (SZV);Taipei - (TPE);Thimphu, Bhutan - (PBH);Tianjin, China - (TSN);Tokyo, Japan - (NRT);Ulaanbaatar, Mongolia - (ULN);Vientiane, Laos - (VTE);Wuhan, China - (WUH);Wuxi, China - (WUX);Xi'an, China - (XIY);Yerevan, Armenia - (EVN);Zhengzhou, China - (CGO);Zuzhou, China - (CSX);Amsterdam, Netherlands - (AMS);Athens, Greece - (ATH);Barcelona, Spain - (BCN);Belgrade, Serbia - (BEG);Berlin, Germany - (TXL);Brussels, Belgium - (BRU);Bucharest, Romania - (OTP);Budapest, Hungary - (BUD);Chișinău, Moldova - (KIV);Copenhagen, Denmark - (CPH);Cork, Ireland -  (ORK);Dublin, Ireland - (DUB);Düsseldorf, Germany - (DUS);Edinburgh, United Kingdom - (EDI);Frankfurt, Germany - (FRA);Geneva, Switzerland - (GVA);Gothenburg, Sweden - (GOT);Hamburg, Germany - (HAM);Helsinki, Finland - (HEL);Istanbul, Turkey - (IST);Kyiv, Ukraine - (KBP);Lisbon, Portugal - (LIS);London, United Kingdom - (LHR);Luxembourg City, Luxembourg - (LUX);Madrid, Spain - (MAD);Manchester, United Kingdom - (MAN);Marseille, France - (MRS);Milan, Italy - (MXP);Moscow, Russia - (DME);Munich, Germany - (MUC);Nicosia, Cyprus - (LCA);Oslo, Norway - (OSL);Paris, France - (CDG);Prague, Czech Republic - (PRG);Reykjavík, Iceland - (KEF);Riga, Latvia - (RIX);Rome, Italy - (FCO);Saint Petersburg, Russia - (LED);Sofia, Bulgaria - (SOF);Stockholm, Sweden - (ARN);Tallinn, Estonia - (TLL);Thessaloniki, Greece - (SKG);Vienna, Austria - (VIE);Vilnius, Lithuania - (VNO);Warsaw, Poland - (WAW);Zagreb, Croatia - (ZAG);Zürich, Switzerland - (ZRH);Arica, Chile - (ARI);Asunción, Paraguay - (ASU);Bogotá, Colombia - (BOG);Buenos Aires, Argentina - (EZE);Curitiba, Brazil - (CWB);Fortaleza, Brazil - (FOR);Guatemala City, Guatemala - (GUA);Lima, Peru - (LIM);Medellín, Colombia - (MDE);Panama City, Panama - (PTY);Porto Alegre, Brazil - (POA);Quito, Ecuador - (UIO);Rio de Janeiro, Brazil - (GIG);São Paulo, Brazil - (GRU);Santiago, Chile - (SCL);Willemstad, Curaçao - (CUR);St. George's, Grenada - (GND);Amman, Jordan - (AMM);Baghdad, Iraq - (BGW);Baku, Azerbaijan - (GYD);Beirut, Lebanon - (BEY);Doha, Qatar - (DOH);Dubai, United Arab Emirates - (DXB);Kuwait City, Kuwait - (KWI);Manama, Bahrain - (BAH);Muscat, Oman - (MCT);Ramallah - (ZDM);Riyadh, Saudi Arabia - (RUH);Tel Aviv, Israel - (TLV);Ashburn, VA, United States - (IAD);Atlanta, GA, United States - (ATL);Boston, MA, United States - (BOS);Buffalo, NY, United States - (BUF);Calgary, AB, Canada - (YYC);Charlotte, NC, United States - (CLT);Chicago, IL, United States - (ORD);Columbus, OH, United States - (CMH);Dallas, TX, United States - (DFW);Denver, CO, United States - (DEN);Detroit, MI, United States - (DTW);Honolulu, HI, United States - (HNL);Houston, TX, United States - (IAH);Indianapolis, IN, United States - (IND);Jacksonville, FL, United States - (JAX);Kansas City, MO, United States - (MCI);Las Vegas, NV, United States - (LAS);Los Angeles, CA, United States - (LAX);McAllen, TX, United States - (MFE);Memphis, TN, United States - (MEM);Mexico City, Mexico - (MEX);Miami, FL, United States - (MIA);Minneapolis, MN, United States - (MSP);Montgomery, AL, United States - (MGM);Montréal, QC, Canada - (YUL);Nashville, TN, United States - (BNA);Newark, NJ, United States - (EWR);Norfolk, VA, United States - (ORF);Omaha, NE, United States - (OMA);Philadelphia, United States - (PHL);Phoenix, AZ, United States - (PHX);Pittsburgh, PA, United States - (PIT);Port-Au-Prince, Haiti - (PAP);Portland, OR, United States - (PDX);Queretaro, MX, Mexico - (QRO);Richmond, Virginia - (RIC);Sacramento, CA, United States - (SMF);Salt Lake City, UT, United States - (SLC);San Diego, CA, United States - (SAN);San Jose, CA, United States - (SJC);Saskatoon, SK, Canada - (YXE);Seattle, WA, United States - (SEA);St. Louis, MO, United States - (STL);Tampa, FL, United States - (TPA);Toronto, ON, Canada - (YYZ);Vancouver, BC, Canada - (YVR);Tallahassee, FL, United States - (TLH);Winnipeg, MB, Canada - (YWG);Adelaide, SA, Australia - (ADL);Auckland, New Zealand - (AKL);Brisbane, QLD, Australia - (BNE);Melbourne, VIC, Australia - (MEL);Noumea, New caledonia - (NOU);Perth, WA, Australia - (PER);Sydney, NSW, Australia - (SYD)".split(";"),e=a.split("colo=")[1].split("\n")[0],t=(a.split("colo=")[1].split("\n")[0],a.split("tls=")[1].split("\n")[0]),o=a.split("http=")[1].split("\n")[0],s=a.split("sni=")[1].split("\n")[0],r=a.split("ip=")[1].split("\n")[0],l=a.split("uag=")[1].split("\n")[0];for(var d=0;d<i.length;d++)if(-1!=i[d].indexOf(e)){document.getElementById("cdn").innerHTML=i[d];break}document.getElementById("tls").innerHTML=t,document.getElementById("http").innerHTML=o,document.getElementById("sni").innerHTML=s,document.getElementById("ip").innerHTML=r,document.getElementById("useragent").innerHTML=l}})},$(document).ready((function(){getCDNinfo()}))</script></p><p style="text-align:center">感谢陪伴与布道，开源之火不灭。​</p><p style="text-align:center"><script>document.write("本次加载耗时: "+(performance.getEntriesByType("navigation").reduce((e,r)=>e+r.responseEnd-r.startTime,0)+performance.getEntriesByType("resource").reduce((e,r)=>e+r.responseEnd-r.startTime,0)).toFixed(0)+"ms")</script></p><p style="text-align:center">当前 SNI 状态： <span id="sni">正在统计！或可能被浏览器防追踪拦截！</span></p><p style="text-align:center">当前 TLS 版本： <span id="tls">正在统计！或可能被浏览器防追踪拦截！</span></p><p style="text-align:center">当前 HTTP 版本： <span id="http">正在统计！或可能被浏览器防追踪拦截！</span></p><p style="text-align:center">当前您的客户端 IP 是： <span id="ip">正在统计！或可能被浏览器防追踪拦截！</span></p><p style="text-align:center">当前分配的 CDN 节点是: <span id="cdn">正在统计！或可能被浏览器防追踪拦截！</span></p><p style="text-align:center">您的 UserAgent 信息是: <span id="useragent">正在统计！或可能被浏览器防追踪拦截！</span></p><p></p><script defer src="https://pv.undefined.today/tracker.min.js" data-website-id="LinuxCNMirror-tracker"></script></div></div></body></html>