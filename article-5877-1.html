<!doctype html><html lang="en"><head><meta name="msvalidate.01" content="D404690CEFCB54C7762AC84935B99171"><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?6618da70c90c8744eead2e9371fb5077";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><script type="text/javascript">!function(t,e,n,c,s,a,r){t[n]=t[n]||function(){(t[n].q=t[n].q||[]).push(arguments)},(a=e.createElement(c)).async=1,a.src="https://www.clarity.ms/tag/s5f3f0tojf",(r=e.getElementsByTagName(c)[0]).parentNode.insertBefore(a,r)}(window,document,"clarity","script")</script><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta http-equiv="X-UA-Compatible" content="ie=edge"><link rel="stylesheet" href="/styles/base.css"><link rel="stylesheet" href="/styles/theme.css"><link rel="shortcut icon" href="/favicon.png"><title>为 Kodi 自制遥控器 - 归墟星火集 又一个 LinuxCN 站点</title><meta name="generator" content="Hexo 7.3.0"></head><body><div class="header-title"><span class="header-light"></span> <span class="header-light"></span> <span class="header-light"></span> <span>归墟星火集 又一个 LinuxCN 站点 linuxcn.undefined.today<span></span></span></div><div class="container"><ul class="nav"><li><a href="/">首页</a></li><li><a target="_blank" rel="noopener" href="https://undefined.today/">Blog</a></li></ul><div class="content"><div class="post-container"><div class="post-header"><span class="ui-tips">标题：</span><h1 class="ui-keyword post-title">为 Kodi 自制遥控器</h1><span class="post-date">2015-07-24</span></div><div class="post-header"><span class="ui-tips">分类：</span> <a href="/categories/%E6%8A%80%E6%9C%AF/">技术</a></div><div class="post-header"><span class="ui-tips">标签：</span> <a href="/tags/XBMC/">XBMC</a> <a href="/tags/Kodi/">Kodi</a> <a href="/tags/%E9%81%A5%E6%8E%A7%E5%99%A8/">遥控器</a></div><div class="post-content"><p><strong>通过运行在 Android 手机上的自制遥控器来控制你的家庭媒体播放器。</strong></p><p><strong>Kodi</strong> 是一款很优秀的软件，能够将几乎所有电脑变身成媒体中心。它可以播放音乐和视频，显示图片，甚至还能显示天气预报。为了在配置成家庭影院后方便使用，你可以通过手机 app 访问运行在连接到 Wi-Fi 的 XBMC 机器上的服务来控制它。可以找到很多这种工具，几乎覆盖所有智能手机系统。</p><p><img src="https://linuxcn.img.undefined.today/data/attachment/album/201507/24/091201qhyjxk777tqyxkuy.jpg"></p><blockquote><p><strong>XBMC</strong></p><p>Kodi 原名叫做 XBMC，在你阅读这篇文章的时候，<strong>XBMC</strong> 已经成为历史。因为法律原因（因为名字 <strong>XBMC</strong> 或 X**-Box Media Center** 里引用了不再支持的过时硬件）项目组决定使用新的名字 <strong>Kodi</strong>。不过，除了名字，其他的都会保持原样。或者说除开通常新版本中所期待的大量新改进。这一般不会影响到遥控软件，它应该能在已有的 <strong>XBMC</strong> 系统和新的 Kodi 系统上都能工作。</p></blockquote><p>我们目前已经配置好了一个用于播放音乐的 <strong>Kodi</strong> 系统，不过我们找到的所有 Kodi 遥控没一个好用的，特别是和媒体中心连接的电视没打开的时候。它们都有点太复杂了，集成了太多功能在手机的小屏幕上。我们希望能有这样的系统，从最开始就是设计成只用于访问音乐库和电台插件，所以我们决定自己实现一个。它不需要用到 Kodi 的所有功能，因为除了音乐以外的任务，我们可以简单地切换使用通用的 Kodi 遥控。我们的测试系统是一个刷了 RaspBMC 发行版的树莓派，但是我们要做的工具并不受限于树莓派或Kodi那个发行版，它应该可以匹配任何安装了相关插件的基于 Linux 的 Kodi 系统。</p><p>首先，遥控程序需要一个用户界面。大多数 Kodi 遥控程序都是独立的 app。不过对于我们要做的这个音乐控制程序，我们希望用户可以不用安装任何东西就可以使用。显然我们需要使用网页界面。Kodi 本身自带网页服务器，但是为了获得更多权限，我们还是使用了独立的网页框架。在同一台电脑上跑两个以上网页服务器没有问题，只不过它们不能使用相同的端口。</p><p>有几个网页框架可以使用。而我们选用 Bottle 是因为它是一个简单高效的框架，而且我们也确实用不到任何高级功能。Bottle 是一个 Python 模块，所以这也将是我们编写服务器模块的语言。</p><p>你应该能在软件包管理器里找到 Bottle。在基于 Debian 的系统（包括 RaspBMC）里，你可以通过下面的命令安装：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install python-bottle</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>遥控程序实际上只是连接用户和系统的中间层。Bottle 提供了和用户交互的方式，而我们将通过 JSON API 来和 <strong>Kodi</strong> 交互。这样可以让我们通过发送 JSON 格式消息的方式去控制媒体播放器。</p><p>我们将用到一个叫做 xbmcjson 的简单 XBMC JASON API 封装。足够用来发送控制请求，而不需要关心实际的 JSON 格式以及和服务器通讯的无聊事。它没有包含在 PIP 包管理中，所以你得直接从 <strong>GitHub</strong> 安装：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/jcsaaddupuy/python-xbmc.git</span><br><span class="line">cd python-xbmc</span><br><span class="line">sudo python setup.py install</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>万事俱备，只欠代码。</p><h4 id="先从-Bottle-开始"><a href="#先从-Bottle-开始" class="headerlink" title="先从 Bottle 开始"></a>先从 Bottle 开始</h4><p>我们程序的基本结构：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">from xbmcjson import XBMC</span><br><span class="line">from bottle import route, run, template, redirect, static_file, request</span><br><span class="line">import os</span><br><span class="line">xbmc = XBMC(&quot;http://192.168.0.5/jsonrpc&quot;, &quot;xbmc&quot;, &quot;xbmc&quot;)</span><br><span class="line">@route(&#x27;/hello/&lt;name&gt;&#x27;)</span><br><span class="line">def index(name):</span><br><span class="line">return template(&#x27;&lt;h1&gt;Hello &#123;&#123;name&#125;&#125;!&lt;/h1&gt;&#x27;, name=name)</span><br><span class="line">run(host=&quot;0.0.0.0&quot;, port=8000)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这样程序将连接到 <strong>Kodi</strong>（不过实际上用不到）；然后 Bottle 会开始提供网站服务。在我们的代码里，它将监听主机 0.0.0.0（意味着允许所有主机连接）的端口 8000。它只设定了一个站点，就是 &#x2F;hello&#x2F;XXXX，这里的 XXXX 可以是任何内容。不管 XXXX 是什么都将作为参数名传递给 index()。然后再替换进去 HTML 网页模版。</p><p>你可以先试着把上面内容写到一个文件（我们取的名字是 remote.py），然后用下面的命令启动：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">python remote.py</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后你可以在浏览器里访问 localhost:8000&#x2F;hello&#x2F;world 看看模版生效的效果。</p><p>@route() 用来设定网页服务器的路径，而函数 index() 会返回该路径的数据。通常是返回由模版生成的 HTML 页面，但是并不是说只能这样（后面会看到）。</p><p>随后，我们将给应用添加更多页面入口，让它变成一个全功能的 Kodi 遥控，但仍将采用相同代码结构。</p><p>XBMC JSON API 接口可以从和 Kodi 机器同网段的任意电脑上访问。也就是说你可以在自己的笔记本上开发，然后再布置到媒体中心上，而不需要浪费时间上传每次改动。</p><p>模版 - 比如前面例子里的那个简单模版 - 是一种结合 Python 和 HTML 来控制输出的方式。理论上，这俩能做很多很多事，但是会非常混乱。我们将只是用它们来生成正确格式的数据。不过，在开始动手之前，我们先得准备点数据。</p><blockquote><p><strong>Paste</strong></p><p>Bottle 自带网页服务器，我们用它来测试遥控程序。不过，我们发现它性能有时不够好。当我们的遥控程序正式上线时，我们希望页面能更快一点显示出来。Bottle 可以和很多不同的网页服务器配合工作，而我们发现 Paste 用起来非常不错。而要使用的话，只要简单地安装（Debian 系统里的 python-paste 包），然后修改一下代码里的 run 调用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">run(host=hostname, port=hostport, server=&quot;paste&quot;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>你可以在 <a target="_blank" rel="noopener" href="http://bottlepy.org/docs/dev/deployment.html">http://bottlepy.org/docs/dev/deployment.html</a> 找到如何使用其他服务器的相关细节。</p></blockquote><h4 id="从-Kodi-获取数据"><a href="#从-Kodi-获取数据" class="headerlink" title="从 Kodi 获取数据"></a>从 Kodi 获取数据</h4><p>XBMC JSON API 分成 14 个命名空间：JSONRPC, Player, Playlist, Files, AudioLibrary, VideoLibrary, Input, Application, System, Favourites, Profiles, Settings, Textures 和 XBMC。每个都可以通过 Python 的 XBMC 对象访问（Favourites 除外，明显是个疏忽）。每个命名空间都包含许多方法用于对程序的控制。例如，Playlist.GetItems() 可以用来获取某个特定播放列表的内容。服务器会返回给我们 JSON 格式的数据，但 xbmcjson 模块会为我们转化成 Python 词典。</p><p>我们需要用到 Kodi 里的两个组件来控制播放：播放器和播放列表。播放器处理播放列表并在每首歌结束时从列表里取下一首。为了查看当前正在播放的内容，我们需要获取正在工作的播放器的 ID，然后根据它找到当前播放列表的 ID。这个可以通过下面的代码来实现：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">def get_playlistid():</span><br><span class="line">player = xbmc.Player.GetActivePlayers()</span><br><span class="line">if len(player[&#x27;result&#x27;]) &gt; 0:</span><br><span class="line">playlist_data = xbmc.Player.GetProperties(&#123;&quot;playerid&quot;:0, &quot;properties&quot;:[&quot;playlistid&quot;]&#125;)</span><br><span class="line">if len(playlist_data[&#x27;result&#x27;]) &gt; 0 and &quot;playlistid&quot; in playlist_data[&#x27;result&#x27;].keys():</span><br><span class="line">return playlist_data[&#x27;result&#x27;][&#x27;playlistid&#x27;]</span><br><span class="line">return -1</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如果当前没有播放器在工作（就是说，返回数据的结果部分的长度是 0），或者当前播放器没有处理播放列表，这样的话函数会返回 -1。其他时候，它会返回当前播放列表的数字 ID。</p><p>当我们拿到当前播放列表的 ID 后，就可以获取该列表的细节内容。按照我们的需求，有两个重要的地方：播放列表里包含的项，以及当前播放所处的位置（已经播放过的项并不会从播放列表移除，只是移动当前播放位置）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">def get_playlist():</span><br><span class="line">playlistid = get_playlistid()</span><br><span class="line">if playlistid &gt;= 0:</span><br><span class="line">data = xbmc.Playlist.GetItems(&#123;&quot;playlistid&quot;:playlistid, &quot;properties&quot;: [&quot;title&quot;, &quot;album&quot;, &quot;artist&quot;, &quot;file&quot;]&#125;)</span><br><span class="line">position_data = xbmc.Player.GetProperties(&#123;&quot;playerid&quot;:0, &#x27;properties&#x27;:[&quot;position&quot;]&#125;)</span><br><span class="line">position = int(position_data[&#x27;result&#x27;][&#x27;position&#x27;])</span><br><span class="line">return data[&#x27;result&#x27;][&#x27;items&#x27;][position:], position</span><br><span class="line">return [], -1</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这样可以返回正在播放的项开始的列表（因为我们并不关心已经播放过的内容），而且也包含了用来从列表里移除项的位置信息。</p><p><img src="https://linuxcn.img.undefined.today/data/attachment/album/201507/24/091205velijznihkq6ahhk.jpg" alt="Image"></p><p>API 文档在这里：<a target="_blank" rel="noopener" href="http://wiki.xbmc.org/?title=JSON-RPC_API/v6">http://wiki.xbmc.org/?title=JSON-RPC_API/v6</a>。它列出了所有支持的函数，但是关于具体如何使用的描述有点太简单了。</p><blockquote><p><strong>JSON</strong></p><p>JSON 是 JavaScript Object Notation 的缩写，最初设计用于 JavaScript 对象的序列化。目前仍然起到这个作用，但是它也是用来编码任意数据的一种很好用的方式。</p><p>JSON 对象都是这样的格式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;property1:value1, property2:value2, property3:value3&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>支持任意数目的属性&#x2F;值配对。对 Python 程序员来说，看上去和字典数据结构很相似，不过这两个确实很像。</p><p>在字典数据结构里，值本身可以是另一个 JSON 对象，或者一个列表，所以下面的格式也是正确的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;name&quot;:&quot;Ben&quot;, &quot;jobs&quot;:[&quot;cook&quot;, &quot;bottle-washer&quot;], &quot;appearance&quot;: &#123;&quot;height&quot;:195, &quot;skin&quot;:&quot;fair&quot;&#125;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>JSON 通常在网络服务中用来发送和接收数据，并且大多数编程语言都能很好地支持，所以如果你熟悉 Python 的话，你应该可以使用你熟悉的编程语言调用相同的接口来轻松地控制 Kodi。</p></blockquote><h4 id="整合到一起"><a href="#整合到一起" class="headerlink" title="整合到一起"></a>整合到一起</h4><p>把之前的功能连接到 HTML 页面很简单：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@route(&#x27;/juke&#x27;)</span><br><span class="line">def index():</span><br><span class="line">current_playlist, position = get_playlist()</span><br><span class="line">return template(&#x27;list&#x27;, playlist=current_playlist, offset = position)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>只需要抓取播放列表（调用我们之前定义的函数），然后将结果传递给负责显示的模版。</p><p>负责显示列表数据的模版的主要部分是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;h2&gt;Currently Playing:&lt;/h2&gt;</span><br><span class="line">% if playlist is not None:</span><br><span class="line">% position = offset</span><br><span class="line">% for song in playlist:</span><br><span class="line">&lt;strong&gt; &#123;&#123;song[&#x27;title&#x27;]&#125;&#125; &lt;/strong&gt;</span><br><span class="line">% if song[&#x27;type&#x27;] == &#x27;unknown&#x27;:</span><br><span class="line">Radio</span><br><span class="line">% else:</span><br><span class="line">&#123;&#123;song[&#x27;artist&#x27;][0]&#125;&#125;</span><br><span class="line">% end</span><br><span class="line">% if position != offset:</span><br><span class="line">&lt;a href=&quot;/remove/&#123;&#123;position&#125;&#125;&quot;&gt;remove&lt;/a&gt;</span><br><span class="line">% else:</span><br><span class="line">&lt;a href=&quot;/skip/&#123;&#123;position&#125;&#125;&quot;&gt;skip&lt;/a&gt;</span><br><span class="line">% end</span><br><span class="line">&lt;br&gt;</span><br><span class="line">% position += 1</span><br><span class="line">% end</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以看到，模版大部分是用 HTML 写的，只有一小部分用来控制输出的其他代码。用两个大括号括起来的变量是输出位置（像我们在第一个 ‘hello world’ 例子里看到的）。你也可以嵌入以百分号开头的 Python 代码。因为没有缩进，你需要用一个 <code>% end</code> 来结束当前的代码块（就像循环或 if 语句）。</p><p>这个模版首先检查列表是否为空，然后遍历里面的每一项。每一项会用粗体显示歌曲名字，然后是艺术家名字，然后是一个是否跳过（如果是当前正在播的歌曲）或从列表移除的链接。所有歌曲的类型都是 ‘song’，如果类型是 ‘unknown’，那就不是歌曲而是网络电台。</p><p>&#x2F;remove&#x2F; 和 &#x2F;skip&#x2F; 路径只是简单地封装了 XBMC 控制功能，在改动生效后重新加载 &#x2F;juke：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@route(&#x27;/skip/&lt;position&gt;&#x27;)</span><br><span class="line">def index(position):</span><br><span class="line">print xbmc.Player.GoTo(&#123;&#x27;playerid&#x27;:0, &#x27;to&#x27;:&#x27;next&#x27;&#125;)</span><br><span class="line">redirect(&quot;/juke&quot;)</span><br><span class="line">@route(&#x27;/remove/&lt;position&gt;&#x27;)</span><br><span class="line">def index(position):</span><br><span class="line">playlistid = get_playlistid()</span><br><span class="line">if playlistid &gt;= 0:</span><br><span class="line">xbmc.Playlist.Remove(&#123;&#x27;playlistid&#x27;:int(playlistid), &#x27;position&#x27;:int(position)&#125;)</span><br><span class="line">redirect(&quot;/juke&quot;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>当然，如果不能往列表里添加歌曲的话那这个列表管理功能也不行。</p><p>因为一旦播放列表结束，它就消失了，所以你需要重新创建一个，这会让事情复杂一些。而且有点让人迷惑的是，播放列表是通过调用 Playlist.Clear() 方法来创建的。这个方法也还用来删除包含网络电台（类型是 unknown）的播放列表。另一个麻烦的地方是列表里的网络电台开始播放后就不会停，所以如果当前在播网络电台，也会需要清除播放列表。</p><p>这些页面包含了指向 &#x2F;play&#x2F;<songid>的链接来播放歌曲。通过下面的代码处理：</songid></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@route(&#x27;/play/&lt;id&gt;&#x27;)</span><br><span class="line">def index(id):</span><br><span class="line">playlistid = get_playlistid()</span><br><span class="line">playlist, not_needed= get_playlist()</span><br><span class="line">if playlistid &lt; 0 or playlist[0][&#x27;type&#x27;] == &#x27;unknown&#x27;:</span><br><span class="line">xbmc.Playlist.Clear(&#123;&quot;playlistid&quot;:0&#125;)</span><br><span class="line">xbmc.Playlist.Add(&#123;&quot;playlistid&quot;:0, &quot;item&quot;:&#123;&quot;songid&quot;:int(id)&#125;&#125;)</span><br><span class="line">xbmc.Player.open(&#123;&quot;item&quot;:&#123;&quot;playlistid&quot;:0&#125;&#125;)</span><br><span class="line">playlistid = 0</span><br><span class="line">else:</span><br><span class="line">xbmc.Playlist.Add(&#123;&quot;playlistid&quot;:playlistid, &quot;item&quot;:&#123;&quot;songid&quot;:int(id)&#125;&#125;)</span><br><span class="line">remove_duplicates(playlistid)</span><br><span class="line">redirect(&quot;/juke&quot;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>最后一件事情是实现 remove_duplicates 调用。这并不是必须的 - 而且还有人并不喜欢这个 - 不过可以保证同一首歌不会多次出现在播放列表里。</p><p>我们也实现了一些页面用来列出收藏歌曲里所有艺术家，以及列出指定艺术家的歌曲和专辑。这些都非常简单，和 &#x2F;juke 页面基本类似。</p><p><img src="https://linuxcn.img.undefined.today/data/attachment/album/201507/24/091207fffjck6hj46w3iry.jpg" alt="Image"></p><p>还需要处理一下 UI，不过功能已经有了。</p><blockquote><p><strong>日志</strong></p><p>通常拿到 XBMC JSON API 并不清楚能用来做什么，而且它的文档也有点模糊。找出如何使用的一种方式是看别的遥控程序是怎么做的。如果打开日志功能，就可以在使用其他遥控程序的时候看到哪个 API 被调用了，然后就可以应用到在自己的代码里。</p><p>要打开日志功能，把 Kodi 媒体中心 接到显示器上，再依次进入设置 &gt; 系统 &gt; 调试，打开允许调试日志。在打开日志功能后，还需要登录到 Kodi 机器上（比如通过 SSH），然后就可以查看日志了。日志文件的位置应该显示在 Kodi 界面左上角。在 RaspBMC 系统里，文件位置是 &#x2F;home&#x2F;pi&#x2F;.xbmc&#x2F;temp&#x2F;xbmc.log。你可以通过下面的命令实时监视哪个 API 接口被调用了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd /home/pi/.xbmc/temp</span><br><span class="line">tail -f xbmc.log | grep &quot;JSON&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure></blockquote><h4 id="增加功能"><a href="#增加功能" class="headerlink" title="增加功能"></a>增加功能</h4><p>上面的代码都是用来播放 Kodi 媒体库里的歌曲的，但我们还希望能播放网络电台。每个插件都有自己的独立 URL 可以通过普通的 XBMC JSON 命令来获取信息。举个例子，要从电台插件里获取选中的电台，可以使用；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@route(&#x27;/radio/&#x27;)</span><br><span class="line">def index():</span><br><span class="line">my_stations = xbmc.Files.GetDirectory(&#123;&quot;directory&quot;:&quot;plugin://plugin.audio.radio_de/stations/my/&quot;, &quot;properties&quot;:</span><br><span class="line">[&quot;title&quot;,&quot;thumbnail&quot;,&quot;playcount&quot;,&quot;artist&quot;,&quot;album&quot;,&quot;episode&quot;,&quot;season&quot;,&quot;showtitle&quot;]&#125;)</span><br><span class="line">if &#x27;result&#x27; in my_stations.keys():</span><br><span class="line">return template(&#x27;radio&#x27;, stations=my_stations[&#x27;result&#x27;][&#x27;files&#x27;])</span><br><span class="line">else:</span><br><span class="line">return template(&#x27;error&#x27;, error=&#x27;radio&#x27;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这样可以返回一个可以和歌曲一样能添加到播放列表的文件。不过，这些文件能一直播下去，所以（之前说过）在添加其他歌曲的时候需要重新创建列表。</p><h4 id="共享歌曲"><a href="#共享歌曲" class="headerlink" title="共享歌曲"></a>共享歌曲</h4><p>除了伺服页面模版，Bottle 还支持静态文件，方便用于那些不会因为用户输入而改变的内容。可以是 CSS 文件，一张图片或是一首 MP3 歌曲。在我们的简单遥控程序里（目前）还没有任何用来美化的 CSS 或图片，不过我们增加了一个下载歌曲的途径。这个可以让媒体中心变成一个存放歌曲的 NAS 盒子。在需要传输大量数据的时候，最好还是用类似 Samba 的功能，但只是下几首歌到手机上的话使用静态文件也是很好的方式。</p><p>通过歌曲 ID 来下载的 Bottle 代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@route(&#x27;/download/&lt;id&gt;&#x27;)</span><br><span class="line">def index(id):</span><br><span class="line">data = xbmc.AudioLibrary.GetSongDetails(&#123;&quot;songid&quot;:int(id), &quot;properties&quot;:[&quot;file&quot;]&#125;)</span><br><span class="line">full_filename = data[&#x27;result&#x27;][&#x27;songdetails&#x27;][&#x27;file&#x27;]</span><br><span class="line">path, filename = os.path.split(full_filename)</span><br><span class="line">return static_file(filename, root=path, download=True)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>应用的时候，只需要为 &#x2F;songsby&#x2F; 页面里的相应 ID 加个链接。</p><p>我们已经把所有的代码过了一遍，不过还需要一点工作来把它们集合到一起。可以自己去 GitHub 页面 <a target="_blank" rel="noopener" href="https://github.com/ben-ev/xbmc-remote">https://github.com/ben-ev/xbmc-remote</a> 看下。</p><blockquote><p><strong>设置</strong><br>我们的遥控程序已经开发完成，还需要保证让它在媒体中心每次开机的时候都能启动。有几种方式，最简单的是在 &#x2F;etc&#x2F;rc.local 里增加一行命令来启动。我们的文件位置在 &#x2F;opt&#x2F;xbmc-remote&#x2F;remote.py，其他文件也和它一起。然后在 &#x2F;etc&#x2F;rc.local 最后的 exit 0 之前增加了下面一行。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /opt/xbmc-remote &amp;&amp; python remote.py &amp;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>GitHub</strong><br>这个项目目前还只是个架子，但是 - 我们运营杂志就意味着没有太多自由时间来编程。不过，我们启动了一个 GitHub 项目，希望能持续完善， 而如果你觉得这个项目有用的话，欢迎做出贡献。</p><p>要查看最新的进展，请访问 <a target="_blank" rel="noopener" href="https://github.com/ben-ev/xbmc-remote">https://github.com/ben-ev/xbmc-remote</a> 看看所处的状态。你可以从页面里获取最新的代码，或者通过命令行复制。</p><p>如果你希望改善它，可以复制项目到你自己的分支开发，然后在功能完成后发起合并请求。关于如何使用 GitHub 的更多信息，请访问 <a target="_blank" rel="noopener" href="https://github.com/features">https://github.com/features</a>。</p></blockquote><hr><p>via: <a target="_blank" rel="noopener" href="http://www.linuxvoice.com/xbmc-build-a-remote-control/">http://www.linuxvoice.com/xbmc-build-a-remote-control/</a></p><p>作者：<a target="_blank" rel="noopener" href="http://www.linuxvoice.com/author/ben_everard/">Ben Everard</a> 译者：<a target="_blank" rel="noopener" href="https://github.com/zpl1025">zpl1025</a> 校对：<a target="_blank" rel="noopener" href="https://github.com/wxy">wxy</a></p><p>本文由 <a target="_blank" rel="noopener" href="https://github.com/LCTT/TranslateProject">LCTT</a> 原创翻译，<a target="_blank" rel="noopener" href="https://linux.cn/">Linux中国</a> 荣誉推出</p></div></div></div><div class="footer"><p class="footer-copyright"><span>Powered by <a target="_blank" href="https://hexo.io">Hexo</a></span> <span>Theme <a target="_blank" href="https://github.com/tinkink-co/hexo-theme-terminal">Terminal</a></span><script type="text/javascript" src="https://cdn.staticfile.net/jquery/3.4.1/jquery.min.js"></script><script>getCDNinfo=function(){$.ajax({url:"/cdn-cgi/trace",success:function(a,n){let i="Antananarivo, Madagascar - (TNR);Cape Town, South Africa - (CPT);Casablanca, Morocco - (CMN);Dar Es Salaam, Tanzania - (DAR);Djibouti City, Djibouti - (JIB);Durban, South Africa - (DUR);Johannesburg, South Africa - (JNB);Kigali, Rwanda - (KGL);Lagos, Nigeria - (LOS);Luanda, Angola - (LAD);Maputo, MZ - (MPM);Mombasa, Kenya - (MBA);Port Louis, Mauritius - (MRU);Réunion, France - (RUN);Bangalore, India - (BLR);Bangkok, Thailand - (BKK);Bandar Seri Begawan, Brunei - (BWN);Cebu, Philippines - (CEB);Chengdu, China - (CTU);Chennai, India - (MAA);Chittagong, Bangladesh - (CGP);Chongqing, China - (CKG);Colombo, Sri Lanka - (CMB);Dhaka, Bangladesh - (DAC);Dongguan, China - (SZX);Foshan, China - (FUO);Fuzhou, China - (FOC);Guangzhou, China - (CAN);Hangzhou, China - (HGH);Hanoi, Vietnam - (HAN);Hengyang, China - (HNY);Ho Chi Minh City, Vietnam - (SGN);Hong Kong - (HKG);Hyderabad, India - (HYD);Islamabad, Pakistan - (ISB);Jakarta, Indonesia - (CGK);Jinan, China - (TNA);Karachi, Pakistan - (KHI);Kathmandu, Nepal - (KTM);Kolkata, India - (CCU);Kuala Lumpur, Malaysia - (KUL);Lahore, Pakistan - (LHE);Langfang, China - (NAY);Luoyang, China - (LYA);Macau - (MFM);Malé, Maldives - (MLE);Manila, Philippines - (MNL);Mumbai, India - (BOM);Nagpur, India - (NAG);Nanning, China - (NNG);New Delhi, India - (DEL);Osaka, Japan - (KIX);Phnom Penh, Cambodia - (PNH);Qingdao, China - (TAO);Seoul, South Korea - (ICN);Shanghai, China - (SHA);Shenyang, China - (SHE);Shijiazhuang, China - (SJW);Singapore, Singapore - (SIN);Suzhou, China - (SZV);Taipei - (TPE);Thimphu, Bhutan - (PBH);Tianjin, China - (TSN);Tokyo, Japan - (NRT);Ulaanbaatar, Mongolia - (ULN);Vientiane, Laos - (VTE);Wuhan, China - (WUH);Wuxi, China - (WUX);Xi'an, China - (XIY);Yerevan, Armenia - (EVN);Zhengzhou, China - (CGO);Zuzhou, China - (CSX);Amsterdam, Netherlands - (AMS);Athens, Greece - (ATH);Barcelona, Spain - (BCN);Belgrade, Serbia - (BEG);Berlin, Germany - (TXL);Brussels, Belgium - (BRU);Bucharest, Romania - (OTP);Budapest, Hungary - (BUD);Chișinău, Moldova - (KIV);Copenhagen, Denmark - (CPH);Cork, Ireland -  (ORK);Dublin, Ireland - (DUB);Düsseldorf, Germany - (DUS);Edinburgh, United Kingdom - (EDI);Frankfurt, Germany - (FRA);Geneva, Switzerland - (GVA);Gothenburg, Sweden - (GOT);Hamburg, Germany - (HAM);Helsinki, Finland - (HEL);Istanbul, Turkey - (IST);Kyiv, Ukraine - (KBP);Lisbon, Portugal - (LIS);London, United Kingdom - (LHR);Luxembourg City, Luxembourg - (LUX);Madrid, Spain - (MAD);Manchester, United Kingdom - (MAN);Marseille, France - (MRS);Milan, Italy - (MXP);Moscow, Russia - (DME);Munich, Germany - (MUC);Nicosia, Cyprus - (LCA);Oslo, Norway - (OSL);Paris, France - (CDG);Prague, Czech Republic - (PRG);Reykjavík, Iceland - (KEF);Riga, Latvia - (RIX);Rome, Italy - (FCO);Saint Petersburg, Russia - (LED);Sofia, Bulgaria - (SOF);Stockholm, Sweden - (ARN);Tallinn, Estonia - (TLL);Thessaloniki, Greece - (SKG);Vienna, Austria - (VIE);Vilnius, Lithuania - (VNO);Warsaw, Poland - (WAW);Zagreb, Croatia - (ZAG);Zürich, Switzerland - (ZRH);Arica, Chile - (ARI);Asunción, Paraguay - (ASU);Bogotá, Colombia - (BOG);Buenos Aires, Argentina - (EZE);Curitiba, Brazil - (CWB);Fortaleza, Brazil - (FOR);Guatemala City, Guatemala - (GUA);Lima, Peru - (LIM);Medellín, Colombia - (MDE);Panama City, Panama - (PTY);Porto Alegre, Brazil - (POA);Quito, Ecuador - (UIO);Rio de Janeiro, Brazil - (GIG);São Paulo, Brazil - (GRU);Santiago, Chile - (SCL);Willemstad, Curaçao - (CUR);St. George's, Grenada - (GND);Amman, Jordan - (AMM);Baghdad, Iraq - (BGW);Baku, Azerbaijan - (GYD);Beirut, Lebanon - (BEY);Doha, Qatar - (DOH);Dubai, United Arab Emirates - (DXB);Kuwait City, Kuwait - (KWI);Manama, Bahrain - (BAH);Muscat, Oman - (MCT);Ramallah - (ZDM);Riyadh, Saudi Arabia - (RUH);Tel Aviv, Israel - (TLV);Ashburn, VA, United States - (IAD);Atlanta, GA, United States - (ATL);Boston, MA, United States - (BOS);Buffalo, NY, United States - (BUF);Calgary, AB, Canada - (YYC);Charlotte, NC, United States - (CLT);Chicago, IL, United States - (ORD);Columbus, OH, United States - (CMH);Dallas, TX, United States - (DFW);Denver, CO, United States - (DEN);Detroit, MI, United States - (DTW);Honolulu, HI, United States - (HNL);Houston, TX, United States - (IAH);Indianapolis, IN, United States - (IND);Jacksonville, FL, United States - (JAX);Kansas City, MO, United States - (MCI);Las Vegas, NV, United States - (LAS);Los Angeles, CA, United States - (LAX);McAllen, TX, United States - (MFE);Memphis, TN, United States - (MEM);Mexico City, Mexico - (MEX);Miami, FL, United States - (MIA);Minneapolis, MN, United States - (MSP);Montgomery, AL, United States - (MGM);Montréal, QC, Canada - (YUL);Nashville, TN, United States - (BNA);Newark, NJ, United States - (EWR);Norfolk, VA, United States - (ORF);Omaha, NE, United States - (OMA);Philadelphia, United States - (PHL);Phoenix, AZ, United States - (PHX);Pittsburgh, PA, United States - (PIT);Port-Au-Prince, Haiti - (PAP);Portland, OR, United States - (PDX);Queretaro, MX, Mexico - (QRO);Richmond, Virginia - (RIC);Sacramento, CA, United States - (SMF);Salt Lake City, UT, United States - (SLC);San Diego, CA, United States - (SAN);San Jose, CA, United States - (SJC);Saskatoon, SK, Canada - (YXE);Seattle, WA, United States - (SEA);St. Louis, MO, United States - (STL);Tampa, FL, United States - (TPA);Toronto, ON, Canada - (YYZ);Vancouver, BC, Canada - (YVR);Tallahassee, FL, United States - (TLH);Winnipeg, MB, Canada - (YWG);Adelaide, SA, Australia - (ADL);Auckland, New Zealand - (AKL);Brisbane, QLD, Australia - (BNE);Melbourne, VIC, Australia - (MEL);Noumea, New caledonia - (NOU);Perth, WA, Australia - (PER);Sydney, NSW, Australia - (SYD)".split(";"),e=a.split("colo=")[1].split("\n")[0],t=(a.split("colo=")[1].split("\n")[0],a.split("tls=")[1].split("\n")[0]),o=a.split("http=")[1].split("\n")[0],s=a.split("sni=")[1].split("\n")[0],r=a.split("ip=")[1].split("\n")[0],l=a.split("uag=")[1].split("\n")[0];for(var d=0;d<i.length;d++)if(-1!=i[d].indexOf(e)){document.getElementById("cdn").innerHTML=i[d];break}document.getElementById("tls").innerHTML=t,document.getElementById("http").innerHTML=o,document.getElementById("sni").innerHTML=s,document.getElementById("ip").innerHTML=r,document.getElementById("useragent").innerHTML=l}})},$(document).ready((function(){getCDNinfo()}))</script></p><p style="text-align:center">感谢陪伴与布道，开源之火不灭。​</p><p style="text-align:center"><script>document.write("本次加载耗时: "+(performance.getEntriesByType("navigation").reduce((e,r)=>e+r.responseEnd-r.startTime,0)+performance.getEntriesByType("resource").reduce((e,r)=>e+r.responseEnd-r.startTime,0)).toFixed(0)+"ms")</script></p><p style="text-align:center">当前 SNI 状态： <span id="sni">正在统计！或可能被浏览器防追踪拦截！</span></p><p style="text-align:center">当前 TLS 版本： <span id="tls">正在统计！或可能被浏览器防追踪拦截！</span></p><p style="text-align:center">当前 HTTP 版本： <span id="http">正在统计！或可能被浏览器防追踪拦截！</span></p><p style="text-align:center">当前您的客户端 IP 是： <span id="ip">正在统计！或可能被浏览器防追踪拦截！</span></p><p style="text-align:center">当前分配的 CDN 节点是: <span id="cdn">正在统计！或可能被浏览器防追踪拦截！</span></p><p style="text-align:center">您的 UserAgent 信息是: <span id="useragent">正在统计！或可能被浏览器防追踪拦截！</span></p><p></p></div></div></body></html>