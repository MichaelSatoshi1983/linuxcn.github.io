<!doctype html><html lang="en"><head><meta name="msvalidate.01" content="D404690CEFCB54C7762AC84935B99171"><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?6618da70c90c8744eead2e9371fb5077";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><script type="text/javascript">!function(t,e,n,c,s,a,r){t[n]=t[n]||function(){(t[n].q=t[n].q||[]).push(arguments)},(a=e.createElement(c)).async=1,a.src="https://www.clarity.ms/tag/s5f3f0tojf",(r=e.getElementsByTagName(c)[0]).parentNode.insertBefore(a,r)}(window,document,"clarity","script")</script><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta http-equiv="X-UA-Compatible" content="ie=edge"><link rel="stylesheet" href="/styles/base.css"><link rel="stylesheet" href="/styles/theme.css"><link rel="shortcut icon" href="/favicon.png"><title>命令行艺术 - 归墟星火集 又一个 LinuxCN 站点</title><meta name="generator" content="Hexo 7.3.0"></head><body><div class="header-title"><span class="header-light"></span> <span class="header-light"></span> <span class="header-light"></span> <span>归墟星火集 又一个 LinuxCN 站点 linuxcn.undefined.today<span></span></span></div><div class="container"><ul class="nav"><li><a href="/">首页</a></li><li><a target="_blank" rel="noopener" href="https://undefined.today/">Blog</a></li></ul><div class="content"><div class="post-container"><div class="post-header"><span class="ui-tips">标题：</span><h1 class="ui-keyword post-title">命令行艺术</h1><span class="post-date">2015-06-29</span></div><div class="post-header"><span class="ui-tips">分类：</span> <a href="/categories/%E6%8A%80%E6%9C%AF/">技术</a></div><div class="post-header"><span class="ui-tips">标签：</span> <a href="/tags/%E5%91%BD%E4%BB%A4%E8%A1%8C/">命令行</a></div><div class="post-content"><p>![curl -s ‘<a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/jlevy/the-art-of-command-line/master/README.md">https://raw.githubusercontent.com/jlevy/the-art-of-command-line/master/README.md</a>‘ | egrep -o ‘<code>\w+</code>‘ | tr -d ‘&#96;’ | cowsay -W50](<a target="_blank" rel="noopener" href="https://linuxcn.img.undefined.today/data/attachment/album/201506/27/151622zjf2gg5cgpso2kcv.png">https://linuxcn.img.undefined.today/data/attachment/album/201506/27/151622zjf2gg5cgpso2kcv.png</a>)</p><p>流畅地使用命令行是一个常被忽略的技能，或被认为是神秘的奥义。但是，它会以明显而微妙的方式改善你作为工程师的灵活度和生产力。这是我在 Linux 上工作时发现的有用的命令行使用小窍门和笔记的精粹。有些小窍门是很基础的，而有些是相当地特别、复杂、或者晦涩难懂。这篇文章不长，但是如果你可以使用并记得这里的所有内容，那么你就懂得很多了。</p><p>其中大部分<a target="_blank" rel="noopener" href="http://www.quora.com/What-are-some-lesser-known-but-useful-Unix-commands">最初</a><a target="_blank" rel="noopener" href="http://www.quora.com/What-are-the-most-useful-Swiss-army-knife-one-liners-on-Unix">出现</a>在<a target="_blank" rel="noopener" href="http://www.quora.com/What-are-some-time-saving-tips-that-every-Linux-user-should-know">Quora</a>上，但是考虑到兴趣所在，似乎更应该放到 Github 上，这里的人比我更能提出改进建议。如果你看到一个错误，或者更好的某种东西，请提交问题或 PR！（当然，提交前请看看必读小节和已有的 PR&#x2F;Issue。）</p><h2 id="必读"><a href="#必读" class="headerlink" title="必读"></a>必读</h2><p>范围：</p><ul><li>本文是针对初学者和专业人员的，选题目标是覆盖面广（全都很重要）、有针对性（大多数情况下都给出具体实例）而简洁（避免不必要内容以及你能在其它地方轻松找到的离题的内容）。每个小窍门在某种情形下都很必需的，或者能比替代品大大节省时间。</li><li>这是为 Linux 写的。绝大部分条目都可以同样应用到 MacOS（或者甚至 Cygwin）。</li><li>主要针对交互式 Bash，尽管大多数小窍门也可以应用到其它 shell，以及常规 Bash 脚本。</li><li>包括了“标准的”UNIX 命令以及那些需要安装的软件包（它们很重要，值得安装）。</li></ul><p>注意：</p><ul><li>为了能在一篇文章内展示尽量多的东西，一些具体的信息会被放到引用页里。你可以使用 Google 来获得进一步的内容。（如果需要的话，）你可以使用 <code>apt-get</code>&#x2F;<code>yum</code>&#x2F;<code>dnf</code>&#x2F;<code>pacman</code>&#x2F;<code>pip</code>&#x2F;<code>brew</code> 来安装这些新的程序。</li><li>使用 <a target="_blank" rel="noopener" href="http://explainshell.com/">Explainshell</a> 来获取命令、参数、管道等内容的解释。</li></ul><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><ul><li>学习基本 Bash 技能。实际上，键入<code>man bash</code>，然后至少浏览一遍所有内容；它很容易理解，没那么长。其它 shell 也不错，但是 Bash 很强大，而且到处都可以找到（如果在你自己的笔记本上<em>只</em>学习 zsh、fish 之类，会在很多情形下受到限制，比如使用现存的服务器时）。</li><li>至少学好一种基于文本的编辑器。理想的一个是 Vim（<code>vi</code>），因为在终端中编辑时随时都能找到它（即使大多数时候你在使用 Emacs、一个大型的 IDE、或一个现代的时髦编辑器）。</li><li>学习怎样使用 <code>man</code> 来阅读文档（好奇的话，用 <code>man man</code> 来列出分区号，比如 1 是常规命令，5 是文件描述，8 用于管理员）。用 <code>apropos</code> 找到帮助页。了解哪些命令不是可执行程序，而是 Bash 内置的，你可以用 <code>help</code> 和 <code>help -d</code> 得到帮助。</li><li>学习使用 <code>&gt;</code> 和 <code>&lt;</code> 来进行输出和输入重定向，以及使用 <code>|</code> 来管道重定向，学习关于 stdout 和 stderr 的东西。</li><li>学习 <code>*</code>（也许还有 <code>?</code> 和 <code>&#123;</code>…<code>&#125;</code> ）文件通配扩展和应用，以及双引号 <code>&quot;</code> 和单引号 <code>&#39;</code> 之间的区别。（更多内容请参看下面关于变量扩展部分）。</li><li>熟悉 Bash 作业管理：<code>&amp;</code>， <strong>ctrl-z</strong>， <strong>ctrl-c</strong>， <code>jobs</code>， <code>fg</code>， <code>bg</code>， <code>kill</code> 等等。</li><li>掌握<code>ssh</code>，以及通过 <code>ssh-agent</code>，<code>ssh-add</code> 等进行无密码验证的基础技能。</li><li>基本的文件管理：<code>ls</code> 和 <code>ls -l</code>（特别是，知道<code>ls -l</code>各个列的意义），<code>less</code>， <code>head</code>， <code>tail</code> 和 <code>tail -f</code>（或者更好的<code>less +F</code>），<code>ln</code> 和 <code>ln -s</code>（知道硬链接和软链接的区别，以及硬链接相对于软链接的优势），<code>chown</code>，<code>chmod</code>，<code>du</code>（用于查看磁盘使用率的快速摘要：<code>du -sk *</code>）。文件系统管理：<code>df</code>， <code>mount</code>，<code>fdisk</code>，<code>mkfs</code>，<code>lsblk</code>。</li><li>基本的网络管理： <code>ip</code> 或 <code>ifconfig</code>，<code>dig</code>。</li><li>熟知正则表达式，以及各种使用<code>grep</code>&#x2F;<code>egrep</code>的选项。<code>-i</code>，<code>-o</code>，<code>-A</code> 和 <code>-B</code> 选项值得掌握。</li><li>学会使用 <code>apt-get</code>，<code>yum</code> ，<code>dnf</code> 或 <code>pacman</code>（这取决于你的发行版）来查找并安装软件包。确保你可以用 <code>pip</code> 来安装基于 Python 的命令行工具（下面的一些东西可以很容易地通过 <code>pip</code> 安装）。</li></ul><h2 id="日常使用"><a href="#日常使用" class="headerlink" title="日常使用"></a>日常使用</h2><ul><li>在Bash中，使用 <strong>tab</strong> 补完参数，使用 <strong>ctrl-r</strong> 来搜索命令历史。</li><li>在Bash中，使用 <strong>ctrl-w</strong> 来删除最后的单词，使用 <strong>ctrl-u</strong> 来删除整行，返回行首。使用 <strong>alt-b</strong> 和 <strong>alt-f</strong> 来逐词移动，使用 <strong>ctrl-k</strong> 来清除到行尾的内容，以及使用 <strong>ctrl-l</strong> 清屏。参见 <code>man readline</code> 来查看 Bash 中所有默认的键盘绑定，有很多。例如，<strong>alt-.</strong> 可以循环显示先前的参数，而<strong>alt-</strong> 扩展通配。（LCTT 译注：关于 Bash 下的快捷键，可以参阅： &lt;&#x2F;article-5660-1.html&gt; ）</li><li>另外，如果你喜欢 vi 风格的键盘绑定，可以使用 <code>set -o vi</code>。</li><li>要查看最近用过的命令，请使用 <code>history</code> 。 有许多缩写形式，比如 <code>!$</code>（上次的参数）和<code>!!</code>（上次的命令），虽然使用 <code>ctrl-r</code> 和 <code>alt-.</code> 更容易些。（LCTT 译注：关于历史扩展功能，可以参阅： &lt;&#x2F;article-5658-1.html&gt; ）</li><li>返回先前的工作目录： <code>cd -</code></li><li>如果你命令输入到一半，但是改变主意了，可以敲 <strong>alt-#</strong> 来添加一个 <code>#</code> 到开头，然后将该命令作为注释输入（或者使用快捷键 <strong>ctrl-a</strong>， <strong>#</strong>，<strong>enter</strong> 输入）。然后，你可以在后面通过命令历史来回到该命令。</li><li>使用 <code>xargs</code>（或 <code>parallel</code>），它很强大。注意，你可以控制每行（<code>-L</code>）执行多少个项目，以及并行执行（<code>-P</code>）。如果你不确定它是否会做正确的事情，可以首先使用 <code>xargs echo</code>。同时，使用 <code>-I&#123;&#125;</code> 也很方便。样例：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">find . -name &#x27;*.py&#x27; | xargs grep some_function</span><br><span class="line">cat hosts | xargs -I&#123;&#125; ssh root@&#123;&#125; hostname</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><code>pstree -p</code> 对于显示进程树很有帮助。</li><li>使用 <code>pgrep</code> 和 <code>pkill</code> 来按名称查找进程或给指定名称的进程发送信号（<code>-f</code> 很有帮助）。</li><li>掌握各种可以发送给进程的信号。例如，要挂起进程，可以使用 <code>kill -STOP [pid]</code>。完整的列表可以查阅 <code>man 7 signal</code>。</li><li>如果你想要一个后台进程一直保持运行，使用 <code>nohup</code> 或 <code>disown</code>。</li><li>通过 <code>netstat -lntp</code> 或 <code>ss -plat</code> 检查哪些进程在监听（用于 TCP，对 UDP 使用 <code>-u</code> 替代 <code>-t</code>）。</li><li><code>lsof</code>来查看打开的套接字和文件。</li><li>在 Bash 脚本中，使用 <code>set -x</code> 调试脚本输出。尽可能使用严格模式。使用 <code>set -e</code> 在遇到错误时退出。也可以使用 <code>set -o pipefail</code>，对错误进行严格处理（虽然该话题有点微妙）。对于更复杂的脚本，也可以使用 <code>trap</code>。</li><li>在 Bash 脚本中，子 shell（写在括号中的）是组合命令的便利的方式。一个常见的例子是临时移动到一个不同的工作目录，如：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 在当前目录做些事</span><br><span class="line">(cd /some/other/dir; other-command)</span><br><span class="line"># 继续回到原目录</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>注意，在 Bash 中有大量的各种各样的变量扩展。检查一个变量是否存在：<code>$&#123;name:?error message&#125;</code>。例如，如果一个Bash脚本要求一个单一参数，只需写 <code>input_file=$&#123;1:?usage: $0 input_file&#125;</code>。算术扩展：<code>i=$(( (i + 1) % 5 ))</code>。序列： <code>&#123;1..10&#125;</code>。修剪字符串：<code>$&#123;var%suffix&#125;</code> 和 <code>$&#123;var#prefix&#125;</code>。例如，if <code>var=foo.pdf</code> ，那么 <code>echo $&#123;var%.pdf&#125;.txt</code> 会输出 <code>foo.txt</code>。</li><li>命令的输出可以通过 <code>&lt;(some command)</code> 作为一个文件来处理。例如，将本地的 <code>/etc/hosts</code> 和远程的比较：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">diff /etc/hosts &lt;(ssh somehost cat /etc/hosts)</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>了解 Bash 中的“嵌入文档”，就像在 <code>cat &lt;&lt;EOF ...</code> 中。</li><li>在 Bash 中，通过：<code>some-command &gt;logfile 2&gt;&amp;1</code> 同时重定向标准输出和标准错误。通常，要确保某个命令不再为标准输入打开文件句柄，而是将它捆绑到你所在的终端，添加 <code>&lt;/dev/null</code> 是个不错的做法。</li><li><code>man ascii</code> 可以得到一个不错的ASCII表，带有十六进制和十进制值两种格式。对于常规编码信息，<code>man unicode</code>，<code>man utf-8</code> 和 <code>man latin1</code> 将很有帮助。</li><li>使用 <code>screen</code> 或 <code>tmux</code> 来复用屏幕，这对于远程 ssh 会话尤为有用，使用它们来分离并重连到会话。另一个只用于保持会话的最小可选方案是 <code>dtach</code>。</li><li>在 ssh 中，知道如何使用 <code>-L</code> 或 <code>-D</code>（偶尔也用<code>-R</code>）来打开端口通道是很有用的，如从一台远程服务器访问网站时。</li><li>为你的 ssh 配置进行优化很有用；例如，这个 <code>~/.ssh/config</code> 包含了可以避免在特定网络环境中连接被断掉的情况的设置、使用压缩（这对于通过低带宽连接使用 scp 很有用），以及使用一个本地控制文件来开启到同一台服务器的多通道：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">TCPKeepAlive=yes</span><br><span class="line">ServerAliveInterval=15</span><br><span class="line">ServerAliveCountMax=6</span><br><span class="line">Compression=yes</span><br><span class="line">ControlMaster auto</span><br><span class="line">ControlPath /tmp/%r@%h:%p</span><br><span class="line">ControlPersist yes</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>其它一些与 ssh 相关的选项对会影响到安全，请小心开启，如各个子网或主机，或者在信任的网络中：<code>StrictHostKeyChecking=no</code>， <code>ForwardAgent=yes</code></li><li>要获得八进制格式的文件的权限，这对于系统配置很有用而用 <code>ls</code> 又没法查看，而且也很容易搞得一团糟，可以使用像这样的东西：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">stat -c &#x27;%A %a %n&#x27; /etc/timezone</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>对于从另一个命令的输出结果中交互选择值，可以使用<a target="_blank" rel="noopener" href="https://github.com/mooz/percol"><code>percol</code></a>。</li><li>对于基于另一个命令（如<code>git</code>）输出的文件交互，可以使用<code>fpp</code> (<a target="_blank" rel="noopener" href="https://github.com/facebook/PathPicker">路径选择器</a>)。</li><li>要为当前目录（及子目录）中的所有文件构建一个简单的 Web 服务器，让网络中的任何人都可以获取，可以使用： <code>python -m SimpleHTTPServer 7777</code> （使用端口 7777 和 Python 2）。</li></ul><h2 id="处理文件和数据"><a href="#处理文件和数据" class="headerlink" title="处理文件和数据"></a>处理文件和数据</h2><ul><li>要在当前目录中按名称定位文件，<code>find . -iname &#39;*something*&#39;</code>（或者相类似的）。要按名称查找任何地方的文件，使用 <code>locate something</code>（但请记住，<code>updatedb</code> 可能还没有索引最近创建的文件）。</li><li>对于源代码或数据文件进行的常规搜索（要比 <code>grep -r</code> 更高级），使用 <a target="_blank" rel="noopener" href="https://github.com/ggreer/the_silver_searcher"><code>ag</code></a>。</li><li>要将 HTML 转成文本：<code>lynx -dump -stdin</code>。</li><li>对于 Markdown、HTML，以及各种类型的文档转换，可以试试 <a target="_blank" rel="noopener" href="http://pandoc.org/"><code>pandoc</code></a>。</li><li>如果你必须处理 XML，<code>xmlstarlet</code> 虽然有点老旧，但是很好用。</li><li>对于 JSON，使用<code>jq</code>。</li><li>对于 Excel 或 CSV 文件，<a target="_blank" rel="noopener" href="https://github.com/onyxfish/csvkit">csvkit</a> 提供了 <code>in2csv</code>，<code>csvcut</code>，<code>csvjoin</code>，<code>csvgrep</code> 等工具。</li><li>对于亚马逊 S3 ，<a target="_blank" rel="noopener" href="https://github.com/s3tools/s3cmd"><code>s3cmd</code></a> 会很方便，而 <a target="_blank" rel="noopener" href="https://github.com/bloomreach/s4cmd"><code>s4cmd</code></a> 则更快速。亚马逊的 <a target="_blank" rel="noopener" href="https://github.com/aws/aws-cli"><code>aws</code></a> 则是其它 AWS 相关任务的必备。</li><li>掌握 <code>sort</code> 和 <code>uniq</code>，包括 uniq 的 <code>-u</code> 和 <code>-d</code> 选项——参见下面的单行程序。</li><li>掌握 <code>cut</code>，<code>paste</code> 和 <code>join</code>，它们用于处理文本文件。很多人会使用 <code>cut</code>，但常常忘了 <code>join</code>。</li><li>了解 <code>tee</code>，它会将 stdin 同时复制到一个文件和 stdout，如 <code>ls -al | tee file.txt</code>。</li><li>知道 locale 会以微妙的方式对命令行工具产生大量的影响，包括排序的顺序（整理）以及性能。大多数安装好的 Linux 会设置 <code>LANG</code> 或其它 locale 环境变量为本地设置，比如像 US English。但是，你要明白，如果改变了本地环境，那么排序也将改变。而且 i18n 过程会让排序或其它命令的运行慢<em>好多倍</em>。在某些情形中（如像下面那样的设置操作或唯一性操作），你可以安全地整个忽略缓慢的 i18n 过程，然后使用传统的基于字节的排序顺序 <code>export LC_ALL=C</code>。</li><li>了解基本的改动数据的 <code>awk</code> 和 <code>sed</code> 技能。例如，计算某个文本文件第三列所有数字的和：<code>awk &#39;&#123; x += $3 &#125; END &#123; print x &#125;&#39;</code>。这可能比 Python 的同等操作要快3倍，而且要短3倍。</li><li>在一个或多个文件中，替换所有出现在特定地方的某个字符串：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">perl -pi.bak -e &#x27;s/old-string/new-string/g&#x27; my-files-*.txt</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>要立即根据某个模式对大量文件重命名，使用 <code>rename</code>。对于复杂的重命名，<a target="_blank" rel="noopener" href="https://github.com/jlevy/repren"><code>repren</code></a> 可以帮助你达成。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 恢复备份文件 foo.bak -&gt; foo:</span><br><span class="line">rename &#x27;s/\.bak$//&#x27; *.bak</span><br><span class="line"># 完整的文件名、目录名 foo -&gt; bar:</span><br><span class="line">repren --full --preserve-case --from foo --to bar .</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>使用 <code>shuf</code> 来从某个文件中打乱或随机选择行。</li><li>了解 <code>sort</code> 的选项。知道这些键是怎么工作的（<code>-t</code>和<code>-k</code>）。特别是，注意你需要写<code>-k1,1</code>来只通过第一个字段排序；<code>-k1</code>意味着根据整行排序。</li><li>稳定排序（<code>sort -s</code>）会很有用。例如，要首先按字段2排序，然后再按字段1排序，你可以使用 <code>sort -k1,1 | sort -s -k2,2</code></li><li>如果你曾经需要在 Bash 命令行中写一个水平制表符（如，用于 -t 参数的排序），按<strong>ctrl-v</strong> <strong>[Tab]</strong>，或者写<code>$&#39;\t&#39;</code>（后面的更好，因为你可以复制&#x2F;粘贴）。</li><li>对源代码进行补丁的标准工具是 <code>diff</code> 和 <code>patch</code>。 用 <code>diffstat</code> 来统计 diff 情况。注意 <code>diff -r</code> 可以用于整个目录，所以可以用 <code>diff -r tree1 tree2 | diffstat</code> 来统计（两个目录的）差异。</li><li>对于二进制文件，使用 <code>hd</code> 进行简单十六进制转储，以及 <code>bvi</code> 用于二进制编辑。</li><li>还是用于二进制文件，<code>strings</code>（加上 <code>grep</code> 等）可以让你找出一点文本。</li><li>对于二进制文件的差异（delta 压缩），可以使用 <code>xdelta3</code>。</li><li>要转换文本编码，试试 <code>iconv</code> 吧，或者对于更高级的用途使用 <code>uconv</code>；它支持一些高级的 Unicode 的东西。例如，这个命令可以转换为小写并移除所有重音符号（通过扩展和丢弃）：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">uconv -f utf-8 -t utf-8 -x &#x27;::Any-Lower; ::Any-NFD; [:Nonspacing Mark:] &gt;; ::Any-NFC; &#x27; &lt; input.txt &gt; output.txt</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>要将文件分割成几个部分，来看看 <code>split</code>（按大小分割）和 <code>csplit</code>（按格式分割）吧。</li><li>使用 <code>zless</code>，<code>zmore</code>，<code>zcat</code> 和 <code>zgrep</code> 来操作压缩文件。</li></ul><h2 id="系统调试"><a href="#系统调试" class="headerlink" title="系统调试"></a>系统调试</h2><ul><li>对于 Web 调试，<code>curl</code> 和 <code>curl -I</code> 很方便灵活，或者也可以使用它们的同行 <code>wget</code>，或者更现代的 <a target="_blank" rel="noopener" href="https://github.com/jakubroztocil/httpie"><code>httpie</code></a>。</li><li>要了解磁盘、CPU、网络的状态，使用 <code>iostat</code>，<code>netstat</code>，<code>top</code>（或更好的 <code>htop</code>）和（特别是）<code>dstat</code>。它们对于快速获知系统中发生的状况很好用。</li><li>对于更深层次的系统总览，可以使用 <a target="_blank" rel="noopener" href="https://github.com/nicolargo/glances"><code>glances</code></a>。它会在一个终端窗口中为你呈现几个系统层次的统计数据，对于快速检查各个子系统很有帮助。</li><li>要了解内存状态，可以运行 <code>free</code> 和 <code>vmstat</code>，看懂它们的输出结果吧。特别是，要知道“cached”值是Linux内核为文件缓存所占有的内存，因此，要有效地统计“free”值。</li><li>Java 系统调试是一件截然不同的事，但是对于 Oracle 系统以及其它一些 JVM 而言，不过是一个简单的小把戏，你可以运行 <code>kill -3 &lt;pid&gt;</code>，然后一个完整的堆栈追踪和内存堆的摘要（包括常规的垃圾收集细节，这很有用）将被转储到stderr&#x2F;logs。</li><li>使用 <code>mtr</code> 作路由追踪更好，可以识别网络问题。</li><li>对于查看磁盘满载的原因，<code>ncdu</code> 会比常规命令如 <code>du -sh *</code> 更节省时间。</li><li>要查找占用带宽的套接字和进程，试试 <code>iftop</code> 或 <code>nethogs</code> 吧。</li><li>（Apache附带的）<code>ab</code>工具对于临时应急检查网络服务器性能很有帮助。对于更复杂的负载测试，可以试试 <code>siege</code>。</li><li>对于更仔细的网络调试，可以用 <code>wireshark</code>，<code>tshark</code> 或 <code>ngrep</code>。</li><li>掌握 <code>strace</code> 和 <code>ltrace</code>。如果某个程序失败、挂起或崩溃，而你又不知道原因，或者如果你想要获得性能的大概信息，这些工具会很有帮助。注意，分析选项（<code>-c</code>）和使用 <code>-p</code> 关联运行进程。</li><li>掌握 <code>ldd</code> 来查看共享库等。</li><li>知道如何使用 <code>gdb</code> 来连接到一个运行着的进程并获取其堆栈追踪信息。</li><li>使用 <code>/proc</code>。当调试当前的问题时，它有时候出奇地有帮助。样例：<code>/proc/cpuinfo</code>，<code>/proc/xxx/cwd</code>，<code>/proc/xxx/exe</code>，<code>/proc/xxx/fd/</code>，<code>/proc/xxx/smaps</code>。</li><li>当调试过去某个东西为何出错时，<code>sar</code> 会非常有帮助。它显示了 CPU、内存、网络等的历史统计数据。</li><li>对于更深层的系统和性能分析，看看 <code>stap</code> (<a target="_blank" rel="noopener" href="https://sourceware.org/systemtap/wiki">SystemTap</a>)，<a target="_blank" rel="noopener" href="http://en.wikipedia.org/wiki/Perf_(Linux)"><code>perf</code></a> 和 <a target="_blank" rel="noopener" href="https://github.com/draios/sysdig"><code>sysdig</code></a> 吧。</li><li>确认是正在使用的 Linux 发行版版本（支持大多数发行版）：<code>lsb_release -a</code>。</li><li>每当某个东西的行为异常时（可能是硬件或者驱动器问题），使用<code>dmesg</code>。</li></ul><h2 id="单行程序"><a href="#单行程序" class="headerlink" title="单行程序"></a>单行程序</h2><p>这是将命令连成一行的一些样例：</p><ul><li>有时候通过 <code>sort</code>&#x2F;<code>uniq</code> 对文本文件做交集、并集和差集运算时，这个例子会相当有帮助。假定 <code>a</code> 和 <code>b</code> 是已经进行了唯一性处理的文本文件。这会很快，而且可以处理任意大小的文件，总计可达数千兆字节。（Sort不受内存限制，不过如果 <code>/tmp</code> 放在一个很小的根分区的话，你可能需要使用 <code>-T</code> 选项。）也可参见上面关于<code>LC_ALL</code>的注解和 <code>-u</code> 选项（参见下面例子更清晰）。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sh cat a b | sort | uniq &gt; c # c 是 a 和 b 的并集 </span><br><span class="line">cat a b | sort | uniq -d &gt; c # c 是 a 和 b 的交集 </span><br><span class="line">cat a b b | sort | uniq -u &gt; c # c 是 a 减去 b 的差集</span><br></pre></td></tr></table></figure><ul><li>使用 <code>grep . *</code> 来可视化查看一个目录中的所有文件的所有内容，例如，对于放满配置文件的目录： <code>/sys</code>， <code>/proc</code>， <code>/etc</code>。</li><li>对某个文本文件的第三列中所有数据进行求和（该例子可能比同等功能的Python要快3倍，而且代码也少于其3倍）：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">awk &#x27;&#123; x += $3 &#125; END &#123; print x &#125;&#x27; myfile</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>如果想要查看某个文件树的大小&#x2F;日期，该例子就像一个递归<code>ls -l</code>，但是比<code>ls -lR</code>要更容易读懂：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">find . -type f -ls</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>只要可以，请使用 <code>xargs</code> 或 <code>parallel</code>。注意，你可以控制每行（<code>-L</code>）执行多少个项目，以及并行执行（<code>-P</code>）。如果你不确定它是否会做正确的事情，可以首先使用 <code>xargs echo</code>。同时，使用 <code>-I&#123;&#125;</code> 也很方便。样例：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">find . -name &#x27;*.py&#x27; | xargs grep some_function</span><br><span class="line">cat hosts | xargs -I&#123;&#125; ssh root@&#123;&#125; hostname</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>比如说，你有一个文本文件，如 Web 服务器的日志，在某些行中出现了某个特定的值，如 URL 中出现的 <code>acct_id</code> 参数。如果你想要统计有多少个 <code>acct_id</code> 的请求：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cat access.log | egrep -o &#x27;acct_id=[0-9]+&#x27; | cut -d= -f2 | sort | uniq -c | sort -rn</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>运行该函数来获得来自本文的随机提示（解析Markdown并从中提取某个项目）：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function taocl() &#123;</span><br><span class="line">    curl -s https://raw.githubusercontent.com/jlevy/the-art-of-command-line/master/README.md |</span><br><span class="line">      pandoc -f markdown -t html |</span><br><span class="line">      xmlstarlet fo --html --dropdtd |</span><br><span class="line">      xmlstarlet sel -t -v &quot;(html/body/ul/li[count(p)&gt;0])[$RANDOM mod last()+1]&quot; |</span><br><span class="line">      xmlstarlet unesc | fmt -80</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="晦涩难懂，但却有用"><a href="#晦涩难懂，但却有用" class="headerlink" title="晦涩难懂，但却有用"></a>晦涩难懂，但却有用</h2><ul><li><code>expr</code>：实施算术或布林操作，或者求正则表达式的值</li><li><code>m4</code>：简单的宏处理器</li><li><code>yes</code>：大量打印一个字符串</li><li><code>cal</code>：漂亮的日历</li><li><code>env</code>：（以特定的环境变量设置）运行一个命令（脚本中很有用）</li><li><code>look</code>：查找以某个字符串开头的英文单词（或文件中的行）</li><li><code>cut</code> 和 <code>paste</code> 以及 <code>join</code>：数据处理</li><li><code>fmt</code>：格式化文本段落</li><li><code>pr</code>：格式化文本为页&#x2F;列</li><li><code>fold</code>：文本折行</li><li><code>column</code>：格式化文本为列或表</li><li><code>expand</code> 和 <code>unexpand</code>：在制表符和空格间转换</li><li><code>nl</code>：添加行号</li><li><code>seq</code>：打印数字</li><li><code>bc</code>：计算器</li><li><code>factor</code>：分解质因子</li><li><code>gpg</code>：加密并为文件签名</li><li><code>toe</code>：terminfo 条目表</li><li><code>nc</code>：网络调试和数据传输</li><li><code>socat</code>：套接字中继和 tcp 端口转发（类似 <code>netcat</code>）</li><li><code>slurm</code>：网络流量可视化</li><li><code>dd</code>：在文件或设备间移动数据</li><li><code>file</code>：识别文件类型</li><li><code>tree</code>：以树形显示目录及子目录；类似 <code>ls</code>，但是是递归的。</li><li><code>stat</code>：文件信息</li><li><code>tac</code>：逆序打印文件</li><li><code>shuf</code>：从文件中随机选择行</li><li><code>comm</code>：逐行对比分类排序的文件</li><li><code>hd</code>和<code>bvi</code>：转储或编辑二进制文件</li><li><code>strings</code>：从二进制文件提取文本</li><li><code>tr</code>：字符转译或处理</li><li><code>iconv</code>或<code>uconv</code>：文本编码转换</li><li><code>split</code>和<code>csplit</code>：分割文件</li><li><code>units</code>：单位转换和计算；将每双周（fortnigh）一浪（浪，furlong，长度单位，约201米）转换为每瞬（blink）一缇（缇，twip，一种和屏幕无关的长度单位）（参见： &#x2F;usr&#x2F;share&#x2F;units&#x2F;definitions.units）（LCTT 译注：这都是神马单位啊！）</li><li><code>7z</code>：高比率文件压缩</li><li><code>ldd</code>：动态库信息</li><li><code>nm</code>：目标文件的符号</li><li><code>ab</code>：Web 服务器基准测试</li><li><code>strace</code>：系统调用调试</li><li><code>mtr</code>：用于网络调试的更好的路由追踪软件</li><li><code>cssh</code>：可视化并发 shell</li><li><code>rsync</code>：通过 SSH 同步文件和文件夹</li><li><code>wireshark</code> 和 <code>tshark</code>：抓包和网络调试</li><li><code>ngrep</code>：从网络层摘取信息</li><li><code>host</code> 和 <code>dig</code>：DNS查询</li><li><code>lsof</code>：处理文件描述符和套接字信息</li><li><code>dstat</code>：有用的系统统计数据</li><li><a target="_blank" rel="noopener" href="https://github.com/nicolargo/glances"><code>glances</code></a>：高级，多个子系统概览</li><li><code>iostat</code>：CPU和磁盘使用率统计</li><li><code>htop</code>：top的改进版</li><li><code>last</code>：登录历史</li><li><code>w</code>：谁登录进来了</li><li><code>id</code>：用户&#x2F;组身份信息</li><li><code>sar</code>：历史系统统计数据</li><li><code>iftop</code>或<code>nethogs</code>：按套接口或进程的网络使用率</li><li><code>ss</code>：套接口统计数据</li><li><code>dmesg</code>：启动和系统错误信息</li><li><code>hdparm</code>：SATA&#x2F;ATA 磁盘操作&#x2F;改善性能</li><li><code>lsb_release</code>：Linux 发行版信息</li><li><code>lsblk</code>：列出块设备，以树形展示你的磁盘和分区</li><li><code>lshw</code>：硬件信息</li><li><code>fortune</code>，<code>ddate</code> 和 <code>sl</code>：嗯，好吧，它取决于你是否认为蒸汽机车和 Zippy 引用“有用”</li></ul><h2 id="更多资源"><a href="#更多资源" class="headerlink" title="更多资源"></a>更多资源</h2><ul><li><a target="_blank" rel="noopener" href="https://github.com/alebcay/awesome-shell">超棒的shell</a>: 一个shell工具和资源一览表。</li><li><a target="_blank" rel="noopener" href="http://redsymbol.net/articles/unofficial-bash-strict-mode/">严格模式</a> 用于写出更佳的shell脚本。</li></ul><h2 id="免责声明"><a href="#免责声明" class="headerlink" title="免责声明"></a>免责声明</h2><p>除了非常小的任务外，其它都写出了代码供大家阅读。伴随力量而来的是责任。事实是，你<em>能</em>在Bash中做的，并不意味着是你所应该做的！；）</p><hr><p>via: <a target="_blank" rel="noopener" href="https://github.com/jlevy/the-art-of-command-line">https://github.com/jlevy/the-art-of-command-line</a></p><p>作者：<a target="_blank" rel="noopener" href="https://github.com/jlevy">jlevy</a> 译者：<a target="_blank" rel="noopener" href="https://github.com/GOLinux">GOLinux</a> 校对：<a target="_blank" rel="noopener" href="https://github.com/wxy">wxy</a></p><p>本文由 <a target="_blank" rel="noopener" href="https://github.com/LCTT/TranslateProject">LCTT</a> 原创翻译，<a target="_blank" rel="noopener" href="https://linux.cn/">Linux中国</a> 荣誉推出</p></div></div></div><div class="footer"><p class="footer-copyright"><span>Powered by <a target="_blank" href="https://hexo.io">Hexo</a></span> <span>Theme <a target="_blank" href="https://github.com/tinkink-co/hexo-theme-terminal">Terminal</a></span><script type="text/javascript" src="https://cdn.staticfile.net/jquery/3.4.1/jquery.min.js"></script><script>getCDNinfo=function(){$.ajax({url:"/cdn-cgi/trace",success:function(a,n){let i="Antananarivo, Madagascar - (TNR);Cape Town, South Africa - (CPT);Casablanca, Morocco - (CMN);Dar Es Salaam, Tanzania - (DAR);Djibouti City, Djibouti - (JIB);Durban, South Africa - (DUR);Johannesburg, South Africa - (JNB);Kigali, Rwanda - (KGL);Lagos, Nigeria - (LOS);Luanda, Angola - (LAD);Maputo, MZ - (MPM);Mombasa, Kenya - (MBA);Port Louis, Mauritius - (MRU);Réunion, France - (RUN);Bangalore, India - (BLR);Bangkok, Thailand - (BKK);Bandar Seri Begawan, Brunei - (BWN);Cebu, Philippines - (CEB);Chengdu, China - (CTU);Chennai, India - (MAA);Chittagong, Bangladesh - (CGP);Chongqing, China - (CKG);Colombo, Sri Lanka - (CMB);Dhaka, Bangladesh - (DAC);Dongguan, China - (SZX);Foshan, China - (FUO);Fuzhou, China - (FOC);Guangzhou, China - (CAN);Hangzhou, China - (HGH);Hanoi, Vietnam - (HAN);Hengyang, China - (HNY);Ho Chi Minh City, Vietnam - (SGN);Hong Kong - (HKG);Hyderabad, India - (HYD);Islamabad, Pakistan - (ISB);Jakarta, Indonesia - (CGK);Jinan, China - (TNA);Karachi, Pakistan - (KHI);Kathmandu, Nepal - (KTM);Kolkata, India - (CCU);Kuala Lumpur, Malaysia - (KUL);Lahore, Pakistan - (LHE);Langfang, China - (NAY);Luoyang, China - (LYA);Macau - (MFM);Malé, Maldives - (MLE);Manila, Philippines - (MNL);Mumbai, India - (BOM);Nagpur, India - (NAG);Nanning, China - (NNG);New Delhi, India - (DEL);Osaka, Japan - (KIX);Phnom Penh, Cambodia - (PNH);Qingdao, China - (TAO);Seoul, South Korea - (ICN);Shanghai, China - (SHA);Shenyang, China - (SHE);Shijiazhuang, China - (SJW);Singapore, Singapore - (SIN);Suzhou, China - (SZV);Taipei - (TPE);Thimphu, Bhutan - (PBH);Tianjin, China - (TSN);Tokyo, Japan - (NRT);Ulaanbaatar, Mongolia - (ULN);Vientiane, Laos - (VTE);Wuhan, China - (WUH);Wuxi, China - (WUX);Xi'an, China - (XIY);Yerevan, Armenia - (EVN);Zhengzhou, China - (CGO);Zuzhou, China - (CSX);Amsterdam, Netherlands - (AMS);Athens, Greece - (ATH);Barcelona, Spain - (BCN);Belgrade, Serbia - (BEG);Berlin, Germany - (TXL);Brussels, Belgium - (BRU);Bucharest, Romania - (OTP);Budapest, Hungary - (BUD);Chișinău, Moldova - (KIV);Copenhagen, Denmark - (CPH);Cork, Ireland -  (ORK);Dublin, Ireland - (DUB);Düsseldorf, Germany - (DUS);Edinburgh, United Kingdom - (EDI);Frankfurt, Germany - (FRA);Geneva, Switzerland - (GVA);Gothenburg, Sweden - (GOT);Hamburg, Germany - (HAM);Helsinki, Finland - (HEL);Istanbul, Turkey - (IST);Kyiv, Ukraine - (KBP);Lisbon, Portugal - (LIS);London, United Kingdom - (LHR);Luxembourg City, Luxembourg - (LUX);Madrid, Spain - (MAD);Manchester, United Kingdom - (MAN);Marseille, France - (MRS);Milan, Italy - (MXP);Moscow, Russia - (DME);Munich, Germany - (MUC);Nicosia, Cyprus - (LCA);Oslo, Norway - (OSL);Paris, France - (CDG);Prague, Czech Republic - (PRG);Reykjavík, Iceland - (KEF);Riga, Latvia - (RIX);Rome, Italy - (FCO);Saint Petersburg, Russia - (LED);Sofia, Bulgaria - (SOF);Stockholm, Sweden - (ARN);Tallinn, Estonia - (TLL);Thessaloniki, Greece - (SKG);Vienna, Austria - (VIE);Vilnius, Lithuania - (VNO);Warsaw, Poland - (WAW);Zagreb, Croatia - (ZAG);Zürich, Switzerland - (ZRH);Arica, Chile - (ARI);Asunción, Paraguay - (ASU);Bogotá, Colombia - (BOG);Buenos Aires, Argentina - (EZE);Curitiba, Brazil - (CWB);Fortaleza, Brazil - (FOR);Guatemala City, Guatemala - (GUA);Lima, Peru - (LIM);Medellín, Colombia - (MDE);Panama City, Panama - (PTY);Porto Alegre, Brazil - (POA);Quito, Ecuador - (UIO);Rio de Janeiro, Brazil - (GIG);São Paulo, Brazil - (GRU);Santiago, Chile - (SCL);Willemstad, Curaçao - (CUR);St. George's, Grenada - (GND);Amman, Jordan - (AMM);Baghdad, Iraq - (BGW);Baku, Azerbaijan - (GYD);Beirut, Lebanon - (BEY);Doha, Qatar - (DOH);Dubai, United Arab Emirates - (DXB);Kuwait City, Kuwait - (KWI);Manama, Bahrain - (BAH);Muscat, Oman - (MCT);Ramallah - (ZDM);Riyadh, Saudi Arabia - (RUH);Tel Aviv, Israel - (TLV);Ashburn, VA, United States - (IAD);Atlanta, GA, United States - (ATL);Boston, MA, United States - (BOS);Buffalo, NY, United States - (BUF);Calgary, AB, Canada - (YYC);Charlotte, NC, United States - (CLT);Chicago, IL, United States - (ORD);Columbus, OH, United States - (CMH);Dallas, TX, United States - (DFW);Denver, CO, United States - (DEN);Detroit, MI, United States - (DTW);Honolulu, HI, United States - (HNL);Houston, TX, United States - (IAH);Indianapolis, IN, United States - (IND);Jacksonville, FL, United States - (JAX);Kansas City, MO, United States - (MCI);Las Vegas, NV, United States - (LAS);Los Angeles, CA, United States - (LAX);McAllen, TX, United States - (MFE);Memphis, TN, United States - (MEM);Mexico City, Mexico - (MEX);Miami, FL, United States - (MIA);Minneapolis, MN, United States - (MSP);Montgomery, AL, United States - (MGM);Montréal, QC, Canada - (YUL);Nashville, TN, United States - (BNA);Newark, NJ, United States - (EWR);Norfolk, VA, United States - (ORF);Omaha, NE, United States - (OMA);Philadelphia, United States - (PHL);Phoenix, AZ, United States - (PHX);Pittsburgh, PA, United States - (PIT);Port-Au-Prince, Haiti - (PAP);Portland, OR, United States - (PDX);Queretaro, MX, Mexico - (QRO);Richmond, Virginia - (RIC);Sacramento, CA, United States - (SMF);Salt Lake City, UT, United States - (SLC);San Diego, CA, United States - (SAN);San Jose, CA, United States - (SJC);Saskatoon, SK, Canada - (YXE);Seattle, WA, United States - (SEA);St. Louis, MO, United States - (STL);Tampa, FL, United States - (TPA);Toronto, ON, Canada - (YYZ);Vancouver, BC, Canada - (YVR);Tallahassee, FL, United States - (TLH);Winnipeg, MB, Canada - (YWG);Adelaide, SA, Australia - (ADL);Auckland, New Zealand - (AKL);Brisbane, QLD, Australia - (BNE);Melbourne, VIC, Australia - (MEL);Noumea, New caledonia - (NOU);Perth, WA, Australia - (PER);Sydney, NSW, Australia - (SYD)".split(";"),e=a.split("colo=")[1].split("\n")[0],t=(a.split("colo=")[1].split("\n")[0],a.split("tls=")[1].split("\n")[0]),o=a.split("http=")[1].split("\n")[0],s=a.split("sni=")[1].split("\n")[0],r=a.split("ip=")[1].split("\n")[0],l=a.split("uag=")[1].split("\n")[0];for(var d=0;d<i.length;d++)if(-1!=i[d].indexOf(e)){document.getElementById("cdn").innerHTML=i[d];break}document.getElementById("tls").innerHTML=t,document.getElementById("http").innerHTML=o,document.getElementById("sni").innerHTML=s,document.getElementById("ip").innerHTML=r,document.getElementById("useragent").innerHTML=l}})},$(document).ready((function(){getCDNinfo()}))</script></p><p style="text-align:center">感谢陪伴与布道，开源之火不灭。​</p><p style="text-align:center"><script>document.write("本次加载耗时: "+(performance.getEntriesByType("navigation").reduce((e,r)=>e+r.responseEnd-r.startTime,0)+performance.getEntriesByType("resource").reduce((e,r)=>e+r.responseEnd-r.startTime,0)).toFixed(0)+"ms")</script></p><p style="text-align:center">当前 SNI 状态： <span id="sni">正在统计！或可能被浏览器防追踪拦截！</span></p><p style="text-align:center">当前 TLS 版本： <span id="tls">正在统计！或可能被浏览器防追踪拦截！</span></p><p style="text-align:center">当前 HTTP 版本： <span id="http">正在统计！或可能被浏览器防追踪拦截！</span></p><p style="text-align:center">当前您的客户端 IP 是： <span id="ip">正在统计！或可能被浏览器防追踪拦截！</span></p><p style="text-align:center">当前分配的 CDN 节点是: <span id="cdn">正在统计！或可能被浏览器防追踪拦截！</span></p><p style="text-align:center">您的 UserAgent 信息是: <span id="useragent">正在统计！或可能被浏览器防追踪拦截！</span></p><p></p></div></div></body></html>