<!doctype html><html lang="en"><head><meta name="msvalidate.01" content="D404690CEFCB54C7762AC84935B99171"><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?6618da70c90c8744eead2e9371fb5077";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><script type="text/javascript">!function(t,e,n,c,s,a,r){t[n]=t[n]||function(){(t[n].q=t[n].q||[]).push(arguments)},(a=e.createElement(c)).async=1,a.src="https://www.clarity.ms/tag/s5f3f0tojf",(r=e.getElementsByTagName(c)[0]).parentNode.insertBefore(a,r)}(window,document,"clarity","script")</script><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta http-equiv="X-UA-Compatible" content="ie=edge"><link rel="stylesheet" href="/styles/base.css"><link rel="stylesheet" href="/styles/theme.css"><link rel="shortcut icon" href="/favicon.png"><title>JVM 解释和编译指南 - 归墟星火集 又一个 LinuxCN 站点</title><meta name="generator" content="Hexo 7.3.0"></head><body><div class="header-title"><span class="header-light"></span> <span class="header-light"></span> <span class="header-light"></span> <span>归墟星火集 又一个 LinuxCN 站点 linuxcn.undefined.today<span></span></span></div><div class="container"><ul class="nav"><li><a href="/">首页</a></li><li><a target="_blank" rel="noopener" href="https://undefined.today/">Blog</a></li></ul><div class="content"><div class="post-container"><div class="post-header"><span class="ui-tips">标题：</span><h1 class="ui-keyword post-title">JVM 解释和编译指南</h1><span class="post-date">2023-11-06</span></div><div class="post-header"><span class="ui-tips">分类：</span> <a href="/categories/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/">软件开发</a></div><div class="post-header"><span class="ui-tips">标签：</span> <a href="/tags/%E7%BC%96%E8%AF%91/">编译</a> <a href="/tags/JVM/">JVM</a> <a href="/tags/%E8%A7%A3%E9%87%8A/">解释</a></div><div class="post-content"><p><img src="https://linuxcn.img.undefined.today/data/attachment/album/202311/06/093552kheiob71meqierhd.png"></p><blockquote><p>通过理解解释、即时编译和预先编译之间的区别，有效地使用它们。</p></blockquote><p>Java 是一种跨平台的编程语言。程序源代码会被编译为 <ruby>字节码 <rt>bytecode</rt></ruby>，然后字节码在运行时被转换为 <ruby>机器码 <rt>machine code</rt></ruby>。<ruby>解释器 <rt>interpreter</rt></ruby> 在物理机器上模拟出的抽象计算机上执行字节码指令。<ruby>即时 <rt>just-in-time</rt></ruby>（JIT）编译发生在运行期，而 <ruby>预先 <rt>ahead-of-time</rt></ruby>（AOT）编译发生在构建期。</p><p>本文将说明解释器、JIT 和 AOT 分别何时起作用，以及如何在 JIT 和 AOT 之间权衡。</p><h3 id="源代码、字节码、机器码"><a href="#源代码、字节码、机器码" class="headerlink" title="源代码、字节码、机器码"></a>源代码、字节码、机器码</h3><p>应用程序通常是由 C、C++ 或 Java 等编程语言编写。用这些高级编程语言编写的指令集合称为源代码。源代码是人类可读的。要在目标机器上执行它，需要将源代码转换为机器可读的机器码。这个转换工作通常是由 <ruby>编译器 <rt>compiler</rt></ruby> 来完成的。</p><p>然而，在 Java 中，源代码首先被转换为一种中间形式，称为字节码。字节码是平台无关的，所以 Java 被称为平台无关编程语言。Java 编译器 <code>javac</code> 将源代码转换为字节码。然后解释器解释执行字节码。</p><p>下面是一个简单的 Java 程序, <code>Hello.java</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//Hello.java</span><br><span class="line">public class Hello &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">         System.out.println(&quot;Inside Hello World!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>使用 <code>javac</code> 编译它，生成包含字节码的 <code>Hello.class</code> 文件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ javac Hello.java</span><br><span class="line">$ ls</span><br><span class="line">Hello.class  Hello.java</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>现在，使用 <code>javap</code> 来反汇编 <code>Hello.class</code> 文件的内容。使用 <code>javap</code> 时如果不指定任何选项，它将打印基本信息，包括编译这个 <code>.class</code> 文件的源文件、包名称、公共和受保护字段以及类的方法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ javap Hello.class</span><br><span class="line">Compiled from &quot;Hello.java&quot;</span><br><span class="line">public class Hello &#123;</span><br><span class="line">    public Hello();</span><br><span class="line">    public static void main(java.lang.String[]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>要查看 <code>.class</code> 文件中的字节码内容，使用 <code>-c</code> 选项：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">$ javap -c Hello.class</span><br><span class="line">Compiled from &quot;Hello.java&quot;</span><br><span class="line">public class Hello &#123;</span><br><span class="line">  public Hello();</span><br><span class="line">        Code:</span><br><span class="line">           0: aload_0</span><br><span class="line">           1: invokespecial #1                      // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">           4: return</span><br><span class="line"></span><br><span class="line">  public static void main(java.lang.String[]);</span><br><span class="line">        Code:</span><br><span class="line">           0: getstatic         #2                      // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">           3: ldc               #3                      // String Inside Hello World!</span><br><span class="line">           5: invokevirtual #4                      // Method    </span><br><span class="line">java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">           8: return</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>要获取更详细的信息，使用 <code>-v</code> 选项：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ javap -v Hello.class</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="解释器，JIT-和-AOT"><a href="#解释器，JIT-和-AOT" class="headerlink" title="解释器，JIT 和 AOT"></a>解释器，JIT 和 AOT</h3><p>解释器负责在物理机器上模拟出的抽象计算机上执行字节码指令。当使用 <code>javac</code> 编译源代码，然后使用 <code>java</code> 执行时，解释器在程序运行时运行并完成它的目标。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ javac Hello.java</span><br><span class="line">$ java Hello</span><br><span class="line">Inside Hello World!</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>JIT 编译器也在运行期发挥作用。当解释器解释 Java 程序时，另一个称为运行时 <ruby>分析器 <rt>profiler</rt></ruby> 的组件将静默地监视程序的执行，统计各部分代码被解释的次数。基于这些统计信息可以检测出程序的 <ruby>热点 <rt>hotspot</rt></ruby>，即那些经常被解释的代码。一旦代码被解释次数超过设定的阈值，它们满足被 JIT 编译器直接转换为机器码的条件。所以 JIT 编译器也被称为分析优化的编译器。从字节码到机器码的转换是在程序运行过程中进行的，因此称为即时编译。JIT 减少了解释器将同一组指令模拟为机器码的负担。</p><p>AOT 编译器在构建期编译代码。在构建时将需要频繁解释和 JIT 编译的代码直接编译为机器码可以缩短 <ruby>Java 虚拟机 <rt>Java Virtual Machine</rt></ruby>（JVM） 的<ruby>预热 <rt>warm-up</rt></ruby>时间。（LCTT 译注：Java 程序启动后首先字节码被解释执行，此时执行效率较低。等到程序运行了足够的时间后，代码热点被检测出来，JIT 开始发挥作用，程序运行效率提升。JIT 发挥作用之前的过程就是预热。）AOT 是在 Java 9 中引入的一个实验性特性。<code>jaotc</code> 使用 Graal 编译器（它本身也是用 Java 编写的）来实现 AOT 编译。</p><p>以 <code>Hello.java</code> 为例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//Hello.java</span><br><span class="line">public class Hello &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(&quot;Inside Hello World!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$ javac Hello.java</span><br><span class="line">$ jaotc --output libHello.so Hello.class</span><br><span class="line">$ java -XX:+UnlockExperimentalVMOptions -XX:AOTLibrary=./libHello.so Hello</span><br><span class="line">Inside Hello World!</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="解释和编译发生的时机"><a href="#解释和编译发生的时机" class="headerlink" title="解释和编译发生的时机"></a>解释和编译发生的时机</h3><p>下面通过例子来展示 Java 在什么时候使用解释器，以及 JIT 和 AOT 何时参与进来。这里有一个简单的程序 <code>Demo.java</code> :</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">//Demo.java</span><br><span class="line">public class Demo &#123;</span><br><span class="line">    public int square(int i) throws Exception &#123;</span><br><span class="line">        return(i*i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        for (int i = 1; i &lt;= 10; i++) &#123;</span><br><span class="line">            System.out.println(&quot;call &quot; + Integer.valueOf(i));</span><br><span class="line">            long a = System.nanoTime();</span><br><span class="line">            Int r = new Demo().square(i);</span><br><span class="line">            System.out.println(&quot;Square(i) = &quot; + r);</span><br><span class="line">            long b = System.nanoTime();</span><br><span class="line">            System.out.println(&quot;elapsed= &quot; + (b-a));</span><br><span class="line">            System.out.println(&quot;--------------------------------&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在这个程序的 <code>main()</code> 方法中创建了一个 <code>Demo</code> 对象的实例，并调用该实例的 <code>square()</code>方法，然后显示 <code>for</code> 循环迭代变量的平方值。编译并运行它：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">$ javac Demo.java</span><br><span class="line">$ java Demo</span><br><span class="line">1 iteration</span><br><span class="line">Square(i) = 1</span><br><span class="line">Time taken= 8432439</span><br><span class="line">--------------------------------</span><br><span class="line">2 iteration</span><br><span class="line">Square(i) = 4</span><br><span class="line">Time taken= 54631</span><br><span class="line">--------------------------------</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">--------------------------------</span><br><span class="line">10 iteration</span><br><span class="line">Square(i) = 100</span><br><span class="line">Time taken= 66498</span><br><span class="line">--------------------------------</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上面的结果是由谁产生的呢？是解释器，JIT 还是 AOT？在目前的情况下，它完全是通过解释产生的。我是怎么得出这个结论的呢？只有代码被解释的次数必须超过某个阈值时，这些热点代码片段才会被加入 JIT 编译队列。只有这时，JIT 编译才会发挥作用。使用以下命令查看 JDK 11 中的该阈值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ java -XX:+PrintFlagsFinal -version | grep CompileThreshold</span><br><span class="line"> intx CompileThreshold     = 10000                                      &#123;pd product&#125; &#123;default&#125;</span><br><span class="line">[...]</span><br><span class="line">openjdk version &quot;11.0.13&quot; 2021-10-19</span><br><span class="line">OpenJDK Runtime Environment 18.9 (build 11.0.13+8)</span><br><span class="line">OpenJDK 64-Bit Server VM 18.9 (build 11.0.13+8, mixed mode, sharing)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上面的输出表明，一段代码被解释 10,000 次才符合 JIT 编译的条件。这个阈值是否可以手动调整呢？是否有 JVM 标志可以指示出方法是否被 JIT 编译了呢？答案是肯定的，而且有多种方式可以达到这个目的。</p><p>使用 <code>-XX:+PrintCompilation</code> 选项可以查看一个方法是否被 JIT 编译。除此之外，使用 <code>-Xbatch</code> 标志可以提高输出的可读性。如果解释和 JIT 同时发生，<code>-Xbatch</code> 可以帮助区分两者的输出。使用这些标志如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ java -Xbatch  -XX:+PrintCompilation  Demo</span><br><span class="line">         34        1        b  3           java.util.concurrent.ConcurrentHashMap::tabAt (22 bytes)</span><br><span class="line">         35        2         n 0           jdk.internal.misc.Unsafe::getObjectVolatile (native)   </span><br><span class="line">         35        3        b  3           java.lang.Object::&lt;init&gt; (1 bytes)</span><br><span class="line">[...]</span><br><span class="line">        210  269         n 0           java.lang.reflect.Array::newArray (native)   (static)</span><br><span class="line">        211  270        b  3           java.lang.String::substring (58 bytes)</span><br><span class="line">[...]</span><br><span class="line">--------------------------------</span><br><span class="line">10 iteration</span><br><span class="line">Square(i) = 100</span><br><span class="line">Time taken= 50150</span><br><span class="line">--------------------------------</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>注意，上面命令的实际输出太长了，这里我只是截取了一部分。输出很长的原因是除了 <code>Demo</code> 程序的代码外，JDK 内部类的函数也被编译了。由于我的重点是 <code>Demo.java</code> 代码，我希望排除内部包的函数来简化输出。通过选项 <code>-XX:CompileCommandFile</code> 可以禁用内部类的 JIT：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ java -Xbatch -XX:+PrintCompilation -XX:CompileCommandFile=hotspot_compiler Demo</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在选项 <code>-XX:CompileCommandFile</code> 指定的文件 <code>hotspot_compiler</code> 中包含了要排除的包：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ cat hotspot_compiler</span><br><span class="line">quiet</span><br><span class="line">exclude java/* *</span><br><span class="line">exclude jdk/* *</span><br><span class="line">exclude sun/* *</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>第一行的 <code>quiet</code> 告诉 JVM 不要输出任何关于被排除类的内容。用 <code>-XX:CompileThreshold</code> 将 JIT 阈值设置为 5。这意味着在解释 5 次之后，就会进行 JIT 编译：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">$ java -Xbatch -XX:+PrintCompilation -XX:CompileCommandFile=hotspot_compiler \</span><br><span class="line">-XX:CompileThreshold=5 Demo</span><br><span class="line">        47      1       n 0     java.lang.invoke.MethodHandle::linkToStatic(LLLLLL)L (native)   </span><br><span class="line">           (static)</span><br><span class="line">        47      2       n 0     java.lang.invoke.MethodHandle::invokeBasic(LLLLL)L (native)   </span><br><span class="line">        47      3       n 0     java.lang.invoke.MethodHandle::linkToSpecial(LLLLLLL)L (native)   </span><br><span class="line">           (static)</span><br><span class="line">        48      4       n 0     java.lang.invoke.MethodHandle::linkToStatic(L)I (native)   (static)</span><br><span class="line">        48      5       n 0     java.lang.invoke.MethodHandle::invokeBasic()I (native)   </span><br><span class="line">        48      6       n 0     java.lang.invoke.MethodHandle::linkToSpecial(LL)I (native)   </span><br><span class="line">           (static)</span><br><span class="line">[...]</span><br><span class="line">        1 iteration</span><br><span class="line">        69   40         n 0     java.lang.invoke.MethodHandle::linkToStatic(ILIIL)I (native)   </span><br><span class="line">           (static)</span><br><span class="line">[...]</span><br><span class="line">Square(i) = 1</span><br><span class="line">        78   48         n 0     java.lang.invoke.MethodHandle::linkToStatic(ILIJL)I (native)   </span><br><span class="line">(static)</span><br><span class="line">        79   49         n 0     java.lang.invoke.MethodHandle::invokeBasic(ILIJ)I (native)   </span><br><span class="line">[...]</span><br><span class="line">        86   54         n 0     java.lang.invoke.MethodHandle::invokeBasic(J)L (native)   </span><br><span class="line">        87   55         n 0     java.lang.invoke.MethodHandle::linkToSpecial(LJL)L (native)   </span><br><span class="line">(static)</span><br><span class="line">Time taken= 8962738</span><br><span class="line">--------------------------------</span><br><span class="line">2 iteration</span><br><span class="line">Square(i) = 4</span><br><span class="line">Time taken= 26759</span><br><span class="line">--------------------------------</span><br><span class="line"></span><br><span class="line">10 iteration</span><br><span class="line">Square(i) = 100</span><br><span class="line">Time taken= 26492</span><br><span class="line">--------------------------------</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>好像输出结果跟只用解释时并没有什么区别。根据 Oracle 的文档，这是因为只有禁用 <code>TieredCompilation</code> 时 <code>-XX:CompileThreshold</code> 才会生效：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">$ java -Xbatch -XX:+PrintCompilation -XX:CompileCommandFile=hotspot_compiler \</span><br><span class="line">-XX:-TieredCompilation -XX:CompileThreshold=5 Demo</span><br><span class="line">124     1       n       java.lang.invoke.MethodHandle::linkToStatic(LLLLLL)L (native)   (static)</span><br><span class="line">127     2       n       java.lang.invoke.MethodHandle::invokeBasic(LLLLL)L (native)   </span><br><span class="line">[...]</span><br><span class="line">1 iteration</span><br><span class="line">        187   40        n       java.lang.invoke.MethodHandle::linkToStatic(ILIIL)I (native)   (static)</span><br><span class="line">[...]</span><br><span class="line">(native)   (static)</span><br><span class="line">        212   54        n       java.lang.invoke.MethodHandle::invokeBasic(J)L (native)   </span><br><span class="line">        212   55        n       java.lang.invoke.MethodHandle::linkToSpecial(LJL)L (native)   (static)</span><br><span class="line">Time taken= 12337415</span><br><span class="line">[...]</span><br><span class="line">--------------------------------</span><br><span class="line">4 iteration</span><br><span class="line">Square(i) = 16</span><br><span class="line">Time taken= 37183</span><br><span class="line">--------------------------------</span><br><span class="line">5 iteration</span><br><span class="line">        214   56        b       Demo::&lt;init&gt; (5 bytes)</span><br><span class="line">        215   57        b       Demo::square (16 bytes)</span><br><span class="line">Square(i) = 25</span><br><span class="line">Time taken= 983002</span><br><span class="line">--------------------------------</span><br><span class="line">6 iteration</span><br><span class="line">Square(i) = 36</span><br><span class="line">Time taken= 81589</span><br><span class="line">[...]</span><br><span class="line">10 iteration</span><br><span class="line">Square(i) = 100</span><br><span class="line">Time taken= 52393</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以看到在第五次迭代之后，代码片段被 JIT 编译了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">--------------------------------</span><br><span class="line">5 iteration</span><br><span class="line">        214   56        b       Demo::&lt;init&gt; (5 bytes)</span><br><span class="line">        215   57        b       Demo::square (16 bytes)</span><br><span class="line">Square(i) = 25</span><br><span class="line">Time taken= 983002</span><br><span class="line">--------------------------------</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以看到，与 <code>square()</code> 方法一起，构造方法也被 JIT 编译了。在 <code>for</code> 循环中调用 <code>square()</code> 之前要先构造 <code>Demo</code> 实例，所以构造方法的解释次数同样达到 JIT 编译阈值。这个例子说明了在解释发生之后何时 JIT 会介入。</p><p>要查看编译后的代码，需要使用 <code>-XX:+PrintAssembly</code> 标志，该标志仅在库路径中有反汇编器时才起作用。对于 OpenJDK，使用 <code>hsdis</code> 作为反汇编器。下载合适版本的反汇编程序库，在本例中是 <code>hsdis-amd64.so</code>，并将其放在 <code>Java_HOME/lib/server</code> 目录下。使用时还需要在 <code>-XX:+PrintAssembly</code> 之前增加 <code>-XX:+UnlockDiagnosticVMOptions</code> 选项。否则，JVM 会给你一个警告。</p><p>完整命令如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">$ java -Xbatch -XX:+PrintCompilation -XX:CompileCommandFile=hotspot_compiler \ -XX:-TieredCompilation -XX:CompileThreshold=5 -XX:+UnlockDiagnosticVMOptions \ -XX:+PrintAssembly Demo</span><br><span class="line">[...]</span><br><span class="line">5 iteration</span><br><span class="line">        178   56        b       Demo::&lt;init&gt; (5 bytes)</span><br><span class="line">Compiled method (c2)    178   56                Demo::&lt;init&gt; (5 bytes)</span><br><span class="line"> total in heap  [0x00007fd4d08dad10,0x00007fd4d08dafe0] = 720</span><br><span class="line"> relocation     [0x00007fd4d08dae88,0x00007fd4d08daea0] = 24</span><br><span class="line">[...]</span><br><span class="line"> handler table  [0x00007fd4d08dafc8,0x00007fd4d08dafe0] = 24</span><br><span class="line">[...]</span><br><span class="line"> dependencies   [0x00007fd4d08db3c0,0x00007fd4d08db3c8] = 8</span><br><span class="line"> handler table  [0x00007fd4d08db3c8,0x00007fd4d08db3f8] = 48</span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line">Demo.square(I)I  [0x00007fd4d08db1c0, 0x00007fd4d08db2b8]  248 bytes</span><br><span class="line">[Entry Point]</span><br><span class="line">[Constants]</span><br><span class="line">  # &#123;method&#125; &#123;0x00007fd4b841f4b0&#125; &#x27;square&#x27; &#x27;(I)I&#x27; in &#x27;Demo&#x27;</span><br><span class="line">  # this:       rsi:rsi   = &#x27;Demo&#x27;</span><br><span class="line">  # parm0:      rdx     = int</span><br><span class="line">  #             [sp+0x20]  (sp of caller)</span><br><span class="line">[...]</span><br><span class="line">[Stub Code]</span><br><span class="line">  0x00007fd4d08db280: movabs $0x0,%rbx          ;   &#123;no_reloc&#125;</span><br><span class="line">  0x00007fd4d08db28a: jmpq   0x00007fd4d08db28a  ;   &#123;runtime_call&#125;</span><br><span class="line">  0x00007fd4d08db28f: movabs $0x0,%rbx          ;   &#123;static_stub&#125;</span><br><span class="line">  0x00007fd4d08db299: jmpq   0x00007fd4d08db299  ;   &#123;runtime_call&#125;</span><br><span class="line">[Exception Handler]</span><br><span class="line">  0x00007fd4d08db29e: jmpq   0x00007fd4d08bb880  ;   &#123;runtime_call ExceptionBlob&#125;</span><br><span class="line">[Deopt Handler Code]</span><br><span class="line">  0x00007fd4d08db2a3: callq  0x00007fd4d08db2a8</span><br><span class="line">  0x00007fd4d08db2a8: subq   $0x5,(%rsp)</span><br><span class="line">  0x00007fd4d08db2ad: jmpq   0x00007fd4d08a01a0  ;   &#123;runtime_call DeoptimizationBlob&#125;</span><br><span class="line">  0x00007fd4d08db2b2: hlt    </span><br><span class="line">  0x00007fd4d08db2b3: hlt    </span><br><span class="line">  0x00007fd4d08db2b4: hlt    </span><br><span class="line">  0x00007fd4d08db2b5: hlt    </span><br><span class="line">  0x00007fd4d08db2b6: hlt    </span><br><span class="line">  0x00007fd4d08db2b7: hlt    </span><br><span class="line">ImmutableOopMap&#123;rbp=NarrowOop &#125;pc offsets: 96</span><br><span class="line">ImmutableOopMap&#123;&#125;pc offsets: 112</span><br><span class="line">ImmutableOopMap&#123;rbp=Oop &#125;pc offsets: 148 Square(i) = 25</span><br><span class="line">Time taken= 2567698</span><br><span class="line">--------------------------------</span><br><span class="line">6 iteration</span><br><span class="line">Square(i) = 36</span><br><span class="line">Time taken= 76752</span><br><span class="line">[...]</span><br><span class="line">--------------------------------</span><br><span class="line">10 iteration</span><br><span class="line">Square(i) = 100</span><br><span class="line">Time taken= 52888</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我只截取了输出中与 <code>Demo.java</code> 相关的部分。</p><p>现在再来看看 AOT 编译。它是在 JDK9 中引入的特性。AOT 是用于生成 <code>.so</code> 这样的库文件的静态编译器。用 AOT 可以将指定的类编译成 <code>.so</code> 库。这个库可以直接执行，而不用解释或 JIT 编译。如果 JVM 没有检测到 AOT 编译的代码，它会进行常规的解释和 JIT 编译。</p><p>使用 AOT 编译的命令如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ jaotc --output=libDemo.so Demo.class</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>用下面的命令来查看共享库的符号表：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ nm libDemo.so</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>要使用生成的 <code>.so</code> 库，使用 <code>-XX:+UnlockExperimentalVMOptions</code> 和 <code>-XX:AOTLibrary</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ java -XX:+UnlockExperimentalVMOptions -XX:AOTLibrary=./libDemo.so Demo</span><br><span class="line">1 iteration</span><br><span class="line">Square(i) = 1</span><br><span class="line">Time taken= 7831139</span><br><span class="line">--------------------------------</span><br><span class="line">2 iteration</span><br><span class="line">Square(i) = 4</span><br><span class="line">Time taken= 36619</span><br><span class="line">[...]</span><br><span class="line">10 iteration</span><br><span class="line">Square(i) = 100</span><br><span class="line">Time taken= 42085</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>从输出上看，跟完全用解释的情况没有区别。为了确认 AOT 发挥了作用，使用 <code>-XX:+PrintAOT</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$ java -XX:+UnlockExperimentalVMOptions -XX:AOTLibrary=./libDemo.so -XX:+PrintAOT Demo</span><br><span class="line">         28        1         loaded        ./libDemo.so  aot library</span><br><span class="line">         80        1         aot[ 1]   Demo.main([Ljava/lang/String;)V</span><br><span class="line">         80        2         aot[ 1]   Demo.square(I)I</span><br><span class="line">         80        3         aot[ 1]   Demo.&lt;init&gt;()V</span><br><span class="line">1 iteration</span><br><span class="line">Square(i) = 1</span><br><span class="line">Time taken= 7252921</span><br><span class="line">--------------------------------</span><br><span class="line">2 iteration</span><br><span class="line">Square(i) = 4</span><br><span class="line">Time taken= 57443</span><br><span class="line">[...]</span><br><span class="line">10 iteration</span><br><span class="line">Square(i) = 100</span><br><span class="line">Time taken= 53586</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>要确认没有发生 JIT 编译，用如下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ java -XX:+UnlockExperimentalVMOptions -Xbatch -XX:+PrintCompilation \ -XX:CompileCommandFile=hotspot_compiler -XX:-TieredCompilation \ -XX:CompileThreshold=3 -XX:AOTLibrary=./libDemo.so -XX:+PrintAOT Demo</span><br><span class="line">         19        1         loaded        ./libDemo.so  aot library</span><br><span class="line">         77        1         aot[ 1]   Demo.square(I)I</span><br><span class="line">         77        2         aot[ 1]   Demo.main([Ljava/lang/String;)V</span><br><span class="line">         77        3         aot[ 1]   Demo.&lt;init&gt;()V</span><br><span class="line">         77        2         aot[ 1]   Demo.main([Ljava/lang/String;)V   made not entrant</span><br><span class="line">[...]</span><br><span class="line">4 iteration</span><br><span class="line">Square(i) = 16</span><br><span class="line">Time taken= 43366</span><br><span class="line">[...]</span><br><span class="line">10 iteration</span><br><span class="line">Square(i) = 100</span><br><span class="line">Time taken= 59554</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>需要特别注意的是，修改被 AOT 编译了的源代码后，一定要重新生成 <code>.so</code> 库文件。否则，过时的的 AOT 编译库文件不会起作用。例如，修改 <code>square()</code> 方法，使其计算立方值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">//Demo.java</span><br><span class="line">public class Demo &#123;</span><br><span class="line"></span><br><span class="line">    public int square(int i) throws Exception &#123;</span><br><span class="line">        return(i*i*i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        for (int i = 1; i &lt;= 10; i++) &#123;</span><br><span class="line">          System.out.println(&quot;&quot; + Integer.valueOf(i)+&quot; iteration&quot;);</span><br><span class="line">          long start = System.nanoTime();</span><br><span class="line">          int r= new Demo().square(i);</span><br><span class="line">          System.out.println(&quot;Square(i) = &quot; + r);</span><br><span class="line">          long end = System.nanoTime();</span><br><span class="line">          System.out.println(&quot;Time taken= &quot; + (end-start));</span><br><span class="line">          System.out.println(&quot;--------------------------------&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>重新编译 <code>Demo.java</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ java Demo.java</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>但不重新生成 <code>libDemo.so</code>。使用下面命令运行 <code>Demo</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">$ java -XX:+UnlockExperimentalVMOptions -Xbatch -XX:+PrintCompilation -XX:CompileCommandFile=hotspot_compiler -XX:-TieredCompilation -XX:CompileThreshold=3 -XX:AOTLibrary=./libDemo.so -XX:+PrintAOT Demo</span><br><span class="line">         20        1         loaded        ./libDemo.so  aot library</span><br><span class="line">         74        1         n           java.lang.invoke.MethodHandle::linkToStatic(LLLLLL)L (native)   (static)</span><br><span class="line">2 iteration</span><br><span class="line">sqrt(i) = 8</span><br><span class="line">Time taken= 43838</span><br><span class="line">--------------------------------</span><br><span class="line">3 iteration</span><br><span class="line">        137   56        b            Demo::&lt;init&gt; (5 bytes)</span><br><span class="line">        138   57        b            Demo::square (6 bytes)</span><br><span class="line">sqrt(i) = 27</span><br><span class="line">Time taken= 534649</span><br><span class="line">--------------------------------</span><br><span class="line">4 iteration</span><br><span class="line">sqrt(i) = 64</span><br><span class="line">Time taken= 51916</span><br><span class="line">[...]</span><br><span class="line">10 iteration</span><br><span class="line">sqrt(i) = 1000</span><br><span class="line">Time taken= 47132</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以看到，虽然旧版本的 <code>libDemo.so</code> 被加载了，但 JVM 检测出它已经过时了。每次生成 <code>.class</code> 文件时，都会在类文件中添加一个指纹，并在 AOT 库中保存该指纹。修改源代码后类指纹与旧的 AOT 库中的指纹不匹配了，所以没有执行 AOT 编译生成的原生机器码。从输出可以看出，现在实际上是 JIT 在起作用（注意 <code>-XX:CompileThreshold</code> 被设置为了 3）。</p><h3 id="AOT-和-JIT-之间的权衡"><a href="#AOT-和-JIT-之间的权衡" class="headerlink" title="AOT 和 JIT 之间的权衡"></a>AOT 和 JIT 之间的权衡</h3><p>如果你的目标是减少 JVM 的预热时间，请使用 AOT，这可以减少运行时负担。问题是 AOT 没有足够的数据来决定哪段代码需要预编译为原生代码。相比之下，JIT 在运行时起作用，却对预热时间有一定的影响。然而，它将有足够的分析数据来更高效地编译和反编译代码。</p><p><em>（题图：MJ&#x2F;ed3e6e15-56c7-4c1d-aff1-84a225faeeeb）</em></p><hr><p>via: <a target="_blank" rel="noopener" href="https://opensource.com/article/22/8/interpret-compile-java">https://opensource.com/article/22/8/interpret-compile-java</a></p><p>作者：<a target="_blank" rel="noopener" href="https://opensource.com/users/jayashree-huttanagoudar">Jayashree Huttanagoudar</a> 选题：<a target="_blank" rel="noopener" href="https://github.com/lkxed">lkxed</a> 译者：<a target="_blank" rel="noopener" href="https://github.com/toknow-gh">toknow-gh</a> 校对：<a target="_blank" rel="noopener" href="https://github.com/wxy">wxy</a></p><p>本文由 <a target="_blank" rel="noopener" href="https://github.com/LCTT/TranslateProject">LCTT</a> 原创编译，<a target="_blank" rel="noopener" href="https://linux.cn/">Linux中国</a> 荣誉推出</p></div></div></div><div class="footer"><p class="footer-copyright"><span>Powered by <a target="_blank" href="https://hexo.io">Hexo</a></span> <span>Theme <a target="_blank" href="https://github.com/tinkink-co/hexo-theme-terminal">Terminal</a></span><script type="text/javascript" src="https://cdn.staticfile.net/jquery/3.4.1/jquery.min.js"></script><script>getCDNinfo=function(){$.ajax({url:"/cdn-cgi/trace",success:function(a,n){let i="Antananarivo, Madagascar - (TNR);Cape Town, South Africa - (CPT);Casablanca, Morocco - (CMN);Dar Es Salaam, Tanzania - (DAR);Djibouti City, Djibouti - (JIB);Durban, South Africa - (DUR);Johannesburg, South Africa - (JNB);Kigali, Rwanda - (KGL);Lagos, Nigeria - (LOS);Luanda, Angola - (LAD);Maputo, MZ - (MPM);Mombasa, Kenya - (MBA);Port Louis, Mauritius - (MRU);Réunion, France - (RUN);Bangalore, India - (BLR);Bangkok, Thailand - (BKK);Bandar Seri Begawan, Brunei - (BWN);Cebu, Philippines - (CEB);Chengdu, China - (CTU);Chennai, India - (MAA);Chittagong, Bangladesh - (CGP);Chongqing, China - (CKG);Colombo, Sri Lanka - (CMB);Dhaka, Bangladesh - (DAC);Dongguan, China - (SZX);Foshan, China - (FUO);Fuzhou, China - (FOC);Guangzhou, China - (CAN);Hangzhou, China - (HGH);Hanoi, Vietnam - (HAN);Hengyang, China - (HNY);Ho Chi Minh City, Vietnam - (SGN);Hong Kong - (HKG);Hyderabad, India - (HYD);Islamabad, Pakistan - (ISB);Jakarta, Indonesia - (CGK);Jinan, China - (TNA);Karachi, Pakistan - (KHI);Kathmandu, Nepal - (KTM);Kolkata, India - (CCU);Kuala Lumpur, Malaysia - (KUL);Lahore, Pakistan - (LHE);Langfang, China - (NAY);Luoyang, China - (LYA);Macau - (MFM);Malé, Maldives - (MLE);Manila, Philippines - (MNL);Mumbai, India - (BOM);Nagpur, India - (NAG);Nanning, China - (NNG);New Delhi, India - (DEL);Osaka, Japan - (KIX);Phnom Penh, Cambodia - (PNH);Qingdao, China - (TAO);Seoul, South Korea - (ICN);Shanghai, China - (SHA);Shenyang, China - (SHE);Shijiazhuang, China - (SJW);Singapore, Singapore - (SIN);Suzhou, China - (SZV);Taipei - (TPE);Thimphu, Bhutan - (PBH);Tianjin, China - (TSN);Tokyo, Japan - (NRT);Ulaanbaatar, Mongolia - (ULN);Vientiane, Laos - (VTE);Wuhan, China - (WUH);Wuxi, China - (WUX);Xi'an, China - (XIY);Yerevan, Armenia - (EVN);Zhengzhou, China - (CGO);Zuzhou, China - (CSX);Amsterdam, Netherlands - (AMS);Athens, Greece - (ATH);Barcelona, Spain - (BCN);Belgrade, Serbia - (BEG);Berlin, Germany - (TXL);Brussels, Belgium - (BRU);Bucharest, Romania - (OTP);Budapest, Hungary - (BUD);Chișinău, Moldova - (KIV);Copenhagen, Denmark - (CPH);Cork, Ireland -  (ORK);Dublin, Ireland - (DUB);Düsseldorf, Germany - (DUS);Edinburgh, United Kingdom - (EDI);Frankfurt, Germany - (FRA);Geneva, Switzerland - (GVA);Gothenburg, Sweden - (GOT);Hamburg, Germany - (HAM);Helsinki, Finland - (HEL);Istanbul, Turkey - (IST);Kyiv, Ukraine - (KBP);Lisbon, Portugal - (LIS);London, United Kingdom - (LHR);Luxembourg City, Luxembourg - (LUX);Madrid, Spain - (MAD);Manchester, United Kingdom - (MAN);Marseille, France - (MRS);Milan, Italy - (MXP);Moscow, Russia - (DME);Munich, Germany - (MUC);Nicosia, Cyprus - (LCA);Oslo, Norway - (OSL);Paris, France - (CDG);Prague, Czech Republic - (PRG);Reykjavík, Iceland - (KEF);Riga, Latvia - (RIX);Rome, Italy - (FCO);Saint Petersburg, Russia - (LED);Sofia, Bulgaria - (SOF);Stockholm, Sweden - (ARN);Tallinn, Estonia - (TLL);Thessaloniki, Greece - (SKG);Vienna, Austria - (VIE);Vilnius, Lithuania - (VNO);Warsaw, Poland - (WAW);Zagreb, Croatia - (ZAG);Zürich, Switzerland - (ZRH);Arica, Chile - (ARI);Asunción, Paraguay - (ASU);Bogotá, Colombia - (BOG);Buenos Aires, Argentina - (EZE);Curitiba, Brazil - (CWB);Fortaleza, Brazil - (FOR);Guatemala City, Guatemala - (GUA);Lima, Peru - (LIM);Medellín, Colombia - (MDE);Panama City, Panama - (PTY);Porto Alegre, Brazil - (POA);Quito, Ecuador - (UIO);Rio de Janeiro, Brazil - (GIG);São Paulo, Brazil - (GRU);Santiago, Chile - (SCL);Willemstad, Curaçao - (CUR);St. George's, Grenada - (GND);Amman, Jordan - (AMM);Baghdad, Iraq - (BGW);Baku, Azerbaijan - (GYD);Beirut, Lebanon - (BEY);Doha, Qatar - (DOH);Dubai, United Arab Emirates - (DXB);Kuwait City, Kuwait - (KWI);Manama, Bahrain - (BAH);Muscat, Oman - (MCT);Ramallah - (ZDM);Riyadh, Saudi Arabia - (RUH);Tel Aviv, Israel - (TLV);Ashburn, VA, United States - (IAD);Atlanta, GA, United States - (ATL);Boston, MA, United States - (BOS);Buffalo, NY, United States - (BUF);Calgary, AB, Canada - (YYC);Charlotte, NC, United States - (CLT);Chicago, IL, United States - (ORD);Columbus, OH, United States - (CMH);Dallas, TX, United States - (DFW);Denver, CO, United States - (DEN);Detroit, MI, United States - (DTW);Honolulu, HI, United States - (HNL);Houston, TX, United States - (IAH);Indianapolis, IN, United States - (IND);Jacksonville, FL, United States - (JAX);Kansas City, MO, United States - (MCI);Las Vegas, NV, United States - (LAS);Los Angeles, CA, United States - (LAX);McAllen, TX, United States - (MFE);Memphis, TN, United States - (MEM);Mexico City, Mexico - (MEX);Miami, FL, United States - (MIA);Minneapolis, MN, United States - (MSP);Montgomery, AL, United States - (MGM);Montréal, QC, Canada - (YUL);Nashville, TN, United States - (BNA);Newark, NJ, United States - (EWR);Norfolk, VA, United States - (ORF);Omaha, NE, United States - (OMA);Philadelphia, United States - (PHL);Phoenix, AZ, United States - (PHX);Pittsburgh, PA, United States - (PIT);Port-Au-Prince, Haiti - (PAP);Portland, OR, United States - (PDX);Queretaro, MX, Mexico - (QRO);Richmond, Virginia - (RIC);Sacramento, CA, United States - (SMF);Salt Lake City, UT, United States - (SLC);San Diego, CA, United States - (SAN);San Jose, CA, United States - (SJC);Saskatoon, SK, Canada - (YXE);Seattle, WA, United States - (SEA);St. Louis, MO, United States - (STL);Tampa, FL, United States - (TPA);Toronto, ON, Canada - (YYZ);Vancouver, BC, Canada - (YVR);Tallahassee, FL, United States - (TLH);Winnipeg, MB, Canada - (YWG);Adelaide, SA, Australia - (ADL);Auckland, New Zealand - (AKL);Brisbane, QLD, Australia - (BNE);Melbourne, VIC, Australia - (MEL);Noumea, New caledonia - (NOU);Perth, WA, Australia - (PER);Sydney, NSW, Australia - (SYD)".split(";"),e=a.split("colo=")[1].split("\n")[0],t=(a.split("colo=")[1].split("\n")[0],a.split("tls=")[1].split("\n")[0]),o=a.split("http=")[1].split("\n")[0],s=a.split("sni=")[1].split("\n")[0],r=a.split("ip=")[1].split("\n")[0],l=a.split("uag=")[1].split("\n")[0];for(var d=0;d<i.length;d++)if(-1!=i[d].indexOf(e)){document.getElementById("cdn").innerHTML=i[d];break}document.getElementById("tls").innerHTML=t,document.getElementById("http").innerHTML=o,document.getElementById("sni").innerHTML=s,document.getElementById("ip").innerHTML=r,document.getElementById("useragent").innerHTML=l}})},$(document).ready((function(){getCDNinfo()}))</script></p><p style="text-align:center">感谢陪伴与布道，开源之火不灭。​</p><p style="text-align:center"><script>document.write("本次加载耗时: "+(performance.getEntriesByType("navigation").reduce((e,r)=>e+r.responseEnd-r.startTime,0)+performance.getEntriesByType("resource").reduce((e,r)=>e+r.responseEnd-r.startTime,0)).toFixed(0)+"ms")</script></p><p style="text-align:center">当前 SNI 状态： <span id="sni">正在统计！或可能被浏览器防追踪拦截！</span></p><p style="text-align:center">当前 TLS 版本： <span id="tls">正在统计！或可能被浏览器防追踪拦截！</span></p><p style="text-align:center">当前 HTTP 版本： <span id="http">正在统计！或可能被浏览器防追踪拦截！</span></p><p style="text-align:center">当前您的客户端 IP 是： <span id="ip">正在统计！或可能被浏览器防追踪拦截！</span></p><p style="text-align:center">当前分配的 CDN 节点是: <span id="cdn">正在统计！或可能被浏览器防追踪拦截！</span></p><p style="text-align:center">您的 UserAgent 信息是: <span id="useragent">正在统计！或可能被浏览器防追踪拦截！</span></p><p></p></div></div></body></html>